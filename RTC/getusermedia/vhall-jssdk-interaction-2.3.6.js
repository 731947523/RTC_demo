/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/CallMain.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-runtime/core-js/get-iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/get-iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/get-iterator */ "./node_modules/core-js/library/fn/get-iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/json/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/json/stringify.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/json/stringify */ "./node_modules/core-js/library/fn/json/stringify.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/map.js":
/*!***************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/map.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/map */ "./node_modules/core-js/library/fn/map.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/assign.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/assign.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-own-property-names.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-names */ "./node_modules/core-js/library/fn/object/get-own-property-names.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/keys.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/keys.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/promise.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/promise.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/promise */ "./node_modules/core-js/library/fn/promise.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ "./node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol/iterator.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ "./node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/asyncToGenerator.js":
/*!****************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/asyncToGenerator.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(/*! ../core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/extends.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/extends.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(/*! ../core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/typeof.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/typeof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(/*! ../core-js/symbol/iterator */ "./node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(/*! ../core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "./node_modules/babel-runtime/regenerator/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/babel-runtime/regenerator/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime-module.js");


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/core-js/library/fn/get-iterator.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/get-iterator.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
module.exports = __webpack_require__(/*! ../modules/core.get-iterator */ "./node_modules/core-js/library/modules/core.get-iterator.js");


/***/ }),

/***/ "./node_modules/core-js/library/fn/json/stringify.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/json/stringify.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js");
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/map.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/library/fn/map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.map */ "./node_modules/core-js/library/modules/es6.map.js");
__webpack_require__(/*! ../modules/es7.map.to-json */ "./node_modules/core-js/library/modules/es7.map.to-json.js");
__webpack_require__(/*! ../modules/es7.map.of */ "./node_modules/core-js/library/modules/es7.map.of.js");
__webpack_require__(/*! ../modules/es7.map.from */ "./node_modules/core-js/library/modules/es7.map.from.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Map;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-own-property-names.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-own-property-names.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.get-own-property-names */ "./node_modules/core-js/library/modules/es6.object.get-own-property-names.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function getOwnPropertyNames(it) {
  return $Object.getOwnPropertyNames(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.keys */ "./node_modules/core-js/library/modules/es6.object.keys.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.keys;


/***/ }),

/***/ "./node_modules/core-js/library/fn/promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/library/fn/promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.promise */ "./node_modules/core-js/library/modules/es6.promise.js");
__webpack_require__(/*! ../modules/es7.promise.finally */ "./node_modules/core-js/library/modules/es7.promise.finally.js");
__webpack_require__(/*! ../modules/es7.promise.try */ "./node_modules/core-js/library/modules/es7.promise.try.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Promise;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.symbol */ "./node_modules/core-js/library/modules/es6.symbol.js");
__webpack_require__(/*! ../../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
__webpack_require__(/*! ../../modules/es7.symbol.observable */ "./node_modules/core-js/library/modules/es7.symbol.observable.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Symbol;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js").f('iterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-instance.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-instance.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-from-iterable.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-from-iterable.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-methods.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-methods.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/library/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-species-constructor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-species-constructor.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-species-create.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-species-create.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/library/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_classof.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_classof.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_cof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection-strong.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_collection-strong.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/library/modules/_redefine-all.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");
var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/library/modules/_set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").fastKey;
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/library/modules/_validate-collection.js");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection-to-json.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_collection-to-json.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/library/modules/_array-from-iterable.js");
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_collection.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/library/modules/_redefine-all.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/library/modules/_an-instance.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/library/modules/_array-methods.js")(0);
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_defined.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-keys.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_for-of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_for-of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_invoke.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_invoke.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iobject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array-iter.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array-iter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-call.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-call.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-create.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-define.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-detect.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-detect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-step.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iterators.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_meta.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_meta.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_microtask.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_microtask.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/library/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_new-promise-capability.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_new-promise-capability.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-assign.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dps.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopd.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopd.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn-ext.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn-ext.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gops.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gpo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-pie.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-sap.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-sap.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_perform.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_perform.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_promise-resolve.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_promise-resolve.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine-all.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine-all.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-collection-from.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-collection-from.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-collection-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-collection-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-species.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-species.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared-key.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_species-constructor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_species-constructor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-at.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_task.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_task.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/library/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-integer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-iobject.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-length.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_uid.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_user-agent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/core-js/library/modules/_validate-collection.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_validate-collection.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-define.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-define.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var get = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.map.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.map.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/library/modules/_collection-strong.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/library/modules/_validate-collection.js");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/library/modules/_collection.js")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.assign.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-property.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-own-property-names.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.get-own-property-names.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/library/modules/_object-gopn-ext.js").f;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.keys.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.keys.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.promise.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.promise.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/library/modules/_species-constructor.js");
var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/library/modules/_task.js").set;
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/library/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/library/modules/_perform.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/library/modules/_user-agent.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/library/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/library/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/library/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.symbol.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.symbol.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/library/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/library/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js");
var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.from.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.map.from.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/library/modules/_set-collection-from.js")('Map');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.map.of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/library/modules/_set-collection-of.js")('Map');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.to-json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.map.to-json.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/library/modules/_collection-to-json.js")('Map') });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.finally.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.promise.finally.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/library/modules/_species-constructor.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/library/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.try.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.promise.try.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/library/modules/_perform.js");

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.async-iterator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.observable.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('observable');


/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats['default']],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ "./node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*****************************************************************************!*\
  !*** (webpack)/node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./rtcbase/node_modules/expose-loader/index.js?adapter!./rtcbase/src/lib/adapter-7.3.0.js-exposed":
/*!***********************************************************************************************!*\
  !*** ./rtcbase/node_modules/expose-loader?adapter!./rtcbase/src/lib/adapter-7.3.0.js-exposed ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["adapter"] = __webpack_require__(/*! -!./adapter-7.3.0.js */ "./rtcbase/src/lib/adapter-7.3.0.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./rtcbase/src/Main.js":
/*!*****************************!*\
  !*** ./rtcbase/src/Main.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_Room__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/Room */ "./rtcbase/src/modules/Room.js");
/* harmony import */ var _modules_Stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/Stream */ "./rtcbase/src/modules/Stream.js");
/* harmony import */ var _modules_Tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/Tools */ "./rtcbase/src/modules/Tools.js");
/* harmony import */ var _common_Definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/Definition */ "./rtcbase/src/common/Definition.js");





// eslint-disable-next-line
__webpack_require__(/*! expose-loader?adapter!./lib/adapter-7.3.0.js */ "./rtcbase/node_modules/expose-loader/index.js?adapter!./rtcbase/src/lib/adapter-7.3.0.js-exposed");
const vhallcall = {
  Room: (specInput) => {
    return new _modules_Room__WEBPACK_IMPORTED_MODULE_0__["default"](specInput);
  },
  Stream: (specInput) => {
    return new _modules_Stream__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, specInput);
  },
  Tools: () => {
    return new _modules_Tools__WEBPACK_IMPORTED_MODULE_2__["default"]();
  },
  version: _common_Definition__WEBPACK_IMPORTED_MODULE_3__["Version"].version,
  date: _common_Definition__WEBPACK_IMPORTED_MODULE_3__["Version"].date
};

/* harmony default export */ __webpack_exports__["default"] = ({ vhallcall, Vhallcall: _common_Definition__WEBPACK_IMPORTED_MODULE_3__["Definition"] });


/***/ }),

/***/ "./rtcbase/src/common/Connection.js":
/*!******************************************!*\
  !*** ./rtcbase/src/common/Connection.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _webrtc_stacks_ChromeStableStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webrtc-stacks/ChromeStableStack */ "./rtcbase/src/webrtc-stacks/ChromeStableStack.js");
/* harmony import */ var _webrtc_stacks_FirefoxStack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webrtc-stacks/FirefoxStack */ "./rtcbase/src/webrtc-stacks/FirefoxStack.js");
/* harmony import */ var _webrtc_stacks_FcStack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webrtc-stacks/FcStack */ "./rtcbase/src/webrtc-stacks/FcStack.js");
/* harmony import */ var _uplog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uplog */ "./rtcbase/src/common/uplog.js");
/* global window, chrome, navigator */





let ErizoSessionId = 103;
var navigator = window.navigator;

const isMobileDevice = () => {
  return !!(/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || ''));
};

const getBrowserInfo = () => {
  var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);
  var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && ('netscape' in window) && / rv:/.test(navigator.userAgent);
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  var isChrome = !!window.chrome && !isOpera;
  var isIE = typeof document !== 'undefined' && !!document.documentMode && !isEdge;

  var nVer = navigator.appVersion;
  var nAgt = navigator.userAgent;
  var browserName = navigator.appName;
  var fullVersion = '' + parseFloat(navigator.appVersion);
  var majorVersion = parseInt(navigator.appVersion, 10);
  var nameOffset, verOffset, ix;

  // In Opera, the true version is after 'Opera' or after 'Version'
  if (isOpera) {
      browserName = 'Opera';
      try {
          fullVersion = navigator.userAgent.split('OPR/')[1].split(' ')[0];
          majorVersion = fullVersion.split('.')[0];
      } catch (e) {
          fullVersion = '0.0.0.0';
          majorVersion = 0;
      }
  }
  // In MSIE version <=10, the true version is after 'MSIE' in userAgent
  // In IE 11, look for the string after 'rv:'
  else if (isIE) {
      verOffset = nAgt.indexOf('rv:');
      if (verOffset > 0) { //IE 11
          fullVersion = nAgt.substring(verOffset + 3);
      } else { //IE 10 or earlier
          verOffset = nAgt.indexOf('MSIE');
          fullVersion = nAgt.substring(verOffset + 5);
      }
      browserName = 'IE';
  }
  // In Chrome, the true version is after 'Chrome' 
  else if (isChrome) {
      verOffset = nAgt.indexOf('Chrome');
      browserName = 'Chrome';
      fullVersion = nAgt.substring(verOffset + 7);
  }
  // In Safari, the true version is after 'Safari' or after 'Version' 
  else if (isSafari) {
      // both and safri and chrome has same userAgent
      if (nAgt.indexOf('CriOS') !== -1) {
          verOffset = nAgt.indexOf('CriOS');
          browserName = 'Chrome';
          fullVersion = nAgt.substring(verOffset + 6);
      } else if (nAgt.indexOf('FxiOS') !== -1) {
          verOffset = nAgt.indexOf('FxiOS');
          browserName = 'Firefox';
          fullVersion = nAgt.substring(verOffset + 6);
      } else {
          verOffset = nAgt.indexOf('Safari');

          browserName = 'Safari';
          fullVersion = nAgt.substring(verOffset + 7);

          if ((verOffset = nAgt.indexOf('Version')) !== -1) {
              fullVersion = nAgt.substring(verOffset + 8);
          }

          if (navigator.userAgent.indexOf('Version/') !== -1) {
              fullVersion = navigator.userAgent.split('Version/')[1].split(' ')[0];
          }
      }
  }
  // In Firefox, the true version is after 'Firefox' 
  else if (isFirefox) {
      verOffset = nAgt.indexOf('Firefox');
      browserName = 'Firefox';
      fullVersion = nAgt.substring(verOffset + 8);
  }

  // In most other browsers, 'name/version' is at the end of userAgent 
  else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
      browserName = nAgt.substring(nameOffset, verOffset);
      fullVersion = nAgt.substring(verOffset + 1);

      if (browserName.toLowerCase() === browserName.toUpperCase()) {
          browserName = navigator.appName;
      }
  }

  if (isEdge) {
      browserName = 'Edge';
      fullVersion = navigator.userAgent.split('Edge/')[1];
      // fullVersion = parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10).toString();
  }

  // trim the fullVersion string at semicolon/space/bracket if present
  if ((ix = fullVersion.search(/[; \)]/)) !== -1) {
      fullVersion = fullVersion.substring(0, ix);
  }

  majorVersion = parseInt('' + fullVersion, 10);

  if (isNaN(majorVersion)) {
      fullVersion = '' + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
  }

  return {
      fullVersion: fullVersion,
      version: majorVersion,
      name: browserName.toLowerCase(),
  };
};

const getBrowser = () => {
  let browser = 'none';

  if (( true && module.exports)) {
    browser = 'fake';
  } else if (window.navigator.userAgent.match('Firefox') !== null) {
    browser = 'mozilla';
  } else if (window.navigator.userAgent.match('Chrome') !== null) {
    browser = 'chrome-stable';
    if (window.navigator.userAgent.match('Electron') !== null) {
      browser = 'electron';
    }
  } else if (window.navigator.userAgent.match('Safari') !== null) {
    browser = 'safari';
  } else if (window.navigator.userAgent.match('AppleWebKit') !== null) {
    browser = 'safari';
  }
  return browser;
};

const getOS = () => {
  var unknown = '-';

  var nVer = navigator.appVersion;
  var nAgt = navigator.userAgent;

  var os = unknown;
  var clientStrings = [{
    s: 'Chrome OS',
    r: /CrOS/
  }, {
    s: 'Windows 10',
    r: /(Windows 10.0|Windows NT 10.0)/
  }, {
    s: 'Windows 8.1',
    r: /(Windows 8.1|Windows NT 6.3)/
  }, {
    s: 'Windows 8',
    r: /(Windows 8|Windows NT 6.2)/
  }, {
    s: 'Windows 7',
    r: /(Windows 7|Windows NT 6.1)/
  }, {
    s: 'Windows Vista',
    r: /Windows NT 6.0/
  }, {
    s: 'Windows Server 2003',
    r: /Windows NT 5.2/
  }, {
    s: 'Windows XP',
    r: /(Windows NT 5.1|Windows XP)/
  }, {
    s: 'Windows 2000',
    r: /(Windows NT 5.0|Windows 2000)/
  }, {
    s: 'Windows ME',
    r: /(Win 9x 4.90|Windows ME)/
  }, {
    s: 'Windows 98',
    r: /(Windows 98|Win98)/
  }, {
    s: 'Windows 95',
    r: /(Windows 95|Win95|Windows_95)/
  }, {
    s: 'Windows NT 4.0',
    r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
  }, {
    s: 'Windows CE',
    r: /Windows CE/
  }, {
    s: 'Windows 3.11',
    r: /Win16/
  }, {
    s: 'Android',
    r: /Android/
  }, {
    s: 'Open BSD',
    r: /OpenBSD/
  }, {
    s: 'Sun OS',
    r: /SunOS/
  }, {
    s: 'Linux',
    r: /(Linux|X11)/
  }, {
    s: 'iOS',
    r: /(iPhone|iPad|iPod)/
  }, {
    s: 'Mac OS X',
    r: /Mac OS X/
  }, {
    s: 'Mac OS',
    r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
  }, {
    s: 'QNX',
    r: /QNX/
  }, {
    s: 'UNIX',
    r: /UNIX/
  }, {
    s: 'BeOS',
    r: /BeOS/
  }, {
    s: 'OS/2',
    r: /OS\/2/
  }, {
    s: 'Search Bot',
    r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
  }];
  for (var i = 0, cs; cs = clientStrings[i]; i++) {
    if (cs.r.test(nAgt)) {
      os = cs.s;
      break;
    }
  }

  var osVersion = unknown;

  if (/Windows/.test(os)) {
    if (/Windows (.*)/.test(os)) {
      osVersion = /Windows (.*)/.exec(os)[1];
    }
    os = 'Windows';
  }

  switch (os) {
    case 'Mac OS X':
      if (/Mac OS X (10[\.\_\d]+)/.test(nAgt)) {
        osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
      }
      break;
    case 'Android':
      if (/Android ([\.\_\d]+)/.test(nAgt)) {
        osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
      }
      break;
    case 'iOS':
      if (/OS (\d+)_(\d+)_?(\d+)?/.test(nAgt)) {
        osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
        if (osVersion && osVersion.length > 3) {
          osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
        }
      }
      break;
  }

  return {
    osName: os.toLowerCase(),
    osVersion: osVersion
  };
};

const buildConnection = (specInput) => {
  let that = {};
  const spec = specInput;
  ErizoSessionId += 1;
  spec.sessionId = ErizoSessionId;

  // Check which WebRTC Stack is installed.
  that.browser = getBrowser();
  if (that.browser === 'fake') {
    _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('Publish/subscribe video/audio streams not supported in erizofc yet', { streamId: spec.streamId });
    that = Object(_webrtc_stacks_FcStack__WEBPACK_IMPORTED_MODULE_2__["default"])(spec);
  } else if (that.browser === 'mozilla') {
    // log.info('Firefox Stack', { streamId: spec.streamId });
    that = Object(_webrtc_stacks_FirefoxStack__WEBPACK_IMPORTED_MODULE_1__["default"])(spec);
  } else if (that.browser === 'safari') {
    // log.info('Safari using Chrome Stable Stack', { streamId: spec.streamId });
    that = Object(_webrtc_stacks_ChromeStableStack__WEBPACK_IMPORTED_MODULE_0__["default"])(spec);
  } else if (that.browser === 'chrome-stable' || that.browser === 'electron') {
    // log.info('Chrome Stable Stack', { streamId: spec.streamId });
    that = Object(_webrtc_stacks_ChromeStableStack__WEBPACK_IMPORTED_MODULE_0__["default"])(spec);
  } else {
    _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('No stack available for this browser', { streamId: spec.streamId });
    throw new Error('WebRTC stack not available');
  }
  if (!that.updateSpec) {
    that.updateSpec = (newSpec, callback = () => {}) => {
      _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('Update Configuration not implemented in this browser', { streamId: spec.streamId });
      callback();
    };
  }

  return that;
};

const GetUserMedia = (config, callback = () => {}, error = () => {}) => {
  let screenConfig;

  const getUserMedia = (userMediaConfig, cb, errorCb) => {
    navigator.mediaDevices.getUserMedia(userMediaConfig).then(cb).catch(errorCb);
  };

  const configureScreensharing = () => {
    _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].debug('Screen access requested');
    switch (getBrowser()) {
    case 'electron' :
      screenConfig = {};
      const osInfo = getOS();
      if (osInfo.osName == 'Windows') {
        screenConfig.audio = config.audio;
      } else {
        screenConfig.audio = false;
      }
      screenConfig.video = config.video;
      _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].info(`screen sharing in Electron. config=${JSON.stringify(screenConfig)}`);
      getUserMedia(screenConfig, callback, error);
      break;
    case 'mozilla':
      _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].info('Screen sharing in Firefox');
      screenConfig = {};
      if (config.video !== undefined) {
        screenConfig.video = config.video;
        screenConfig.video.mediaSource = 'window' || false;
      } else {
        screenConfig = {
          audio: config.audio,
          video: { mediaSource: 'window' || false }
        };
      }
      getUserMedia(screenConfig, callback, error);
      break;

    case 'chrome-stable':
      _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].info('Screen sharing in Chrome');
      screenConfig = {};
      if (config.desktopStreamId) {
        screenConfig.video = config.video || { mandatory: {} };
        screenConfig.video.mandatory = screenConfig.video.mandatory || {};
        screenConfig.video.mandatory.chromeMediaSource = 'desktop';
        screenConfig.video.mandatory.chromeMediaSourceId = config.desktopStreamId;
        getUserMedia(screenConfig, callback, error);
      } else if (navigator.mediaDevices.getDisplayMedia) {
        let videoConfig = true;
        if (config.video && config.video.width && config.video.height) {
          videoConfig = { width: {}, height: {} };
          videoConfig.width = config.video.width.max;
          // videoConfig.width.min = config.video.width.min;
          videoConfig.height = config.video.height.max;
          // videoConfig.height.min = config.video.height.min;
          if (config.video.frameRate) {
            videoConfig.frameRate = {};
            videoConfig.frameRate = config.video.frameRate.max;
            // screenConfig.video.frameRate.min = config.video.frameRate.min;
          }
        }
        navigator.mediaDevices.getDisplayMedia({ video: videoConfig, audio: config.screenSpeaker }).then((stream) => {
          if (config.screenSpeaker || !config.audio) {
            callback(stream);
          } else {
            // screenSpeaker为false && audio为true
            getUserMedia({ video: false, audio: config.audio }, (audioStream) => {
              audioStream.getAudioTracks().forEach((track) => {
                stream.addTrack(track);
              });
              audioStream.getTracks().forEach((trackInput) => {
                audioStream.removeTrack(trackInput);
              });
              audioStream = undefined;
              callback(stream);
            }, () => {
              callback(stream);
            });
          }
        }).catch((e) => {
          error(e);
        });
      } else {
        // Default extensionId - this extension is only usable in our server,
        // please make your own extension based on the code in
        // erizo_controller/erizoClient/extras/chrome-extension
        let extensionId = 'omakdpbabdhobphckndjamjoggpnemml';
        if (config.extensionId) {
          _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].info(`extensionId supplied, using ${config.extensionId}`);
          extensionId = config.extensionId;
        }
        _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].info('Screen access on chrome stable, looking for extension');
        try {
          chrome.runtime.sendMessage(extensionId, { getStream: true },
            (response) => {
              if (response === undefined) {
                _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('Access to screen denied');
                const theError = { code: 'Access to screen denied' };
                error(theError);
                return;
              }
              const theId = response.streamId;
              _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].debug('Screen response options', { Collapsed: response.options });
              if (config.video.mandatory !== undefined) {
                screenConfig.video = config.video;
                screenConfig.video.mandatory.chromeMediaSource = 'desktop';
                screenConfig.video.mandatory.chromeMediaSourceId = theId;
              } else {
                screenConfig = { video: { mandatory: { chromeMediaSource: 'desktop',
                  chromeMediaSourceId: theId } } };
                if (config.video.width && config.video.height) {
                  screenConfig.video.mandatory.maxWidth = config.video.width.max;
                  screenConfig.video.mandatory.maxHeight = config.video.height.max;
                }
                if (config.video.frameRate) {
                  screenConfig.video.mandatory.maxFrameRate = config.video.frameRate.max;
                }
                if (response.options.canRequestAudioTrack) {
                  screenConfig.audio = { mandatory: { chromeMediaSource: 'desktop',
                    chromeMediaSourceId: theId } };
                }
              }
              getUserMedia(screenConfig, callback, error);
            });
        } catch (e) {
          _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('Screensharing plugin is not accessible ');
          const theError = { code: 'no_plugin_present' };
          error(theError);
        }
      }
      break;

    case 'safari':
      if (navigator.mediaDevices.getDisplayMedia) {
        let videoConfig = true;
        if (config.video && config.video.width && config.video.height) {
          videoConfig = { width: {}, height: {} };
          videoConfig.width = config.video.width.max;
          // videoConfig.width.min = config.video.width.min;
          videoConfig.height = config.video.height.max;
          // videoConfig.height.min = config.video.height.min;
          if (config.video.frameRate) {
            videoConfig.frameRate = {};
            videoConfig.frameRate = config.video.frameRate.max;
            // screenConfig.video.frameRate.min = config.video.frameRate.min;
          }
        }
        navigator.mediaDevices.getDisplayMedia({ video: videoConfig, audio: config.screenSpeaker }).then((stream) => {
          if (config.screenSpeaker || !config.audio) {
            callback(stream);
          } else {
            getUserMedia({ video: false, audio: config.audio }, (audioStream) => {
              audioStream.getAudioTracks().forEach((track) => {
                stream.addTrack(track);
              });
              audioStream.getTracks().forEach((trackInput) => {
                audioStream.removeTrack(trackInput);
              });
              audioStream = undefined;
              callback(stream);
            }, () => {
              callback(stream);
            });
          }
        }).catch((e) => {
          error(e);
        });
      } else {
        _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('This version of safari does not support desktop sharing');
        const theError = { code: 'browser version is too old' };
        error(theError);
      }
      break;

    default:
      _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('This browser does not support ScreenSharing');
    }
  };

  if (config.screen) {
    configureScreensharing();
    return;
  } 
  else if (config.hasInsertedStream && config.insertedStream) {
    if (config.insertedStream.getTracks().length > 0) {
      callback(config.insertedStream);
      return;
    } else {
      const theError = { name: 'InsertedStreamError', code: 0, message: 'insertedStream not correct' };
      error(theError);
      return;
    }
  } 
  else if (config.audioTrack && config.videoTrack) { // 如果传入音频track和视频track，则不采集硬件设备
    callback(new MediaStream());
    return;
  }
  else if ((config.audioTrack || config.videoTrack) && (!config.video && !config.audio)) { // 如果仅传入一个track,且video/audio均为false，则不采集硬件设备
    callback(new MediaStream());
    return;
  }
  else {  // 如果仅传入一个track, 且video/audio不全为false，则适用于插播图片+麦克风的场景
    getUserMedia(config, callback, error);
    return;
  }
};

const getExtensionVersion = (callback, extId) => {
  if (getBrowser() !== 'chrome-stable') {
    callback(undefined);
    return;
  }
  let extensionId = 'omakdpbabdhobphckndjamjoggpnemml';
  if (extId) {
    extensionId = extId;
  }
  chrome.runtime.sendMessage(extensionId, { getVersion: true },
    (response) => {
      if (response === undefined) {
        callback(response);
      } else {
        const theVersion = response.version;
        if (theVersion) {
          callback(theVersion);
        } else {
          callback(undefined);
        }
      }
    });
};

/**
 * 获取设备权限，触发浏览器弹出权限选择框。
 * @param device
 * @returns {Promise<undefined>}
 * @constructor
 */
function AccessPermissions(device = '') {
  let config = {};
  return new Promise((resolve) => {
    if (device === 'video') {
      config = { video: true, audio: false };
    } else if (device === 'audio') {
      config = { video: false, audio: true };
    } else {
      resolve();
      return;
    }
    navigator.mediaDevices.getUserMedia(config).then((stream) => {
      stream.getTracks().forEach((trackInput) => {
        trackInput.stop();
      });
      resolve();
    }).catch(() => {
      resolve();
    });
  });
}

const EnumerateDevices = (callback = () => {}, error = () => {}) => {
  const browserDevices = {
    audioInputDevices: [],
    audioOutputDevices: [],
    videoInputDevices: [],
    videoOutputDevices: []
  };

  let audioAccess = '';
  let videoAccess = '';
  navigator.mediaDevices.enumerateDevices().then((devices) => {
    devices.forEach((device) => {
      if (device.kind === 'audioinput' && device.label === '') {
        audioAccess = 'audio';
      } else if (device.kind === 'videoinput' && device.label === '') {
        videoAccess = 'video';
      }
    });
  }).then(() => AccessPermissions(videoAccess))
    .then(() => AccessPermissions(audioAccess))
    .then(() => navigator.mediaDevices.enumerateDevices())
    .then((devices) => {
      devices.forEach((device) => {
        if (device.kind === 'audioinput') {
          browserDevices.audioInputDevices.push(device);
        } else if (device.kind === 'videoinput') {
          browserDevices.videoInputDevices.push(device);
        } else if (device.kind === 'audiooutput') {
          browserDevices.audioOutputDevices.push(device);
        } else if (device.kind === 'videooutput') {
          browserDevices.videoOutputDevices.push(device);
        }
      });
      if (navigator.mediaDevices.getDisplayMedia) {
        browserDevices.videoInputDevices.push({ deviceId: 'desktopScreen', groupId: '', kind: 'videoinput', label: '桌面共享' });
      }else {
        try {
          getExtensionVersion((theVersion) => {
            if (theVersion) {
              browserDevices.videoInputDevices.push({ deviceId: 'desktopScreen', groupId: '', kind: 'videoinput', label: '桌面共享' });
            }
          });
        } catch (e) {
          _uplog__WEBPACK_IMPORTED_MODULE_3__["default"].error('Screen sharing plugin is not accessible');
        }
      }
      callback(browserDevices);
    })
    .catch((err) => {
      error(err);
    });
};

const Connection = {
  GetUserMedia,
  buildConnection,
  EnumerateDevices,
  getExtensionVersion,
  isMobileDevice,
  getBrowserInfo,
  getBrowser,
  getOS,
};

/* harmony default export */ __webpack_exports__["default"] = (Connection);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./rtcbase/src/common/Definition.js":
/*!******************************************!*\
  !*** ./rtcbase/src/common/Definition.js ***!
  \******************************************/
/*! exports provided: Definition, QUICKSCAN, QUICKSCAN_V2, K, Version, Permission */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Definition", function() { return Definition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUICKSCAN", function() { return QUICKSCAN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUICKSCAN_V2", function() { return QUICKSCAN_V2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return K; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Version", function() { return Version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Permission", function() { return Permission; });
const Version = {
  version: "2.3.6",
  date: "2021/11/1"
};

const Permission = {
  OWNER: 'owner',
  PUBLISH: 'publish',
  SUBSCRIBE: 'subscribe',
}

const Definition = {
  // v2 screen_profile, from http://wiki.vhallops.com/pages/viewpage.action?pageId=76218457
  RTC_SCREEN_PROFILE_1080P_4x3_M: { videoSize: [960, 720, 1440, 1080], videoFrameRate: [5, 5], bitRate: [500, 1300], ratio: 4 / 3 },
  RTC_SCREEN_PROFILE_1080P_4x3_H: { videoSize: [960, 720, 1440, 1080], videoFrameRate: [15, 25], bitRate: [500, 1800], ratio: 4 / 3 },
  RTC_SCREEN_PROFILE_1080P_16x9_M: { videoSize: [1280, 720, 1920, 1080], videoFrameRate: [5, 5], bitRate: [500, 1600], ratio: 16 / 9 },
  RTC_SCREEN_PROFILE_1080P_16x9_H: { videoSize: [1280, 720, 1920, 1080], videoFrameRate: [15, 25], bitRate: [500, 2200], ratio: 16 / 9 },
  RTC_SCREEN_PROFILE_720P_4x3_M: { videoSize: [720, 540, 960, 720], videoFrameRate: [5, 5], bitRate: [500, 900], ratio: 4 / 3 },
  RTC_SCREEN_PROFILE_720P_4x3_H: { videoSize: [480, 360, 960, 720], videoFrameRate: [15, 25], bitRate: [500, 1400], ratio: 4 / 3 },
  RTC_SCREEN_PROFILE_720P_16x9_M: { videoSize: [1280, 720, 1280, 720], videoFrameRate: [5, 5], bitRate: [500, 1050], ratio: 16 / 9 },
  RTC_SCREEN_PROFILE_720P_16x9_H: { videoSize: [640, 360, 1280, 720], videoFrameRate: [15, 25], bitRate: [500, 1600], ratio: 16 / 9 },
  RTC_SCREEN_PROFILE_540P_4x3_M: { videoSize: [640, 480, 720, 540], videoFrameRate: [5, 5], bitRate: [400, 800], ratio: 4 / 3 },
  RTC_SCREEN_PROFILE_540P_4x3_H: { videoSize: [640, 480, 720, 540], videoFrameRate: [15, 25], bitRate: [400, 950], ratio: 4 / 3 },
  RTC_SCREEN_PROFILE_540P_16x9_M: { videoSize: [960, 540, 960, 540], videoFrameRate: [5, 5], bitRate: [400, 950], ratio: 16 / 9 },
  RTC_SCREEN_PROFILE_540P_16x9_H: { videoSize: [848, 480, 960, 540], videoFrameRate: [15, 25], bitRate: [400, 1150], ratio: 16 / 9 },
  // v2 video_profile, from http://wiki.vhallops.com/pages/viewpage.action?pageId=76218457
  RTC_VIDEO_PROFILE_1080P_4x3_M: { videoSize: [640, 480, 1440, 1080], videoFrameRate: [10, 15], bitRate: [600, 1500], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_1080P_4x3_H: { videoSize: [640, 480, 1440, 1080], videoFrameRate: [15, 25], bitRate: [600, 1750], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_1080P_16x9_M: { videoSize: [848, 480, 1920, 1080], videoFrameRate: [10, 15], bitRate: [600, 1700], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_1080P_16x9_H: { videoSize: [848, 480, 1920, 1080], videoFrameRate: [15, 25], bitRate: [600, 2000], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_720P_4x3_M: { videoSize: [480, 360, 960, 720], videoFrameRate: [10, 15], bitRate: [500, 1050], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_720P_4x3_H: { videoSize: [480, 360, 960, 720], videoFrameRate: [15, 25], bitRate: [500, 1300], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_720P_16x9_M: { videoSize: [640, 360, 1280, 720], videoFrameRate: [10, 15], bitRate: [500, 1200], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_720P_16x9_H: { videoSize: [640, 360, 1280, 720], videoFrameRate: [15, 25], bitRate: [500, 1450], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_540P_4x3_M: { videoSize: [480, 360, 720, 540], videoFrameRate: [10, 15], bitRate: [400, 700], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_540P_4x3_H: { videoSize: [480, 360, 720, 540], videoFrameRate: [15, 25], bitRate: [400, 900], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_540P_16x9_M: { videoSize: [640, 360, 960, 540], videoFrameRate: [10, 15], bitRate: [400, 800], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_540P_16x9_H: { videoSize: [640, 360, 960, 540], videoFrameRate: [15, 25], bitRate: [400, 950], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_480P_4x3_M: { videoSize: [240, 180, 640, 480], videoFrameRate: [10, 15], bitRate: [300, 600], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_480P_4x3_H: { videoSize: [240, 180, 640, 480], videoFrameRate: [15, 25], bitRate: [300, 700], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_480P_16x9_M: { videoSize: [320, 180, 848, 480], videoFrameRate: [10, 15], bitRate: [300, 750], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_480P_16x9_H: { videoSize: [320, 180, 848, 480], videoFrameRate: [15, 25], bitRate: [300, 900], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_360P_4x3_M: { videoSize: [240, 180, 480, 360], videoFrameRate: [10, 15], bitRate: [200, 350], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_360P_4x3_H: { videoSize: [240, 180, 480, 360], videoFrameRate: [15, 25], bitRate: [200, 450], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_360P_16x9_M: { videoSize: [320, 180, 640, 360], videoFrameRate: [10, 15], bitRate: [200, 450], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_360P_16x9_H: { videoSize: [320, 180, 640, 360], videoFrameRate: [15, 25], bitRate: [200, 500], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_240P_4x3_M: { videoSize: [160, 120, 320, 240], videoFrameRate: [10, 15], bitRate: [200, 300], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_240P_4x3_H: { videoSize: [160, 120, 320, 240], videoFrameRate: [15, 25], bitRate: [250, 380], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_240P_16x9_M: { videoSize: [160, 90, 424, 240], videoFrameRate: [10, 15], bitRate: [220, 350], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_240P_16x9_H: { videoSize: [160, 90, 424, 240], videoFrameRate: [15, 25], bitRate: [300, 450], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_180P_4x3_M: { videoSize: [160, 120, 240, 180], videoFrameRate: [10, 15], bitRate: [190, 290], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_180P_4x3_H: { videoSize: [160, 120, 240, 180], videoFrameRate: [15, 25], bitRate: [220, 350], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_180P_16x9_M: { videoSize: [160, 90, 320, 180], videoFrameRate: [10, 15], bitRate: [190, 290], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_180P_16x9_H: { videoSize: [160, 90, 320, 180], videoFrameRate: [15, 25], bitRate: [220, 350], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_120P_4x3_M: { videoSize: [160, 120, 160, 120], videoFrameRate: [10, 15], bitRate: [150, 200], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_120P_4x3_H: { videoSize: [160, 120, 160, 120], videoFrameRate: [15, 25], bitRate: [210, 280], ratio: 4 / 3 },
  RTC_VIDEO_PROFILE_120P_16x9_M: { videoSize: [160, 90, 160, 90], videoFrameRate: [10, 15], bitRate: [120, 180], ratio: 16 / 9 },
  RTC_VIDEO_PROFILE_120P_16x9_H: { videoSize: [160, 90, 160, 90], videoFrameRate: [15, 25], bitRate: [160, 250], ratio: 16 / 9 },

  // audio profile, see https://tools.ietf.org/html/rfc7587
  RTC_AUDIO_PROFILE_LOW: { maxaveragebitrate: 24000, maxplaybackrate: 16000, stereo: 0 },
  RTC_AUDIO_PROFILE_STANDARD: { maxaveragebitrate: 40000, maxplaybackrate: 48000, stereo: 0 },
  // RTC_AUDIO_PROFILE_STANDARD_STEREO: { maxaveragebitrate: 40000, maxplaybackrate: 48000, stereo: 1 },
  RTC_AUDIO_PROFILE_HIGH: { maxaveragebitrate: 128000, maxplaybackrate: 48000, stereo: 0 },
  // RTC_AUDIO_PROFILE_HIGH_STEREO: { maxaveragebitrate: 192000, maxplaybackrate: 48000, stereo: 1 },

  // 旁路视频Profile
  BROADCAST_VIDEO_PROFILE_480P_0: { resolution: [640, 480], framerate: 25, bitrate: 700 },
  BROADCAST_VIDEO_PROFILE_480P_1: { resolution: [848, 480], framerate: 25, bitrate: 750 },
  BROADCAST_VIDEO_PROFILE_540P_0: { resolution: [720, 540], framerate: 25, bitrate: 950 },
  BROADCAST_VIDEO_PROFILE_540P_1: { resolution: [960, 540], framerate: 25, bitrate: 1150 },
  BROADCAST_VIDEO_PROFILE_720P_0: { resolution: [960, 720], framerate: 25, bitrate: 1400 },
  BROADCAST_VIDEO_PROFILE_720P_1: { resolution: [1280, 720], framerate: 25, bitrate: 1600 },
  BROADCAST_VIDEO_PROFILE_960P_0: { resolution: [1280, 960], framerate: 25, bitrate: 1600 },
  BROADCAST_VIDEO_PROFILE_960P_1: { resolution: [1712, 960], framerate: 25, bitrate: 1900 },
  BROADCAST_VIDEO_PROFILE_1080P_0: { resolution: [1440, 1080], framerate: 25, bitrate: 1800 },
  BROADCAST_VIDEO_PROFILE_1080P_1: { resolution: [1920, 1080], framerate: 25, bitrate: 2200 },
  // 增加竖屏旁路
  BROADCAST_VIDEO_PROFILE_480P_1_VERTICAL: { resolution: [480, 848], framerate: 25, bitrate: 750 },
  BROADCAST_VIDEO_PROFILE_540P_1_VERTICAL: { resolution: [540, 960], framerate: 25, bitrate: 1150 },
  BROADCAST_VIDEO_PROFILE_720P_1_VERTICAL: { resolution: [720, 1280], framerate: 25, bitrate: 1600 },
  BROADCAST_VIDEO_PROFILE_1080P_1_VERTICAL: { resolution: [1080, 1920], framerate: 25, bitrate: 2200 },

  // 旁路窗格裁剪模式
  BROADCAST_CROP_TYPE_NONE: 0,    /* 等比缩放至窗格 */
  BROADCAST_CROP_TYPE_CENTER: 1,  /* 将原图裁剪为窗格宽高比，再缩放填满窗格 */
  BROADCAST_CROP_TYPE_FIT: 2,     /* 不保持原图宽高比，拉伸铺满窗格 */

  // 旁路窗格宽高比
  BROADCAST_PANE_ASPACT_RATIO_4_3: 0,
  BROADCAST_PANE_ASPACT_RATIO_16_9: 1,

  // 旁路混流自适应布局模式
  CANVAS_ADAPTIVE_LAYOUT_GRID_MODE: 1,  // 均分布局
  CANVAS_ADAPTIVE_LAYOUT_TILED_MODE: 2, // 平铺布局
  CANVAS_ADAPTIVE_LAYOUT_FLOAT_MODE: 3, // 悬浮布局

  // 旁路混流特定布局模板
  CANVAS_LAYOUT_PATTERN_GRID_1: 0,
  CANVAS_LAYOUT_PATTERN_GRID_2_H: 1,
  CANVAS_LAYOUT_PATTERN_GRID_3_E: 2,
  CANVAS_LAYOUT_PATTERN_GRID_3_D: 3,
  CANVAS_LAYOUT_PATTERN_GRID_4_M: 4,
  CANVAS_LAYOUT_PATTERN_GRID_5_D: 5,
  CANVAS_LAYOUT_PATTERN_GRID_6_E: 6,
  CANVAS_LAYOUT_PATTERN_GRID_9_E: 7,
  CANVAS_LAYOUT_PATTERN_FLOAT_2_1DR: 8,
  CANVAS_LAYOUT_PATTERN_FLOAT_2_1DL: 9,
  CANVAS_LAYOUT_PATTERN_FLOAT_3_2DL: 10,
  CANVAS_LAYOUT_PATTERN_FLOAT_6_5D: 11,
  CANVAS_LAYOUT_PATTERN_FLOAT_6_5T: 12,
  CANVAS_LAYOUT_PATTERN_TILED_5_1T4D: 13,
  CANVAS_LAYOUT_PATTERN_TILED_5_1D4T: 14,
  CANVAS_LAYOUT_PATTERN_TILED_5_1L4R: 15,
  CANVAS_LAYOUT_PATTERN_TILED_5_1R4L: 16,
  CANVAS_LAYOUT_PATTERN_TILED_6_1T5D: 17,
  CANVAS_LAYOUT_PATTERN_TILED_6_1D5T: 18,
  CANVAS_LAYOUT_PATTERN_TILED_9_1L8R: 19,
  CANVAS_LAYOUT_PATTERN_TILED_9_1R8L: 20,
  CANVAS_LAYOUT_PATTERN_TILED_13_1L12R: 21,
  CANVAS_LAYOUT_PATTERN_TILED_17_1TL16GRID: 22,
  CANVAS_LAYOUT_PATTERN_TILED_9_1D8T: 23,
  CANVAS_LAYOUT_PATTERN_TILED_13_1TL12GRID: 24,
  CANVAS_LAYOUT_PATTERN_TILED_17_1TL16GRID_E: 25,
  CANVAS_LAYOUT_PATTERN_CUSTOM: 27,
  CANVAS_LAYOUT_EX_PATTERN_GRID_12_E: 28,
  CANVAS_LAYOUT_EX_PATTERN_GRID_16_E: 29,
  CANVAS_LAYOUT_EX_PATTERN_FLOAT_2_1TR: 30,
  CANVAS_LAYOUT_EX_PATTERN_FLOAT_2_1TL: 31,

  // video codecs
  CODECS_VP8: 'VP8',
  CODECS_VP9: 'VP9',
  CODECS_H264: 'H264',
  CODECS_H265: 'H265',
  CODECS_AV1: 'AV1',

  // 日志等级分类
  LOG_ALL: 1,
  LOG_INFO: 2,
  LOG_WARN: 3,
  LOG_ERROR: 4,
  LOG_NONE: 5, 

  // 日志上报分类
  LOG_ENABLE_REPORT: 1, // 开启上报
  LOG_DISABLE_REPORT: 2, // 关闭上报  仅包含链路
  LOG_DISABLE_ALL_REPORT: 3, // 关闭上报  包含链路和计费

  // 以下不建议使用，择机删除
  // v1.0
  BROADCAST_LAYOUT_SPLIT_GRID: 4,
  BROADCAST_LAYOUT_SPLIT_OVERLAP: 8,
  BROADCAST_LAYOUT_SPLIT_TOPSIDE: 14,
  BROADCAST_LAYOUT_SPLIT_BOTTOMSIDE: 13,
  BROADCAST_LAYOUT_SPLIT_TOPSIDE_5: 18,
  BROADCAST_LAYOUT_SPLIT_BOTTOMSIDE_5: 17,
  BROADCAST_LAYOUT_SPLIT_ONLYONE: 0,
  // crop
  CROP_TYPE_NONE: 0,
  CROP_TYPE_1_1: 1,
  CROP_TYPE_4_3: 2,
  CROP_TYPE_16_9: 3,
  CROP_TYPE_AUTO: 4,
  // v1，不推荐使用，旁路输出视频参数(分辨率)
  BROADCAST_VIDEO_RESOLUTION_NORMAL: [1280, 720],
  BROADCAST_VIDEO_RESOLUTION_480P: [848, 480],
  BROADCAST_VIDEO_RESOLUTION_540P: [960, 540],
  BROADCAST_VIDEO_RESOLUTION_720P: [1280, 720],
  BROADCAST_VIDEO_RESOLUTION_960P: [1712, 960],
  BROADCAST_VIDEO_RESOLUTION_1080P: [1920, 1080],
  // v1，不推荐使用，旁路输出视频参数(帧率)
  BROADCAST_VIDEO_FRAMERATE_NORMAL: 20,
  BROADCAST_VIDEO_FRAMERATE_15: 15,
  BROADCAST_VIDEO_FRAMERATE_20: 20,
  BROADCAST_VIDEO_FRAMERATE_25: 25,
  // v1，不推荐使用，旁路输出视频参数(码率)
  BROADCAST_VIDEO_BITRATE_NORMAL: 1600,
  BROADCAST_VIDEO_BITRATE_LOW: 750,
  BROADCAST_VIDEO_BITRATE_MEDIUN: 1600,
  BROADCAST_VIDEO_BITRATE_HIGH: 2200,
  // v1，不推荐使用，互动视频分辨率
  VIDEO_QUALITY_NORMAL: [320, 240, 320, 240],
  VIDEO_QUALITY_LOW: [160, 120, 160, 120],
  VIDEO_QUALITY_MEDIUM: [320, 240, 320, 240],
  VIDEO_QUALITY_HIGH: [480, 360, 480, 360],
  VIDEO_QUALITY_360P: [640, 360, 640, 360],
  VIDEO_QUALITY_480P: [640, 480, 640, 480],
  VIDEO_QUALITY_540P: [960, 540, 960, 540],
  VIDEO_QUALITY_720P: [960, 720, 960, 720],
  VIDEO_QUALITY_720P_0: [960, 720, 960, 720],
  VIDEO_QUALITY_720P_1: [1280, 720, 1280, 720],
  VIDEO_QUALITY_1080P: [960, 540, 1920, 1080],
  VIDEO_QUALITY_SCREEN: [960, 540, 1920, 1080],
  // v1，不推荐使用，互动视频帧率
  VIDEO_FRAME_RATE_NORMAL: [10, 20],
  VIDEO_FRAME_RATE_5: [5, 5],
  VIDEO_FRAME_RATE_10: [10, 10],
  VIDEO_FRAME_RATE_15: [10, 15],
  VIDEO_FRAME_RATE_20: [10, 20],
  VIDEO_FRAME_RATE_25: [10, 25],
  VIDEO_FRAME_RATE_SCREEN: [5, 5],
  // v1，不推荐使用，互动视频码率
  VIDEO_BANDWIDTH_NORMAL: 900,
  VIDEO_BANDWIDTH_LOW: 500,
  VIDEO_BANDWIDTH_MEDIUM: 900,
  VIDEO_BANDWIDTH_HIGH: 1600,
  VIDEO_BANDWIDTH_SCREEN: 1800,
  /**
   * v1 Video Profile
   * 问题：
   * 添加ratio参数，解决部分分辨率（480P_1）不是标准16/9或4/3时，部分老旧摄像头等比调整失败的问题。
   * safari 13 问题：
   * VIDEO_PROFILE_240P_1 的最低分辨率调整至160x90，部分摄像头无法发起424x240
   */
  VIDEO_PROFILE_120P_0: { videoSize: [160, 120, 160, 120], videoFrameRate: [10, 25], bitRate: [150, 280], ratio: 4 / 3 },
  VIDEO_PROFILE_120P_1: { videoSize: [160, 90, 160, 90], videoFrameRate: [10, 25], bitRate: [160, 320], ratio: 16 / 9 },
  VIDEO_PROFILE_180P_0: { videoSize: [160, 120, 240, 180], videoFrameRate: [10, 25], bitRate: [180, 340], ratio: 4 / 3 },
  VIDEO_PROFILE_180P_1: { videoSize: [160, 90, 320, 180], videoFrameRate: [10, 25], bitRate: [190, 350], ratio: 16 / 9 },
  VIDEO_PROFILE_240P_0: { videoSize: [160, 120, 320, 240], videoFrameRate: [10, 25], bitRate: [200, 380], ratio: 4 / 3 },
  VIDEO_PROFILE_240P_1: { videoSize: [160, 90, 424, 240], videoFrameRate: [10, 25], bitRate: [220, 450], ratio: 16 / 9 },
  VIDEO_PROFILE_360P_0: { videoSize: [320, 240, 480, 360], videoFrameRate: [10, 25], bitRate: [225, 550], ratio: 4 / 3 },
  VIDEO_PROFILE_360P_1: { videoSize: [424, 240, 640, 360], videoFrameRate: [10, 25], bitRate: [280, 650], ratio: 16 / 9 },
  VIDEO_PROFILE_480P_0: { videoSize: [480, 360, 640, 480], videoFrameRate: [10, 25], bitRate: [400, 950], ratio: 4 / 3 },
  VIDEO_PROFILE_480P_1: { videoSize: [640, 360, 848, 480], videoFrameRate: [10, 25], bitRate: [500, 1200], ratio: 16 / 9 },
  VIDEO_PROFILE_720P_0: { videoSize: [480, 360, 960, 720], videoFrameRate: [10, 25], bitRate: [550, 1900], ratio: 4 / 3 },
  VIDEO_PROFILE_720P_1: { videoSize: [640, 360, 1280, 720], videoFrameRate: [10, 25], bitRate: [600, 2150], ratio: 16 / 9 },
  VIDEO_PROFILE_1080P_0: { videoSize: [640, 480, 1440, 1080], videoFrameRate: [10, 25], bitRate: [750, 2700], ratio: 4 / 3 },
  VIDEO_PROFILE_1080P_1: { videoSize: [848, 480, 1920, 1080], videoFrameRate: [10, 25], bitRate: [950, 3200], ratio: 16 / 9 },
  VIDEO_PROFILE_720P_DESKTOP: { videoSize: [1280, 720, 1280, 720], videoFrameRate: [5, 5], bitRate: [800, 1250], ratio: 16 / 9 },
  VIDEO_PROFILE_1080P_DESKTOP: { videoSize: [1280, 720, 1920, 1080], videoFrameRate: [5, 5], bitRate: [1200, 1800], ratio: 16 / 9 },
  // 以上
};

const QUICKSCAN_V2 = [];
Object.keys(Definition).forEach((label, index) => {
  if (label.indexOf('RTC_VIDEO_PROFILE') >= 0) {
    const item = Definition[label];
    const scanItem = { label, width: item.videoSize[2], height: item.videoSize[3], ratio: item.ratio.toString() };
    QUICKSCAN_V2.push(scanItem);
  }
});

const QUICKSCAN = [
  {
    label: 'VIDEO_PROFILE_1080P_1',
    width: 1920,
    height: 1080,
    ratio: '16:9'
  },
  {
    label: 'VIDEO_PROFILE_1080P_0',
    width: 1440,
    height: 1080,
    ratio: '4:3'
  },
  {
    label: 'VIDEO_PROFILE_720P_1',
    width: 1280,
    height: 720,
    ratio: '16:9'
  },
  {
    label: 'VIDEO_PROFILE_720P_0',
    width: 960,
    height: 720,
    ratio: '4:3'
  },
  {
    label: 'VIDEO_PROFILE_480P_1',
    width: 848,
    height: 480,
    ratio: '16:9'
  },
  {
    label: 'VIDEO_PROFILE_480P_0',
    width: 640,
    height: 480,
    ratio: '4:3'
  },
  {
    label: 'VIDEO_PROFILE_360P_1',
    width: 640,
    height: 360,
    ratio: '16:9'
  },
  {
    label: 'VIDEO_PROFILE_360P_0',
    width: 480,
    height: 360,
    ratio: '4:3'
  },
  {
    label: 'VIDEO_PROFILE_240P_1',
    width: 424,
    height: 240,
    ratio: '16:9'
  },
  {
    label: 'VIDEO_PROFILE_240P_0',
    width: 320,
    height: 240,
    ratio: '4:3'
  },
  {
    label: 'VIDEO_PROFILE_180P_1',
    width: 320,
    height: 180,
    ratio: '16:9'
  },
  {
    label: 'VIDEO_PROFILE_180P_0',
    width: 240,
    height: 180,
    ratio: '4:3'
  },
  {
    label: 'VIDEO_PROFILE_120P_1',
    width: 160,
    height: 90,
    ratio: '16:9'
  },
  {
    label: 'VIDEO_PROFILE_120P_0',
    width: 160,
    height: 120,
    ratio: '4:3'
  }
];

/* K value is composed of three parts: module number + status number (normal is 2, error is 4) + serial number,
** For example：18 + 2 + 001 = 182001
** The following is the macro definition of the k-value serial number
 */
const K = {
  // about ROOM signalling
  CONNECT_SERVER: '001',
  DISCONNECT_SERVER: '002',
  PLAY_MESSAGE: '003',
  PUSH_MESSAGE: '004',
  CALL_PUBLISH_API: '005',
  SEND_PUBLISH: '006',
  PUBLISH_RESULT: '007',
  CREATE_LOCAL_PEER: '008',
  SEND_LOCAL_OFFER: '009',
  PROCESS_LOCAL_ANSWER: '010',
  SEND_LOCAL_CAND: '011',
  RECV_LOCAL_READY: '012',
  CALL_SUBSCRIBE_API: '013',
  SEND_SUBSCRIBE: '014',
  SUBSCRIBE_RESULT: '015',
  CREATE_REMOTE_PEER: '016',
  SEND_REMOTE_OFFER: '017',
  PROCESS_REMOTE_ANSWER: '018',
  SEND_REMOTE_CAND: '019',
  RECV_REMOTE_READY: '020',
  NEW_STREAM_ADD: '021',
  CALL_UNPUBLISH_API: '022',
  SEND_UNPUBLISH: '023',
  UNPUBLISH_RESULT: '024',
  CALL_UNSUBSCRIBE_API: '025',
  SEND_UNSUBSCRIBE: '026',
  CALL_DISCONNECT_API: '027',
  REMOVE_REMOTE_STREAM: '028',
  UNSUBSCRIBE_RESULT: '029',
  CALL_CONNECT_API: '030',
  DEVICE_CHANGE_EVENT: '031',
  SET_MAX_USERCOUNT: '032',

  // about statistical INFO
  STAT_INFO: '100',
  // about MIX action
  SEND_CONFIGROOMBROADCAST: '201',
  CONFIGROOMBROADCAST_RESULT: '202',
  SEND_SETMIXLAYOUTMODE: '203',
  SETMIXLAYOUTMODE_RESULT: '204',
  SEND_SETMIXLAYOUTMAINSCREEN: '205',
  SETMIXLAYOUTMAINSCREEN_RESULT: '206',
  SEND_STARTROOMBROADCAST: '207',
  STARTROOMBROADCAST_RESULT: '208',
  SEND_STOPROOMBROADCAST: '209',
  STOPROOMBROADCAST_RESULT: '210',
  SEND_SETSTREAMMIXOPTION: '211',
  SETSTREAMMIXOPTION_RESULT: '212',
  SEND_SETMIXADAPTIVELAYOUTMODE: '213',
  SETMIXADAPTIVELAYOUTMODE_RESULT: '214',

  // about STREAM action
  CONSTRUCT_LOCAL_STREAM: '500',
  INIT_LOCAL_STREAM: '501',
  PLAY_STREAM: '502',
  STOP_STREAM: '503',
  CALL_MUTE_AUDIO: '504',
  CALL_MUTE_VIDEO: '505',
  REPORT_SCREEN: '506',
  REPORT_VOLUME: '507',
  SET_AUDIO_OUTPUT: '509',
  CLOSE_LOCAL_STREAM: '513',
  PUBLISH_ICE_STATUS: '514',
  SUBSCRIBE_ICE_STATUS: '515',
  SWITCH_VIDEO_PROFILE: '516',
  // about version
  REPORT_SDK_VERSION: '601',
  REPORT_PLUGIN_VERSION: '602',
  // about TOOLS
  REPORT_DEVICES: '701',
  REPORT_RESOLUTION_LIST: '702',

  // ERROR EVENT
  // about ROOM signalling
  ER_CONNECT_SERVER: '001',
  ER_CALL_PUBLISH_API: '002',
  ER_PUBLISH_RESULT: '003',
  ER_CONNECT_LOCAL_PEER: '004',
  ER_REMOTE_LOCAL_STREAM: '005',
  ER_CALL_SUBSCRIBE_API: '006',
  ER_SUBSCRIBE_RESULT: '007',
  ER_REMOTE_PEER: '008',
  ER_CALL_UNPUBLISH_API: '009',
  ER_UNPUBLISH_RESULT: '010',
  ER_CALL_UNSUBSCRIBE_API: '011',
  ER_UNSUBSCRIBE_RESULT: '012',
  ER_DISCONNECT: '013',
  ER_STREAM_NOT_FOUND: '014',
  // about MIX action
  ER_CONFIGROOMBROADCAST_RESULT: '201',
  ER_SETMIXLAYOUTMODE_RESULT: '202',
  ER_SETMIXLAYOUTMAINSCREEN_RESULT: '203',
  ER_STARTROOMBROADCAST_RESULT: '204',
  ER_STOPROOMBROADCAST_RESULT: '205',
  ER_SETSTREAMMIXOPTION_RESULT: '206',
  ER_SETMIXADAPTIVELAYOUTMODE_RESULT: '207',
  // about STREAM action
  ER_INIT_STREAM: '501',
  ER_MONITOR_VOLUME: '502',
  ER_STREAM_ENDED: '503',
  ER_STREAM_STUNK: '504',
  ER_STREAM_FAILED: '505',
  ER_SWITCH_VIDEO_PROFILE: '506',
  // about TOOLS
  ER_GET_DEVICES: '701',
  ER_GET_RESOLUTION_LIST: '702',
  // about websocket
  WEBSOCKET_MSG: '801',
  // about user behavior
  EVENT_BEFOREUNLOAD_WHEN_CONNECTED: '901',
  EVENT_BEFOREUNLOAD_WHEN_UNCONNECTED: '902'
};




/***/ }),

/***/ "./rtcbase/src/common/Socket.js":
/*!**************************************!*\
  !*** ./rtcbase/src/common/Socket.js ***!
  \**************************************/
/*! exports provided: SocketEvent, Socket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SocketEvent", function() { return SocketEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return Socket; });
/* harmony import */ var _lib_socket_io__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/socket.io */ "./rtcbase/src/lib/socket.io.js");
/* harmony import */ var _lib_socket_io__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_socket_io__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _uplog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uplog */ "./rtcbase/src/common/uplog.js");
/* harmony import */ var _Definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Definition */ "./rtcbase/src/common/Definition.js");
/* harmony import */ var _utils_Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Events */ "./rtcbase/src/utils/Events.js");
/* global */







class SocketEvent extends _utils_Events__WEBPACK_IMPORTED_MODULE_3__["LicodeEvent"] {
  constructor(type, specInput) {
    super({ type });
    this.args = specInput.args;
  }
}

/*
 * Class Stream represents a local or a remote Stream in the Room. It will handle the WebRTC
 * stream and identify the stream and where it should be drawn.
 */
class Socket extends _utils_Events__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"] {
  constructor() {
    super();
    this.defaultCallback = () => {};
    this.messageBuffer = [];

    this.CONNECTED = Symbol('connected');
    this.RECONNECTING = Symbol('reconnecting');
    this.DISCONNECTED = Symbol('disconnected');

    this.WEBSOCKET_NORMAL_CLOSURE = 1000;
    this.state = this.DISCONNECTED;
    this.IO = _lib_socket_io__WEBPACK_IMPORTED_MODULE_0___default.a;

    this.roomId = '';
    this.userId = '';
    this.host = '';

    this.socket = null;
  }

  emit(type, ...args) {
    this.dispatchEvent(new SocketEvent(type, { args }));
  }

  addToBuffer(type, message, callback, error) {
    this.messageBuffer.push([type, message, callback, error]);
  }

  flushBuffer() {
    if (this.state !== this.CONNECTED) {
      return;
    }
    this.messageBuffer.forEach((message) => {
      this.sendMessage(...message);
    });
  }

  connect(token, options, callback = this.defaultCallback, error = this.defaultCallback) {
    this.roomId = token.token.roomId;
    this.userId = token.token.userId;
    this.host = token.token.host;
    const upLogOptions = {
      uid: this.userId,
      aid: this.roomId
    };
    _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].init(upLogOptions);

    let successful = false;
    const socketOptions = {
      reconnection: true,
      reconnectionAttempts: 3,
      // timeout: 20000,
      secure: token.token.secure,
      forceNew: true,
      transports: ['websocket'],
      rejectUnauthorized: false
    };
    const transport = token.token.secure ? 'wss://' : 'ws://';
    const host = token.token.host;
    let socket = this.IO.connect(transport + host, socketOptions);

    // Hack to know the exact reason of the WS closure (socket.io does not publish it)
    let closeCode = this.WEBSOCKET_NORMAL_CLOSURE;
    const socketOnCloseFunction = socket.io.engine.transport.ws.onclose;
    socket.io.engine.transport.ws.onclose = (closeEvent) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].info(`WebSocket internalOnClose, code: ${closeEvent.code}, reason: ${closeEvent.reason}, wasClean: ${closeEvent.wasClean}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
      closeCode = closeEvent.code;
      socketOnCloseFunction(closeEvent);
    };
    this.socket = socket;

    socket.on('onAddStream', this.emit.bind(this, 'onAddStream'));
    socket.on('onPublished', this.emit.bind(this, 'onPublished'));
    socket.on('onPublishInit', this.emit.bind(this, 'onPublishInit'));
    socket.on('signaling_message_vhall', this.emit.bind(this, 'signaling_message_vhall'));
    // We receive an event of new data in one of the streams
    socket.on('onUpdateAttributeStream', this.emit.bind(this, 'onUpdateAttributeStream'));
    // We receive an event of a stream removed from the room
    socket.on('onRemoveStream', this.emit.bind(this, 'onRemoveStream'));
    socket.on('broadcastMuteStream', this.emit.bind(this, 'broadcastMuteStream'));
    socket.on('userDeleted', this.emit.bind(this, 'userDeleted'));
    socket.on('customSignalling', this.emit.bind(this, 'customSignalling'));
    socket.on('remoteUserEnterRoom', this.emit.bind(this, 'remoteUserEnterRoom'));
    socket.on('remoteUserQuitRoom', this.emit.bind(this, 'remoteUserQuitRoom'));

    // The socket has disconnected
    socket.on('disconnect', (reason) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].info(`socket disconnect, id: ${this.id}, code: ${closeCode}, reason: ${reason}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
      if (reason === 'transport error' ||
        reason === 'ping timeout') {
        this.state = this.RECONNECTING;
        return;
      }
      this.emit('disconnect', reason, closeCode);
      socket.close();
    });

    socket.on('connection_failed', (evt) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`socket connection_failed, id: ${this.id}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
      if (!successful) {
        error({ result: 'failed', code: 400, msg: 'connection failed' });
      }
      this.emit('connection_failed', evt);
    });

    socket.on('error', (err) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`socket error, id: ${this.id}, error: ${err.message}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
      if (successful) {
        this.emit('error');
      } else {
        error({ result: 'failed', code: 400, msg: 'socket error' });
      }
    });
    
    socket.on('connect_error', (err) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`socket connect_error, id: ${this.id}, error: ${err.message}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
    });

    socket.on('connect_timeout', (err) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`socket connect_timeout, id: ${this.id}, error: ${err.message}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
    });

    socket.on('reconnecting', (attemptNumber) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].info(`socket reconnecting, id: ${this.id}, attempet: ${attemptNumber}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
    });

    socket.on('reconnect', (attemptNumber) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].info(`socket reconnect, id: ${this.id}, attempet: ${attemptNumber}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
      this.state = this.CONNECTED;
      socket.emit('reconnected', this.id);
      this.flushBuffer();
    });

    socket.on('reconnect_attempt', (attemptNumber) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].info(`socket reconnect_attempt, id: ${this.id}, attempet: ${attemptNumber}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
    });

    socket.on('reconnect_error', (err) => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].info(`socket reconnect_error, id: ${this.id}, error: ${err.message}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
    });

    socket.on('reconnect_failed', () => {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`socket reconnect_failed, id: ${this.id}`, { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
      this.state = this.DISCONNECTED;
      if (!successful) {
        error({ result: 'failed', code: 400, msg: 'reconnect failed' });
      }
      this.emit('disconnect', 'reconnect failed', closeCode);
    });

    /*
    socket.on('ping', () => {
      log.info('socket ping', { k: K.WEBSOCKET_MSG });
    });

    socket.on('pong', (ms) => {
      log.info(`socket pong, in ${ms} ms`, { k: K.WEBSOCKET_MSG });
    });
    */

    // First message with the token
    const args = options;
    args.token = token;
    this.sendMessage('token', args, (response) => {
      this.state = this.CONNECTED;
      this.id = response.msg.clientId;
      successful = true;
      callback(response.msg);
    }, error);
  }

  disconnect() {
    this.state = this.DISCONNECTED;
    this.socket.disconnect();
  };

  // Function to send a message to the server using socket.io
  sendMessage(type, msg, callback = this.defaultCallback, error = this.defaultCallback) {
    if (this.state === this.DISCONNECTED && type !== 'token') {
      _uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error('Trying to send a message over a disconnected Socket', { k: _Definition__WEBPACK_IMPORTED_MODULE_2__["K"].WEBSOCKET_MSG });
      return;
    }
    if (this.state === this.RECONNECTING) {
      this.addToBuffer(type, msg, callback, error);
      return;
    }
    this.socket.emit(type, msg, (resp) => {
      if (resp === 'error') {  // when controller's onToken return 'error'
        error('error');
      } else if (resp.result === 'success') {
        callback(resp);
      } else if (resp.result === 'failed') {
        error(resp);
      } else {
        callback(resp);
      }
    });
  }
}




/***/ }),

/***/ "./rtcbase/src/common/uplog.js":
/*!*************************************!*\
  !*** ./rtcbase/src/common/uplog.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _utils_Base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Base64 */ "./rtcbase/src/utils/Base64.js");
/* harmony import */ var _utils_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Logger */ "./rtcbase/src/utils/Logger.js");
/* harmony import */ var _utils_ErizoMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ErizoMap */ "./rtcbase/src/utils/ErizoMap.js");
/* harmony import */ var _Definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Definition */ "./rtcbase/src/common/Definition.js");
/* global XMLHttpRequest, document, window, navigator, fetch */





const UplogInterval = 30;

class UpLog {
  constructor() {
    this.sessionId = UpLog.random();
    this.prefixK = '18';
    this.message = '';
    this.monitor_api = '/monitor';
    this.allowHeartLog = true;
    this.playHeart = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_2__["default"])();
    this.publishHeart = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_2__["default"])();
    this.publishStatsHeart = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_2__["default"])();
    this.FrameHeart = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_2__["default"])();
    this.biz_des02 = 2;
    this.pf = '7';
    this.ver = _Definition__WEBPACK_IMPORTED_MODULE_3__["Version"].version;
    this.date = _Definition__WEBPACK_IMPORTED_MODULE_3__["Version"].date;
    this.inited = false;
    this.backlog = [];
    this.browerUA = window.navigator.userAgent;
    this.streamDetail = {
      bitRate: 0,
      videoWidth: 0,
      videoHeight: 0,
      totalBytesReceived: 0,
      totalBytesSent: 0,
      bytesReceived: 0, // 30s
      bytesSent: 0, // 30s
      frameRate: 0 // 1s
    };
    this.isPreventReport = 1
  }

  init(specInput, otherOption) {
    this.sessionId = UpLog.random();
    this.url = specInput.url ? specInput.url : 'https://t-dc.e.vhall.com/login';
    this.biz_role = specInput.biz_role ? specInput.biz_role : '';
    this.biz_id = specInput.biz_id ? specInput.biz_id : '';
    this.biz_des01 = specInput.biz_des01 ? specInput.biz_des01 : '';
    this.bu = specInput.bu ? specInput.bu : 0;
    this.cid = specInput.cid;
    this.uid = specInput.uid;
    this.aid = specInput.aid;
    this.vid = specInput.vid;
    this.app_id = specInput.app_id;
    this.sd = specInput.sd;
    this.otherOption = otherOption;
    this.inited = true;
    const parser = document.createElement('a');
    parser.href = this.url;
    this.monitor_url = `${parser.protocol}//${parser.host}${this.monitor_api}`;
    this.cleanBacklog();
  }

  static random() {
    const array = [1, 2, 3, 4, 5, 6, 7, 8, 9];

    return (new Date()).valueOf() +
      String(array[Math.floor(Math.random() * array.length)]) +
      String(array[Math.floor(Math.random() * array.length)]) +
      String(array[Math.floor(Math.random() * array.length)]);
  }

  static createXMLHttp() {
    let XmlHttp;
    if (global.ActiveXObject) {
      const arr = [
        'MSXML2.XMLHttp.6.0',
        'MSXML2.XMLHttp.5.0',
        'MSXML2.XMLHttp.4.0',
        'MSXML2.XMLHttp.3.0',
        'MSXML2.XMLHttp',
        'Microsoft.XMLHttp'
      ];
      for (let i = 0; i < arr.length; i += 1) {
        try {
          XmlHttp = new global.ActiveXObject(arr[i]);
          break;
        } catch (error) {
          // empty
        }
      }
    } else {
      try {
        XmlHttp = new XMLHttpRequest();
      } catch (otherError) {
        // empty
      }
    }
    return XmlHttp;
  } // function createXMLHTTP finish;

  static push(url) {
    const xhr = UpLog.createXMLHttp();
    xhr.open('get', url, true);
    xhr.onload = () => {
      // empty
    };
    xhr.send();
  } // push function finish;

  cleanBacklog() {
    this.backlog.forEach((cell) => {
      this.report(cell.msg, { k: cell.k, level: cell.level, streamId: cell.streamId, Collapsed: cell.Collapsed });
    });
    this.backlog = [];
  }

  info(msg = '', { k = '000', streamId = '', Collapsed = '' } = {}) {
    this.report(msg, { k, streamId, Collapsed });
  }

  error(msg = '', { k = '000', streamId = '', Collapsed = '' } = {}) {
    this.report(msg, { k, level: 'error', streamId, Collapsed });
  }

  debug(msg = '', { k = '000', streamId = '', Collapsed = '' } = {}) {
    this.report(msg, { k, level: 'debug', streamId, Collapsed } );
  }

  warn(msg = '', { k = '000', streamId = '', Collapsed = '' } = {}) {
    this.report(msg, { k, level: 'warning', streamId, Collapsed } );
  }

  report(msg = '', { k = '000', level = 'info', streamId = '', Collapsed = '' } = {}) {
    // Uninitialized, queued
    if (!this.inited) {
      this.backlog.push({ msg, k, level, streamId, Collapsed });
      return;
    }
    // console
    let m = '2';
    if (msg && level === 'error') {
      _utils_Logger__WEBPACK_IMPORTED_MODULE_1__["default"].error(`${streamId} | ${msg}`, Collapsed);
      m = '4';
    } else if(msg && level === 'debug'){
      _utils_Logger__WEBPACK_IMPORTED_MODULE_1__["default"].debug(`${streamId} | ${msg}`, Collapsed);
    } else if(msg && level === 'warning'){
      _utils_Logger__WEBPACK_IMPORTED_MODULE_1__["default"].warning(`${streamId} | ${msg}`, Collapsed);
    } else {
      _utils_Logger__WEBPACK_IMPORTED_MODULE_1__["default"].info(`${streamId}  | ${msg}`, Collapsed);
    }
    // Not uploading log
    if (k === '000' || this.isPreventReport == 2 || this.isPreventReport == 3) {
      return;
    }
    // upload log
    let message = msg;
    if (Collapsed) {
      message = `${msg} ${JSON.stringify(Collapsed)}`;
    }

    let dictdata = {
      s: this.sessionId,
      ld: Date.now(),
      cid: this.cid,
      uid: this.uid,
      aid: this.aid,
      pf: this.pf,
      ver: this.ver,
      bu: this.bu,
      _m: message,
      p: streamId
    };

    if (k === '001') {
      dictdata = Object.assign({
        s: this.sessionId,
        ld: Date.now(),
        cid: this.cid,
        uid: this.uid,
        aid: this.aid,
        pf: this.pf,
        ver: this.ver,
        bu: this.bu,
        _m: message,
        p: streamId
      }, this.otherOption)
    }

    const id = UpLog.random();
    const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_0__["default"].encodeBase64(JSON.stringify(dictdata));
    const url = `${this.monitor_url}?k=${this.prefixK}${m}${k}&id=${id}&s=${this.sessionId}&bu=${this.bu}&token=${token}`;
    UpLog.push(url);
  }

  // 浏览器刷新或关闭上报  901/902
  fetch(msg = '', { k = '000', streamId = '' } = {}) {
    // Uninitialized, queued
    if (!this.inited || this.isPreventReport == 2 || this.isPreventReport == 3) {
      return;
    }
    let m = '4';
    const dictdata = {
      s: this.sessionId,
      ld: Date.now(),
      cid: this.cid,
      uid: this.uid,
      aid: this.aid,
      pf: this.pf,
      ver: this.ver,
      bu: this.bu,
      _m: msg,
      p: streamId
    };
    const id = UpLog.random();
    const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_0__["default"].encodeBase64(JSON.stringify(dictdata));
    const url = `${this.monitor_url}?k=${this.prefixK}${m}${k}&id=${id}&s=${this.sessionId}&bu=${this.bu}&token=${token}`;
    if (navigator.sendBeacon) {
      const data = new FormData();
      navigator.sendBeacon(url, data);
    } else {
      fetch(url);
    }
  }

  // 订阅计费上报 003
  playMessageLog(stream) {
    if (!this.inited || this.isPreventReport == 3) {
      return;
    }
    const stats = stream.getStats();
    stats.transport.forEach((stat) => {
      if (stat.bytesReceived) {
        const bytesReceived = stat.bytesReceived - this.streamDetail.totalBytesReceived;
        this.streamDetail.bytesReceived = bytesReceived > 0 ? bytesReceived : 0;
        this.streamDetail.totalBytesReceived = stat.bytesReceived;
      }
      if (stat.bytesSent) {
        const bytesSent = stat.bytesSent - this.streamDetail.totalBytesSent;
        this.streamDetail.bytesSent = bytesSent > 0 ? bytesSent : 0;
        this.streamDetail.totalBytesSent = stat.bytesSent;
      }

      this.streamDetail.bitRate = (8 * (this.streamDetail.bytesReceived + this.streamDetail.bytesSent)) / UplogInterval;
    });

    stats.track.forEach((stat) => {
      if (stat.frameHeight && stat.frameWidth) {
        this.streamDetail.videoWidth = stat.frameWidth;
        this.streamDetail.videoHeight = stat.frameHeight;
      }
    });
    const k = _Definition__WEBPACK_IMPORTED_MODULE_3__["K"].PLAY_MESSAGE;
    const id = UpLog.random();
    const dictdata = Object.assign({
      s: this.sessionId,
      tt: Date.now() - stream.upLogTime,
      uid: this.uid,
      aid: this.aid,
      _m: this.message,
      p: stream.getID(),
      pf: this.pf,
      ver: this.ver,
      errorcode: 2002,
      vtype: stream.streamType,
      videoWidth: this.streamDetail.videoWidth,
      videoHeight: this.streamDetail.videoHeight,
      bitrate: parseInt(this.streamDetail.bitRate / 1000, 10),
      tf: this.streamDetail.bytesReceived,
      uf: this.streamDetail.bytesSent,
      biz_role: this.biz_role,
      biz_id: this.biz_id,
      biz_des01: this.biz_des01,
      biz_des02: this.biz_des02,
      bu: this.bu,
      vid: this.vid,
      vfid: this.vid,
      app_id: this.app_id,
      sd: this.sd,
      os: stream.overseas
    }, this.otherOption);
    stream.refreshUpLogTime();
    const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_0__["default"].encodeBase64(JSON.stringify(dictdata));
    const url = `${this.url}?k=${this.prefixK}2${k}&id=${id}&s=${this.sessionId}&bu=${this.bu}&token=${token}`;
    UpLog.push(url);
  }

  startPlayMessageLog(stream) {
    if (this.playHeart.has(stream.getID()) || this.allowHeartLog === false) {
      return;
    }
    this.playHeart.add(stream.getID(),
      global.setInterval(this.playMessageLog.bind(this), UplogInterval * 1000, stream));
  }

  stopPlayMessageLog(stream) {
    if (this.playHeart.has(stream.getID())) {
      global.clearInterval(this.playHeart.get(stream.getID()));
      this.playHeart.remove(stream.getID());
      this.playMessageLog(stream);
    }
  }

  // 推流计费上报 004
  publishMessageLog(stream) {
    if (!this.inited || this.isPreventReport == 3) {
      return;
    }
    const stats = stream.getStats();
    stats.transport.forEach((stat) => {
      if (stat.bytesReceived) {
        const bytesReceived = stat.bytesReceived - this.streamDetail.totalBytesReceived;
        this.streamDetail.bytesReceived = bytesReceived > 0 ? bytesReceived : 0;
        this.streamDetail.totalBytesReceived = stat.bytesReceived;
      }
      if (stat.bytesSent) {
        const bytesSent = stat.bytesSent - this.streamDetail.totalBytesSent;
        this.streamDetail.bytesSent = bytesSent > 0 ? bytesSent : 0;
        this.streamDetail.totalBytesSent = stat.bytesSent;
      }
      this.streamDetail.bitRate = (8 * (this.streamDetail.bytesReceived + this.streamDetail.bytesSent)) / UplogInterval;
    });

    stats.track.forEach((stat) => {
      if (stat.frameHeight && stat.frameWidth) {
        this.streamDetail.videoWidth = stat.frameWidth;
        this.streamDetail.videoHeight = stat.frameHeight;
      }
    });

    const k = _Definition__WEBPACK_IMPORTED_MODULE_3__["K"].PUSH_MESSAGE;
    const id = UpLog.random();
    const dictdata = Object.assign({
      s: this.sessionId,
      tt: Date.now() - stream.upLogTime,
      uid: this.uid,
      aid: this.aid,
      _m: this.message,
      p: stream.getID(),
      pf: this.pf,
      ver: this.ver,
      errorcode: 2003,
      vtype: stream.streamType,
      videoWidth: this.streamDetail.videoWidth,
      videoHeight: this.streamDetail.videoHeight,
      bitrate: parseInt(this.streamDetail.bitRate / 1000, 10),
      tf: this.streamDetail.bytesReceived,
      uf: this.streamDetail.bytesSent,
      biz_role: this.biz_role,
      biz_id: this.biz_id,
      biz_des01: this.biz_des01,
      biz_des02: this.biz_des02,
      bu: this.bu,
      vid: this.vid,
      vfid: this.vid,
      app_id: this.app_id,
      sd: this.sd,
      os: stream.overseas
    }, this.otherOption);
    stream.refreshUpLogTime();
    const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_0__["default"].encodeBase64(JSON.stringify(dictdata));
    const url = `${this.url}?k=${this.prefixK}2${k}&id=${id}&s=${this.sessionId}&bu=${this.bu}&token=${token}`;
    UpLog.push(url);
  }

  startPublishMessageLog(stream) {
    this.biz_des02 = 1;
    if (this.publishHeart.has(stream.getID()) || this.allowHeartLog === false) {
      return;
    }
    this.publishHeart.add(stream.getID(),
      global.setInterval(this.publishMessageLog.bind(this), UplogInterval * 1000, stream));
  }

  stopPublishMessageLog(stream) {
    this.biz_des02 = 2;
    if (this.publishHeart.has(stream.getID())) {
      global.clearInterval(this.publishHeart.get(stream.getID()));
      this.publishHeart.remove(stream.getID());
      this.publishMessageLog(stream);
    }
  }

  // 上报视频截图 506
  reportFrame(stream) {
    if (!this.inited || this.isPreventReport == 2 || this.isPreventReport == 3) {
      return;
    }

    if (stream.hasVideo() || stream.hasScreen()) {
      const frameB64 = stream.getVideoFrameURL('image/jpeg', 0.1, 160, 120);
      const k = _Definition__WEBPACK_IMPORTED_MODULE_3__["K"].REPORT_SCREEN;
      const dictdata = {
        s: this.sessionId,
        ld: Date.now(),
        uid: this.uid,
        aid: this.aid,
        pf: this.pf,
        ver: this.ver,
        bu: this.bu,
        _m: frameB64,
        p: stream.getID()
      };
      const id = UpLog.random();
      const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_0__["default"].encodeBase64(JSON.stringify(dictdata));
      const url = `${this.monitor_url}?k=${this.prefixK}2${k}&id=${id}&s=${this.sessionId}&bu=${this.bu}&token=${token}`;
      UpLog.push(url);
    }
  }

  startReportFrame(stream) {
    if (this.FrameHeart.has(stream.getID())) {
      return;
    }
    this.FrameHeart.add(stream.getID(),
      global.setInterval(this.reportFrame.bind(this), 15000, stream));
  }

  stopReportFrame(stream) {
    if (this.FrameHeart.has(stream.getID())) {
      global.clearInterval(this.FrameHeart.get(stream.getID()));
      this.FrameHeart.remove(stream.getID());
    }
  }

  // 上报版本 601
  reportVersion() {
    if (!this.inited || this.isPreventReport == 2 || this.isPreventReport == 3) {
      return;
    }
    const k = _Definition__WEBPACK_IMPORTED_MODULE_3__["K"].REPORT_SDK_VERSION;
    const id = UpLog.random();
    const dictdata = {
      s: this.sessionId,
      cid: this.cid,
      uid: this.uid,
      aid: this.aid,
      pf: this.pf,
      ver: this.ver,
      release_date: this.date,
      bu: this.bu,
      app_id: this.app_id,
      dt: '',
      os: '',
      ua: this.browerUA,
      cpu: '',
      memory: '',
      _m: ''
    };
    const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_0__["default"].encodeBase64(JSON.stringify(dictdata));
    const url = `${this.monitor_url}?k=${this.prefixK}2${k}&id=${id}&s=${this.sessionId}&bu=${this.bu}&token=${token}`;
    UpLog.push(url);
  }

  // 上报质量信息 100
  pubSubStatsLog(localStreams, remoteStreams) {
    if (!this.inited || this.isPreventReport == 2 || this.isPreventReport == 3) {
      return;
    }
    if (localStreams.keys().length + remoteStreams.keys().length < 1) {
      return;
    }

    const streamDataModel = {
      s: this.sessionId,
      ld: Date.now(),
      uid: this.uid,
      aid: this.aid,
      p: '',
      vtype: '',
      type: '',
      avbw: 0,
      rtt: 0,
      t_kbytes: 0,
      t_kbitrate: 0,
      t_dura: 0,
      v_exist: 0,
      v_ssrc: 0,
      v_kbytes: 0,
      v_kbitrate: 0,
      v_width: 0,
      v_height: 0,
      v_fmrate: 0,
      v_fmcount: 0,
      v_fmenc: 0,
      v_tet: 0,
      v_qpsum: 0,
      v_pkt: 0,
      v_tpsd: 0,
      v_pkt_lost: 0,
      v_pkt_retran: 0,
      v_nack: 0,
      v_pli: 0,
      v_fir: 0,
      v_srcw: 0,
      v_srch: 0,
      v_srcfmt: 0,
      v_jit: 0,
      v_rtt: 0,
      v_drop: 0,
      v_decd: 0,
      a_exist: 0,
      a_ssrc: 0,
      a_level: 0,
      a_kbytes: 0,
      a_kbitrate: 0,
      a_pkt: 0,
      a_pkt_lost: 0,
      a_pkt_retran: 0,
      a_jit: 0,
      a_rtt: 0
    };
    const dictData = [];
    localStreams.forEach((stream, id) => {
      // deep copy
      const streamData = JSON.parse(JSON.stringify(streamDataModel));
      streamData.p = id;
      streamData.vtype = stream.streamType;
      streamData.type = 'sent';
      streamData.t_dura = Math.max(0, Date.now() - stream.startMonitorTime);
      const stats = stream.getStats();
      streamData.t_kbitrate = stats.calculated.t_kbitrateSent;
      streamData.v_kbitrate = stats.calculated.v_kbitrateSent;
      streamData.a_kbitrate = stats.calculated.a_kbitrateSent;
      streamData.v_fmrate = stats.calculated.v_frameRate;
      stats.transport.forEach((stat) => {
        streamData.ld = stat.timestamp;
        if (stat.bytesSent !== undefined && stat.bytesReceived !== undefined) {
          streamData.t_kbytes = parseInt((stat.bytesSent + stat.bytesReceived) / 1000, 10);
        }
      });
      stats.candidatePair.forEach((stat) => {
        if (stat.availableOutgoingBitrate !== undefined) {
          streamData.avbw = parseInt(stat.availableOutgoingBitrate / 1000, 10);
        }
        if (stat.currentRoundTripTime !== undefined) {
          streamData.rtt = parseInt((stat.currentRoundTripTime) * 1000, 10);
        }
      });
      stats.track.forEach((stat) => {
        if (stat.kind === 'video') {
          streamData.v_exist = 1;
          if (stat.frameHeight && stat.frameWidth) {
            streamData.v_width = stat.frameWidth;
            streamData.v_height = stat.frameHeight;
          }
          streamData.v_fmcount = stat.framesSent;
        }
        if (stat.kind === 'audio') {
          streamData.a_exist = 1;
        }
      });
      stats.mediaSource.forEach((stat) => {
        if (stat.kind === 'video') {
          streamData.v_srcw = stat.width;
          streamData.v_srch = stat.height;
          streamData.v_srcfmt = stat.framesPerSecond;
        }
        if (stat.kind === 'audio') {
          streamData.a_level = parseInt(stat.audioLevel * 100000, 10);
        }
      });
      stats.outboundRtp.forEach((stat) => {
        if (stat.kind === 'video') {
          streamData.v_ssrc = stat.ssrc;
          streamData.v_kbytes += parseInt(stat.bytesSent / 1000, 10);
          streamData.v_pkt += stat.packetsSent;
          streamData.v_nack += stat.nackCount;
          streamData.v_pli += stat.pliCount;
          streamData.v_fir += stat.firCount;
          streamData.v_fmenc += stat.framesEncoded;
          streamData.v_tet += stat.totalEncodeTime;
          streamData.v_qpsum += stat.qpSum;
          streamData.v_tpsd += stat.totalPacketSendDelay;
          streamData.v_pkt_retran += stat.retransmittedPacketsSent;
        }
        if (stat.kind === 'audio') {
          streamData.a_ssrc = stat.ssrc;
          streamData.a_kbytes = parseInt(stat.bytesSent / 1000, 10);
          streamData.a_pkt = stat.packetsSent;
          streamData.a_pkt_retran = stat.retransmittedPacketsSent;
        }
      });
      stats.remoteInboundRtp.forEach((stat) => {
        if (stat.kind === 'video') {
          streamData.v_pkt_lost += stat.packetsLost;
          streamData.v_jit = parseInt(stat.jitter * 1000, 10);
          streamData.v_rtt = parseInt(stat.roundTripTime * 1000, 10);
        }
        if (stat.kind === 'audio') {
          streamData.a_pkt_lost = stat.packetsLost;
          streamData.a_jit = parseInt(stat.jitter * 1000, 10);
          streamData.a_rtt = parseInt(stat.roundTripTime * 1000, 10);
        }
      });
      // console.log('publish:', JSON.stringify(streamData));
      dictData.push(streamData);
    });

    remoteStreams.forEach((stream, id) => {
      if (!localStreams.has(id)) {
        // deep copy
        const streamData = JSON.parse(JSON.stringify(streamDataModel));
        streamData.p = id;
        streamData.vtype = stream.streamType;
        streamData.type = 'recv';
        streamData.t_dura = Math.max(0, Date.now() - stream.startMonitorTime);
        const stats = stream.getStats();
        streamData.t_kbitrate = stats.calculated.t_kbitrateReceived;
        streamData.v_kbitrate = stats.calculated.v_kbitrateReceived;
        streamData.a_kbitrate = stats.calculated.a_kbitrateReceived;
        streamData.v_fmrate = stats.calculated.v_frameRate;
        stats.transport.forEach((stat) => {
          streamData.ld = stat.timestamp;
          if (stat.bytesSent !== undefined && stat.bytesReceived !== undefined) {
            streamData.t_kbytes = parseInt((stat.bytesSent + stat.bytesReceived) / 1000, 10);
          }
        });
        stats.candidatePair.forEach((stat) => {
          if (stat.currentRoundTripTime !== undefined) {
            streamData.rtt = parseInt((stat.currentRoundTripTime) * 1000, 10);
          }
        });
        stats.track.forEach((stat) => {
          if (stat.kind === 'video') {
            streamData.v_exist = 1;
            if (stat.frameHeight && stat.frameWidth) {
              streamData.v_width = stat.frameWidth;
              streamData.v_height = stat.frameHeight;
            }
            streamData.v_fmcount = stat.framesReceived;
            streamData.v_drop = stat.framesDropped;
            streamData.v_decd = stat.framesDecoded;
          }
          if (stat.kind === 'audio') {
            streamData.a_exist = 1;
            if (stat.audioLevel !== undefined) {
              streamData.a_level = parseInt(stat.audioLevel * 100000, 10);
            }
          }
        });
        stats.inboundRtp.forEach((stat) => {
          if (stat.kind === 'video') {
            streamData.v_ssrc = stat.ssrc;
            streamData.v_kbytes = parseInt(stat.bytesReceived / 1000, 10);
            streamData.v_pkt = stat.packetsReceived;
            streamData.v_nack = stat.nackCount;
            streamData.v_pkt_lost = stat.packetsLost;
            streamData.v_pli = stat.pliCount;
          }
          if (stat.kind === 'audio') {
            streamData.a_ssrc = stat.ssrc;
            streamData.a_kbytes = parseInt(stat.bytesReceived / 1000, 10);
            streamData.a_pkt = stat.packetsReceived;
            streamData.a_pkt_lost = stat.packetsLost;
            streamData.a_jit = parseInt(stat.jitter * 1000, 10);
          }
        });
        // console.log('subscribe:', JSON.stringify(streamData));
        dictData.push(streamData);
      }
    });

    const k = _Definition__WEBPACK_IMPORTED_MODULE_3__["K"].STAT_INFO;
    const logID = UpLog.random();
    const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_0__["default"].encodeBase64(JSON.stringify(dictData));
    const url = `${this.monitor_url}?k=${this.prefixK}2${k}&id=${logID}&s=${this.sessionId}&bu=${this.bu}&token=${token}`;
    UpLog.push(url);
  }
  
  setReportFlag(level){
    this.isPreventReport = level
  }
}

const log = new UpLog();

/* harmony default export */ __webpack_exports__["default"] = (log);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./rtcbase/src/lib/adapter-7.3.0.js":
/*!******************************************!*\
  !*** ./rtcbase/src/lib/adapter-7.3.0.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */

'use strict';

var _adapter_factory = require('./adapter_factory.js');

var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
module.exports = adapter; // this is the difference from adapter_core.

},{"./adapter_factory.js":2}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = adapterFactory;

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _chrome_shim = require('./chrome/chrome_shim');

var chromeShim = _interopRequireWildcard(_chrome_shim);

var _edge_shim = require('./edge/edge_shim');

var edgeShim = _interopRequireWildcard(_edge_shim);

var _firefox_shim = require('./firefox/firefox_shim');

var firefoxShim = _interopRequireWildcard(_firefox_shim);

var _safari_shim = require('./safari/safari_shim');

var safariShim = _interopRequireWildcard(_safari_shim);

var _common_shim = require('./common_shim');

var commonShim = _interopRequireWildcard(_common_shim);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Shimming starts here.
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
function adapterFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      window = _ref.window;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true
  };

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimGetStats(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);
      firefoxShim.shimAddTransceiver(window);
      firefoxShim.shimCreateOffer(window);
      firefoxShim.shimCreateAnswer(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimGetDisplayMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCreateOfferLegacy(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
}

// Browser shims.

},{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimMediaStream = shimMediaStream;
exports.shimOnTrack = shimOnTrack;
exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
exports.shimGetStats = shimGetStats;
exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.fixNegotiationNeeded = fixNegotiationNeeded;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimMediaStream(window) {
  window.MediaStream = window.MediaStream || window.webkitMediaStream;
}

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
      get: function get() {
        return this._ontrack;
      },
      set: function set(f) {
        if (this._ontrack) {
          this.removeEventListener('track', this._ontrack);
        }
        this.addEventListener('track', this._ontrack = f);
      },

      enumerable: true,
      configurable: true
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var _this = this;

      if (!this._ontrackpoly) {
        this._ontrackpoly = function (e) {
          // onaddstream does not fire when a track is added to an existing
          // stream. But stream.onaddtrack is implemented so we use that.
          e.stream.addEventListener('addtrack', function (te) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === te.track.id;
              });
            } else {
              receiver = { track: te.track };
            }

            var event = new Event('track');
            event.track = te.track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
          e.stream.getTracks().forEach(function (track) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === track.id;
              });
            } else {
              receiver = { track: track };
            }
            var event = new Event('track');
            event.track = track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
        };
        this.addEventListener('addstream', this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    // even if RTCRtpTransceiver is in window, it is only used and
    // emitted in unified-plan. Unfortunately this means we need
    // to unconditionally wrap the event.
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      if (!e.transceiver) {
        Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
      }
      return e;
    });
  }
}

function shimGetSendersWithDtmf(window) {
  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
    var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
      return {
        track: track,
        get dtmf() {
          if (this._dtmf === undefined) {
            if (track.kind === 'audio') {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };

    // augment addTrack when getSenders is not available.
    if (!window.RTCPeerConnection.prototype.getSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice(); // return a copy of the internal state.
      };
      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        var sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };

      var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        var idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this2 = this;

      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach(function (track) {
        _this2._senders.push(shimSenderWithDtmf(_this2, track));
      });
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;

      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);

      stream.getTracks().forEach(function (track) {
        var sender = _this3._senders.find(function (s) {
          return s.track === track;
        });
        if (sender) {
          // remove sender
          _this3._senders.splice(_this3._senders.indexOf(sender), 1);
        }
      });
    };
  } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this4 = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this4;
      });
      return senders;
    };

    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}

function shimGetStats(window) {
  if (!window.RTCPeerConnection) {
    return;
  }

  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _this5 = this;

    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    // If selector is a function then we are in the old style stats so just
    // pass back the original getStats format to avoid breaking old users.


    if (arguments.length > 0 && typeof selector === 'function') {
      return origGetStats.apply(this, arguments);
    }

    // When spec-style getStats is supported, return those when called with
    // either no arguments or the selector argument is null.
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
      return origGetStats.apply(this, []);
    }

    var fixChromeStats_ = function fixChromeStats_(response) {
      var standardReport = {};
      var reports = response.result();
      reports.forEach(function (report) {
        var standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          }[report.type] || report.type
        };
        report.names().forEach(function (name) {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });

      return standardReport;
    };

    // shim getStats with maplike support
    var makeMapStats = function makeMapStats(stats) {
      return new Map(Object.keys(stats).map(function (key) {
        return [key, stats[key]];
      }));
    };

    if (arguments.length >= 2) {
      var successCallbackWrapper_ = function successCallbackWrapper_(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };

      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
    }

    // promise-support
    return new Promise(function (resolve, reject) {
      origGetStats.apply(_this5, [function (response) {
        resolve(makeMapStats(fixChromeStats_(response)));
      }, reject]);
    }).then(onSucc, onErr);
  };
}

function shimSenderReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
    return;
  }

  // shim sender stats.
  if (!('getStats' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        var _this6 = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this6;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      var sender = this;
      return this._pc.getStats().then(function (result) {
        return (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          utils.filterStats(result, sender.track, true)
        );
      });
    };
  }

  // shim receiver stats.
  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        var _this7 = this;

        var receivers = origGetReceivers.apply(this, []);
        receivers.forEach(function (receiver) {
          return receiver._pc = _this7;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      var receiver = this;
      return this._pc.getStats().then(function (result) {
        return utils.filterStats(result, receiver.track, false);
      });
    };
  }

  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
    return;
  }

  // shim RTCPeerConnection.getStats(track).
  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
      var track = arguments[0];
      var sender = void 0;
      var receiver = void 0;
      var err = void 0;
      this.getSenders().forEach(function (s) {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach(function (r) {
        if (r.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
    }
    return origGetStats.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrackWithNative(window) {
  // shim addTrack/removeTrack with native variants in order to make
  // the interactions with legacy getLocalStreams behave as in other browsers.
  // Keeps a mapping stream.id => [stream, rtpsenders...]
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this8 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
      return _this8._shimmedLocalStreams[streamId][0];
    });
  };

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    var sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this9 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this9.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    var existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    var newSenders = this.getSenders().filter(function (newSender) {
      return existingSenders.indexOf(newSender) === -1;
    });
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };

  var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this10 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
        var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          _this10._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (_this10._shimmedLocalStreams[streamId].length === 1) {
          delete _this10._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrack(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  // shim addTrack and removeTrack.
  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window);
  }

  // also shim pc.getLocalStreams when addTrack is shimmed
  // to return the original streams.
  var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this11 = this;

    var nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map(function (stream) {
      return _this11._reverseStreams[stream.id];
    });
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this12 = this;

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this12.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    // Add identity mapping for consistency with addTrack.
    // Unless this is being used with a stream from addTrack.
    if (!this._reverseStreams[stream.id]) {
      var newStream = new window.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };

  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    var _this13 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    var streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
      return t === track;
    })) {
      // this is not fully correct but all we can manage without
      // [[associated MediaStreams]] internal slot.
      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
    }

    var alreadyExists = this.getSenders().find(function (s) {
      return s.track === track;
    });
    if (alreadyExists) {
      throw new DOMException('Track already exists.', 'InvalidAccessError');
    }

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    var oldStream = this._streams[stream.id];
    if (oldStream) {
      // this is using odd Chrome behaviour, use with caution:
      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
      // Note: we rely on the high-level addTrack/dtmf shim to
      // create the sender with a dtmf sender.
      oldStream.addTrack(track);

      // Trigger ONN async.
      Promise.resolve().then(function () {
        _this13.dispatchEvent(new Event('negotiationneeded'));
      });
    } else {
      var newStream = new window.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find(function (s) {
      return s.track === track;
    });
  };

  // replace the internal stream id with the external one and
  // vice versa.
  function replaceInternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  function replaceExternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  ['createOffer', 'createAnswer'].forEach(function (method) {
    var nativeMethod = window.RTCPeerConnection.prototype[method];
    var methodObj = _defineProperty({}, method, function () {
      var _this14 = this;

      var args = arguments;
      var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
      if (isLegacyCall) {
        return nativeMethod.apply(this, [function (description) {
          var desc = replaceInternalStreamId(_this14, description);
          args[0].apply(null, [desc]);
        }, function (err) {
          if (args[1]) {
            args[1].apply(null, err);
          }
        }, arguments[2]]);
      }
      return nativeMethod.apply(this, arguments).then(function (description) {
        return replaceInternalStreamId(_this14, description);
      });
    });
    window.RTCPeerConnection.prototype[method] = methodObj[method];
  });

  var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };

  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

  var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
    get: function get() {
      var description = origLocalDescription.get.apply(this);
      if (description.type === '') {
        return description;
      }
      return replaceInternalStreamId(this, description);
    }
  });

  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this15 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    // We can not yet check for sender instanceof RTCRtpSender
    // since we shim RTPSender. So we check if sender._pc is set.
    if (!sender._pc) {
      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
    }
    var isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
    }

    // Search for the native stream the senders track belongs to.
    this._streams = this._streams || {};
    var stream = void 0;
    Object.keys(this._streams).forEach(function (streamid) {
      var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
        return sender.track === track;
      });
      if (hasTrack) {
        stream = _this15._streams[streamid];
      }
    });

    if (stream) {
      if (stream.getTracks().length === 1) {
        // if this is the last track of the stream, remove the stream. This
        // takes care of any shimmed _senders.
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        // relying on the same odd chrome behaviour as above.
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event('negotiationneeded'));
    }
  };
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.webkitRTCPeerConnection;
  }
  if (!window.RTCPeerConnection) {
    return;
  }

  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
  if (browserDetails.version < 53) {
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    // Firefox 68+ emits and processes {candidate: "", ...}, ignore
    // in older versions. Native support planned for Chrome M77.
    if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}

function fixNegotiationNeeded(window) {
  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
    var pc = e.target;
    if (pc.signalingState !== 'stable') {
      return;
    }
    return e;
  });
}

},{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, getSourceId) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  // getSourceId is a function that returns a promise resolving with
  // the sourceId of the screen/window/tab to be shared.
  if (typeof getSourceId !== 'function') {
    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then(function (sourceId) {
      var widthSpecified = constraints.video && constraints.video.width;
      var heightSpecified = constraints.video && constraints.video.height;
      var frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}

},{}],5:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var logging = utils.log;

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (!navigator.mediaDevices) {
    return;
  }

  var browserDetails = utils.detectBrowser(window);

  var constraintsToChrome_ = function constraintsToChrome_(c) {
    if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function (key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function oldname_(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === 'deviceId' ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function (mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function shimConstraints_(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && _typeof(constraints.audio) === 'object') {
      var remap = function remap(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && _typeof(constraints.video) === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches = void 0;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices().then(function (devices) {
            devices = devices.filter(function (d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function (d) {
              return matches.some(function (match) {
                return d.label.toLowerCase().includes(match);
              });
            });
            if (!dev && devices.length && matches.includes('back')) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function shimError_(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function toString() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function (c) {
      navigator.webkitGetUserMedia(c, onSuccess, function (e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator.getUserMedia = getUserMedia_.bind(navigator);

  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
  // function which returns a Promise, it does not accept spec-style
  // constraints.
  if (navigator.mediaDevices.getUserMedia) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (cs) {
      return shimConstraints_(cs, function (c) {
        return origGetUserMedia(c).then(function (stream) {
          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function (track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function (e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }
}

},{"../utils.js":15}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimRTCIceCandidate = shimRTCIceCandidate;
exports.shimMaxMessageSize = shimMaxMessageSize;
exports.shimSendThrowTypeError = shimSendThrowTypeError;
exports.shimConnectionState = shimConnectionState;
exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

var _sdp = require('sdp');

var _sdp2 = _interopRequireDefault(_sdp);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shimRTCIceCandidate(window) {
  // foundation is arbitrarily chosen as an indicator for full support for
  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
    return;
  }

  var NativeRTCIceCandidate = window.RTCIceCandidate;
  window.RTCIceCandidate = function RTCIceCandidate(args) {
    // Remove the a= which shouldn't be part of the candidate string.
    if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }

    if (args.candidate && args.candidate.length) {
      // Augment the native candidate with the parsed fields.
      var nativeCandidate = new NativeRTCIceCandidate(args);
      var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
      var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

      // Add a serializer that does not serialize the extra attributes.
      augmentedCandidate.toJSON = function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment
        };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

  // Hook up the augmented candidate in onicecandidate and
  // addEventListener('icecandidate', ...)
  utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
    if (e.candidate) {
      Object.defineProperty(e, 'candidate', {
        value: new window.RTCIceCandidate(e.candidate),
        writable: 'false'
      });
    }
    return e;
  });
}

function shimMaxMessageSize(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);

  if (!('sctp' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
      get: function get() {
        return typeof this._sctp === 'undefined' ? null : this._sctp;
      }
    });
  }

  var sctpInDescription = function sctpInDescription(description) {
    if (!description || !description.sdp) {
      return false;
    }
    var sections = _sdp2.default.splitSections(description.sdp);
    sections.shift();
    return sections.some(function (mediaSection) {
      var mLine = _sdp2.default.parseMLine(mediaSection);
      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
    });
  };

  var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
    // TODO: Is there a better solution for detecting Firefox?
    var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    var version = parseInt(match[1], 10);
    // Test for NaN (yes, this is ugly)
    return version !== version ? -1 : version;
  };

  var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
    // Every implementation we know can send at least 64 KiB.
    // Note: Although Chrome is technically able to send up to 256 KiB, the
    //       data does not reach the other peer reliably.
    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
    var canSendMaxMessageSize = 65536;
    if (browserDetails.browser === 'firefox') {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
          // fragmentation.
          canSendMaxMessageSize = 16384;
        } else {
          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
          // messages. Thus, supporting ~2 GiB when sending.
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        // Currently, all FF >= 57 will reset the remote maximum message size
        // to the default value when a data channel is created at a later
        // stage. :(
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        // FF >= 60 supports sending ~2 GiB
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };

  var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
    // Note: 65536 bytes is the default value from the SDP spec. Also,
    //       every implementation we know supports receiving 65536 bytes.
    var maxMessageSize = 65536;

    // FF 57 has a slightly incorrect default remote max message size, so
    // we need to adjust it here to avoid a failure when sending.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }

    var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
      // If the maximum message size is not present in the remote SDP and
      // both local and remote are Firefox, the remote peer can receive
      // ~2 GiB.
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };

  var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    // Chrome decided to not expose .sctp in plan-b mode.
    // As usual, adapter.js has to do an 'ugly worakaround'
    // to cover up the mess.
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
      var _getConfiguration = this.getConfiguration(),
          sdpSemantics = _getConfiguration.sdpSemantics;

      if (sdpSemantics === 'plan-b') {
        Object.defineProperty(this, 'sctp', {
          get: function get() {
            return typeof this._sctp === 'undefined' ? null : this._sctp;
          },

          enumerable: true,
          configurable: true
        });
      }
    }

    if (sctpInDescription(arguments[0])) {
      // Check if the remote is FF.
      var isFirefox = getRemoteFirefoxVersion(arguments[0]);

      // Get the maximum message size the local peer is capable of sending
      var canSendMMS = getCanSendMaxMessageSize(isFirefox);

      // Get the maximum message size of the remote peer.
      var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

      // Determine final maximum message size
      var maxMessageSize = void 0;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }

      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
      // attribute.
      var sctp = {};
      Object.defineProperty(sctp, 'maxMessageSize', {
        get: function get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }

    return origSetRemoteDescription.apply(this, arguments);
  };
}

function shimSendThrowTypeError(window) {
  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
    return;
  }

  // Note: Although Firefox >= 57 has a native implementation, the maximum
  //       message size can be reset for all data channels at a later stage.
  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

  function wrapDcSend(dc, pc) {
    var origDataChannelSend = dc.send;
    dc.send = function send() {
      var data = arguments[0];
      var length = data.length || data.size || data.byteLength;
      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    var dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}

/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
 * since DTLS failures would be hidden. See
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
 * for the Firefox tracking bug.
 */
function shimConnectionState(window) {
  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  Object.defineProperty(proto, 'connectionState', {
    get: function get() {
      return {
        completed: 'connected',
        checking: 'connecting'
      }[this.iceConnectionState] || this.iceConnectionState;
    },

    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, 'onconnectionstatechange', {
    get: function get() {
      return this._onconnectionstatechange || null;
    },
    set: function set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
      }
    },

    enumerable: true,
    configurable: true
  });

  ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
    var origMethod = proto[method];
    proto[method] = function () {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = function (e) {
          var pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            var newEvent = new Event('connectionstatechange', e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}

function removeAllowExtmapMixed(window) {
  /* remove a=extmap-allow-mixed for Chrome < M71 */
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
    return;
  }
  var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
      desc.sdp = desc.sdp.split('\n').filter(function (line) {
        return line.trim() !== 'a=extmap-allow-mixed';
      }).join('\n');
    }
    return nativeSRD.apply(this, arguments);
  };
}

},{"./utils":15,"sdp":17}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimPeerConnection = shimPeerConnection;
exports.shimReplaceTrack = shimReplaceTrack;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _filtericeservers = require('./filtericeservers');

var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (window.RTCIceGatherer) {
    if (!window.RTCIceCandidate) {
      window.RTCIceCandidate = function RTCIceCandidate(args) {
        return args;
      };
    }
    if (!window.RTCSessionDescription) {
      window.RTCSessionDescription = function RTCSessionDescription(args) {
        return args;
      };
    }
    // this adds an additional event listener to MediaStrackTrack that signals
    // when a tracks enabled property was changed. Workaround for a bug in
    // addStream, see below. No longer required in 15025+
    if (browserDetails.version < 15025) {
      var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
        set: function set(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }
  }

  // ORTC defines the DTMF sender a bit different.
  // https://github.com/w3c/ortc/issues/714
  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = new window.RTCDtmfSender(this);
          } else if (this.track.kind === 'video') {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
  // Edge currently only implements the RTCDtmfSender, not the
  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
  if (window.RTCDtmfSender && !window.RTCDTMFSender) {
    window.RTCDTMFSender = window.RTCDtmfSender;
  }

  var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
  window.RTCPeerConnection = function RTCPeerConnection(config) {
    if (config && config.iceServers) {
      config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
      utils.log('ICE servers after filtering:', config.iceServers);
    }
    return new RTCPeerConnectionShim(config);
  };
  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
}

function shimReplaceTrack(window) {
  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
  if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
    window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
  }
}

},{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterIceServers = filterIceServers;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function (server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function (url) {
        // filter STUN unconditionally.
        if (url.indexOf('stun:') === 0) {
          return false;
        }

        var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
        if (validTurn && !hasTurn) {
          hasTurn = true;
          return true;
        }
        return validTurn && !hasTurn;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

},{"../utils":15}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window) {
  if (!('getDisplayMedia' in window.navigator)) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
}

},{}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetUserMedia = shimGetUserMedia;
function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  var shimError_ = function shimError_(e) {
    return {
      name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function toString() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function (c) {
    return origGetUserMedia(c).catch(function (e) {
      return Promise.reject(shimError_(e));
    });
  };
}

},{}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimOnTrack = shimOnTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.shimSenderGetStats = shimSenderGetStats;
exports.shimReceiverGetStats = shimReceiverGetStats;
exports.shimRemoveStream = shimRemoveStream;
exports.shimRTCDataChannel = shimRTCDataChannel;
exports.shimAddTransceiver = shimAddTransceiver;
exports.shimCreateOffer = shimCreateOffer;
exports.shimCreateAnswer = shimCreateAnswer;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
    return; // probably media.peerconnection.enabled=false in about:config
  }
  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.mozRTCPeerConnection;
  }

  if (browserDetails.version < 53) {
    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  // as well as ignoring {sdpMid, candidate: ""}
  if (browserDetails.version < 68) {
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      // Firefox 68+ emits and processes {candidate: "", ...}, ignore
      // in older versions.
      if (arguments[0] && arguments[0].candidate === '') {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  var modernStatsTypes = {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  };

  var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
      if (browserDetails.version < 53 && !onSucc) {
        // Shim only promise getStats with spec-hyphens in type names
        // Leave callback version alone; misc old uses of forEach before Map
        try {
          stats.forEach(function (stat) {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e) {
          if (e.name !== 'TypeError') {
            throw e;
          }
          // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
          stats.forEach(function (stat, i) {
            stats.set(i, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}

function shimSenderGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
    return;
  }
  var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this;
      });
      return senders;
    };
  }

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
      var sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
  };
}

function shimReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
    return;
  }
  var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      var _this2 = this;

      var receivers = origGetReceivers.apply(this, []);
      receivers.forEach(function (receiver) {
        return receiver._pc = _this2;
      });
      return receivers;
    };
  }
  utils.wrapPeerConnectionEvent(window, 'track', function (e) {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}

function shimRemoveStream(window) {
  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
    return;
  }
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    var _this3 = this;

    utils.deprecated('removeStream', 'removeTrack');
    this.getSenders().forEach(function (sender) {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        _this3.removeTrack(sender);
      }
    });
  };
}

function shimRTCDataChannel(window) {
  // rename DataChannel to RTCDataChannel (native fix in FF60):
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
  if (window.DataChannel && !window.RTCDataChannel) {
    window.RTCDataChannel = window.DataChannel;
  }
}

function shimAddTransceiver(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      var initParameters = arguments[1];
      var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;
      if (shouldPerformCheck) {
        // If sendEncodings params are provided, validate grammar
        initParameters.sendEncodings.forEach(function (encodingParam) {
          if ('rid' in encodingParam) {
            var ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError('Invalid RID value provided.');
            }
          }
          if ('scaleResolutionDownBy' in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
              throw new RangeError('scale_resolution_down_by must be >= 1.0');
            }
          }
          if ('maxFramerate' in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError('max_framerate must be >= 0.0');
            }
          }
        });
      }
      var transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        // Check if the init options were applied. If not we do this in an
        // asynchronous way and save the promise reference in a global object.
        // This is an ugly hack, but at the same time is way more robust than
        // checking the sender parameters before and after the createOffer
        // Also note that after the createoffer we are not 100% sure that
        // the params were asynchronously applied so we might miss the
        // opportunity to recreate offer.
        var sender = transceiver.sender;

        var params = sender.getParameters();
        if (!('encodings' in params)) {
          params.encodings = initParameters.sendEncodings;
          this.setParametersPromises.push(sender.setParameters(params).catch(function () {}));
        }
      }
      return transceiver;
    };
  }
}

function shimCreateOffer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer() {
    var _this4 = this,
        _arguments2 = arguments;

    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function () {
        return origCreateOffer.apply(_this4, _arguments2);
      }).finally(function () {
        _this4.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}

function shimCreateAnswer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    var _this5 = this,
        _arguments3 = arguments;

    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function () {
        return origCreateAnswer.apply(_this5, _arguments3);
      }).finally(function () {
        _this5.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}

},{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, preferredMediaSource) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
      err.name = 'NotFoundError';
      // from https://heycam.github.io/webidl/#idl-DOMException-error-names
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window.navigator.mediaDevices.getUserMedia(constraints);
  };
}

},{}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimGetUserMedia(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  navigator.getUserMedia = function (constraints, onSuccess, onError) {
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };

  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function remap(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (c) {
      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function () {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function (c) {
        if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}

},{"../utils":15}],14:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
exports.shimCallbacksAPI = shimCallbacksAPI;
exports.shimGetUserMedia = shimGetUserMedia;
exports.shimConstraints = shimConstraints;
exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimLocalStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!('addStream' in window.RTCPeerConnection.prototype)) {
    var _addTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      // Try to emulate Chrome's behaviour of adding in audio-video order.
      // Safari orders by track id.
      stream.getAudioTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
      stream.getVideoTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
    };

    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
      var stream = arguments[1];
      if (stream) {
        if (!this._localStreams) {
          this._localStreams = [stream];
        } else if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this2 = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      var index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      var tracks = stream.getTracks();
      this.getSenders().forEach(function (sender) {
        if (tracks.includes(sender.track)) {
          _this2.removeTrack(sender);
        }
      });
    };
  }
}

function shimRemoteStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
      get: function get() {
        return this._onaddstream;
      },
      set: function set(f) {
        var _this3 = this;

        if (this._onaddstream) {
          this.removeEventListener('addstream', this._onaddstream);
          this.removeEventListener('track', this._onaddstreampoly);
        }
        this.addEventListener('addstream', this._onaddstream = f);
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!_this3._remoteStreams) {
              _this3._remoteStreams = [];
            }
            if (_this3._remoteStreams.includes(stream)) {
              return;
            }
            _this3._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            _this3.dispatchEvent(event);
          });
        });
      }
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}

function shimCallbacksAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  var prototype = window.RTCPeerConnection.prototype;
  var origCreateOffer = prototype.createOffer;
  var origCreateAnswer = prototype.createAnswer;
  var setLocalDescription = prototype.setLocalDescription;
  var setRemoteDescription = prototype.setRemoteDescription;
  var addIceCandidate = prototype.addIceCandidate;

  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  var withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;

  withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;

  withCallback = function withCallback(candidate, successCallback, failureCallback) {
    var promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // shim not needed in Safari 12.1
    var mediaDevices = navigator.mediaDevices;
    var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator.mediaDevices.getUserMedia = function (constraints) {
      return _getUserMedia(shimConstraints(constraints));
    };
  }

  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }.bind(navigator);
  }
}

function shimConstraints(constraints) {
  if (constraints && constraints.video !== undefined) {
    return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
  }

  return constraints;
}

function shimRTCIceServerUrls(window) {
  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
  var OrigPeerConnection = window.RTCPeerConnection;
  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      var newIceServers = [];
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        var server = pcConfig.iceServers[i];
        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
          utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  // wrap static methods. Currently just generateCertificate.
  if ('generateCertificate' in window.RTCPeerConnection) {
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get: function get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}

function shimTrackEventTransceiver(window) {
  // Add event.transceiver member over deprecated event.receiver
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimCreateOfferLegacy(window) {
  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      var audioTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'audio';
      });
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === 'sendrecv') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('sendonly');
          } else {
            audioTransceiver.direction = 'sendonly';
          }
        } else if (audioTransceiver.direction === 'recvonly') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('inactive');
          } else {
            audioTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver('audio');
      }

      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      var videoTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'video';
      });
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === 'sendrecv') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('sendonly');
          } else {
            videoTransceiver.direction = 'sendonly';
          }
        } else if (videoTransceiver.direction === 'recvonly') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('inactive');
          } else {
            videoTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver('video');
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}

},{"../utils":15}],15:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.extractVersion = extractVersion;
exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
exports.disableLog = disableLog;
exports.disableWarnings = disableWarnings;
exports.log = log;
exports.deprecated = deprecated;
exports.detectBrowser = detectBrowser;
exports.compactObject = compactObject;
exports.walkStats = walkStats;
exports.filterStats = filterStats;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function wrappedCallback(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        cb(modifiedEvent);
      }
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function get() {
      return this['_on' + eventNameToWrap];
    },
    set: function set(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
      }
    },

    enumerable: true,
    configurable: true
  });
}

function disableLog(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  logDisabled_ = bool;
  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
}

/**
 * Disable or enable deprecation warnings
 * @param {!boolean} bool set to true to disable warnings.
 */
function disableWarnings(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  deprecationWarnings_ = !bool;
  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
}

function log() {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== 'undefined' && typeof console.log === 'function') {
      console.log.apply(console, arguments);
    }
  }
}

/**
 * Shows a deprecation warning suggesting the modern and spec-compatible API.
 */
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
}

/**
 * Browser detector.
 *
 * @return {object} result containing browser and version
 *     properties.
 */
function detectBrowser(window) {
  var navigator = window.navigator;

  // Returned result object.

  var result = { browser: null, version: null };

  // Fail early if it's not a browser
  if (typeof window === 'undefined' || !window.navigator) {
    result.browser = 'Not a browser.';
    return result;
  }

  if (navigator.mozGetUserMedia) {
    // Firefox.
    result.browser = 'firefox';
    result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
    // Chrome, Chromium, Webview, Opera.
    // Version matches Chrome/WebRTC version.
    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
    // more complicated fallback to webkitRTCPeerConnection.
    result.browser = 'chrome';
    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
    // Edge.
    result.browser = 'edge';
    result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    // Safari.
    result.browser = 'safari';
    result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
  } else {
    // Default fallthrough: not supported.
    result.browser = 'Not a supported browser.';
    return result;
  }

  return result;
}

/**
 * Checks if something is an object.
 *
 * @param {*} val The something you want to check.
 * @return true if val is an object, false otherwise.
 */
function isObject(val) {
  return Object.prototype.toString.call(val) === '[object Object]';
}

/**
 * Remove all empty objects and undefined values
 * from a nested object -- an enhanced and vanilla version
 * of Lodash's `compact`.
 */
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }

  return Object.keys(data).reduce(function (accumulator, key) {
    var isObj = isObject(data[key]);
    var value = isObj ? compactObject(data[key]) : data[key];
    var isEmptyObject = isObj && !Object.keys(value).length;
    if (value === undefined || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, _defineProperty({}, key, value));
  }, {});
}

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function (name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function (id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function (value) {
    if (value.type === 'track' && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function (trackStat) {
    result.forEach(function (stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

},{}],16:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldѕ are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this._localDescription = null;
    this._remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
    configurable: true,
    get: function() {
      return this._localDescription;
    }
  });
  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
    configurable: true,
    get: function() {
      return this._remoteDescription;
    }
  });

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // ѕdpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete‥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc._localDescription.sdp =
          SDPUtils.getDescription(pc._localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc._localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
          protocol === 'UDP/DTLS/SCTP'))) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          protocol: protocol,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        // If the offer contained RTX but the answer did not,
        // remove RTX from sendEncodingParameters.
        var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

        var hasRtx = commonCapabilities.codecs.filter(function(c) {
          return c.name.toLowerCase() === 'rtx';
        }).length;
        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
          delete transceiver.sendEncodingParameters[0].rtx;
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc._remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
      }
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && transceiver.dtlsTransport &&
          !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      }
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc._remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
            sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
          } else {
            sdp += 'm=application 0 ' + transceiver.protocol +
                ' webrtc-datachannel\r\n';
          }
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc._remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":17}],17:[function(require,module,exports){
/* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(parts) {
      return parts.attribute === 'cname';
    });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(function(line) {
      var parts = line.substr(17).split(' ');
      return parts.map(function(part) {
        return parseInt(part, 10);
      });
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(obj) {
      return obj.attribute === 'cname';
    })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(msidParts) {
      return msidParts.attribute === 'msid';
    });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  var mline = SDPUtils.parseMLine(mediaSection);
  var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  var maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substr(12), 10),
      protocol: mline.fmt,
      maxMessageSize: maxMessageSize
    };
  }
  var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]
      .substr(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize: maxMessageSize
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  var output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n'
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  var user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
    transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
    transceiver.dtlsTransport.getLocalParameters(),
    type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}]},{},[1])(1)
});


/***/ }),

/***/ "./rtcbase/src/lib/beauty.js":
/*!***********************************!*\
  !*** ./rtcbase/src/lib/beauty.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader */ "./rtcbase/src/lib/shader.js");

class Beauty{
  constructor(){
    this.canvas = null
    this.gl = null
    this.glProgram = null
    this.texture = null

    this.vertex = [ -1.0, -1.0, 0.0, 1.0,  -1.0, 0.0, 1.0,  1.0,  0.0, -1.0, 1.0,  0.0]
    this.vertexIndice = [ 0, 1, 2, 0, 2, 3]
    this.triangleTexCoords = [ 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]

    this.videoSource = null
    this.samplerUniform = null

    this.beautyLevel = 0.0
    this.beautyId = null // 美颜ID requestAnimationFrame ID
    this.intervalId = null // 美颜ID setinterval ID
    this.hidden = document.hidden
    this.listener()
    this.isDestroy = false
    this.id = null
  }

  async init(opt){
    if(!opt.source){
      return Promise.reject({message: 'video source is null', code: ''})
    }
    this.isDestroy = false
    this.id = opt.id
    this.videoSource = opt.source
    await this.createCanvas(opt.canvasOpt)
    this.setupContext()
    await this.initShaders()
    this.createTexture()
    this.samplerUniform = this.gl.getUniformLocation(this.glProgram, 'uSampler')
    
  }

  createCanvas(opt){
    return new Promise((resolve, reject)=>{
      if(document.querySelector(`.beautyCanvas_${opt.id}`)){
        resolve()
      }
      this.canvas = document.createElement('canvas')
      this.canvas.setAttribute('class', `beautyCanvas_${opt.id}`)
      this.canvas.setAttribute('width', opt && opt.width || 1280)
      this.canvas.setAttribute('height', opt && opt.height || 720)
      resolve()
    })
  }

  createVideo(sourceId){
    let virtualVideo = document.createElement('video')
    virtualVideo.setAttribute('class', `virtul_${sourceId}`)
    return virtualVideo
  }

  createTexture () {
    this.texture = this.gl.createTexture()
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture)
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true)
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.videoSource)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)
    this.gl.bindTexture(this.gl.TEXTURE_2D, null)
  }

  // 设置美颜等级 0 - 1
  setLevel(level = 0){
    this.beautyLevel = level
  }

  // 设置canvas 分辨率
  setCanvasProfile(opt){
    return new Promise((resolve, reject)=>{
      if(!this.canvas){
        reject({code:'', message: 'canvas is null'})
      }
      this.canvas.width = opt.width
      this.canvas.height = opt.height
      resolve()
    })
  }

  setupContext() {
    try {
      this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl')
    }catch(e){
    }
    if (this.gl) {
      this.gl.clearColor(74 / 255, 115 / 255, 94 / 255, 1.0)
      this.gl.clear(this.gl.COLOR_BUFFER_BIT)
    }
  }

  getCanvasCap(frameRate = 25){
    window.canvas = this.canvas.captureStream(frameRate)
    return this.canvas.captureStream(frameRate)
  }

  startDraw(){
    console.log('startDraw',Boolean(!this.gl), this.videoSource, this.hidden, document.hidden, this.beautyId);
    if(!this.gl ) return;

    if(this.hidden){
      if(this.beautyId){
        cancelAnimationFrame(()=>{this.draw()})
      }
      
      if(this.intervalId) clearInterval(this.intervalId)
      // setInterval(()=>{console.log('???')},1000)
      this.intervalId = setInterval(() => { 
        this.draw()
      }, 40)
    }else{
      if(this.intervalId) {
        clearInterval(this.intervalId)
        this.intervalId = null
      }
      this.draw()
    }
  }

  draw () {
    if(!this.hidden){
      this.beautyId = requestAnimationFrame(()=>{this.draw()})
    }
    // console.warn(this.intervalId? '定时器' : 'Animation')
    var vertexBuffer = this.gl.createBuffer()
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer)
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertex), this.gl.STATIC_DRAW)
    
    // indice data
    var vertexIndiceBuffer = this.gl.createBuffer()
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vertexIndiceBuffer)
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.vertexIndice), this.gl.STATIC_DRAW)

    // set position attribute
    var aVertexPosition = this.gl.getAttribLocation(this.glProgram, 'aPos')
    this.gl.vertexAttribPointer(aVertexPosition, 3, this.gl.FLOAT, false, 0, 0)
    this.gl.enableVertexAttribArray(aVertexPosition)
    
    // texture coordinate data
    var trianglesTexCoordBuffer = this.gl.createBuffer()
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, trianglesTexCoordBuffer)
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.triangleTexCoords), this.gl.STATIC_DRAW)
    
    // set texture coordinate attribute
    var vertexTexCoordAttribute = this.gl.getAttribLocation(this.glProgram, 'aVertexTextureCoord')
    this.gl.enableVertexAttribArray(vertexTexCoordAttribute)
    this.gl.vertexAttribPointer(vertexTexCoordAttribute, 2, this.gl.FLOAT, false, 0, 0)

    var resolutionLocation = this.gl.getUniformLocation(this.glProgram, 'u_resolution')
    this.gl.uniform2f(resolutionLocation, this.gl.canvas.width, this.gl.canvas.height)
    
    var textureSizeLocation = this.gl.getUniformLocation(this.glProgram, 'u_textureSize')
    this.gl.uniform2f(textureSizeLocation, 1280, 720)
    
    var beautyLvLocation = this.gl.getUniformLocation(this.glProgram, 'u_params')
    this.gl.uniform1f(beautyLvLocation, this.beautyLevel)//0.5 is the slider input value(0.0 - 1.0)
    // 
    // bind texture and set the sampler
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture)
    // this.texture
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGB, this.gl.RGB, this.gl.UNSIGNED_BYTE, this.videoSource)
    this.gl.uniform1i(this.samplerUniform, 0)
    
    this.gl.clearColor(74 / 255, 115 / 255, 94 / 255, 1.0)
    this.gl.clear(this.gl.COLOR_BUFFER_BIT)
    
    this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)
  }

  /* init shader begain */
  async initShaders() {
    // compile shaders
    var vertexS = await this.makeShader(_shader__WEBPACK_IMPORTED_MODULE_0__["vertexShader"], this.gl.VERTEX_SHADER)
    var fragmentS = await this.makeShader(_shader__WEBPACK_IMPORTED_MODULE_0__["fragmentShader"], this.gl.FRAGMENT_SHADER)

    // create program
    this.glProgram = this.gl.createProgram()
    // attach and link shaders to the program
    this.gl.attachShader(this.glProgram, vertexS)
    this.gl.attachShader(this.glProgram, fragmentS)
    this.gl.linkProgram(this.glProgram)

    if (!this.gl.getProgramParameter(this.glProgram, this.gl.LINK_STATUS)) {
      console.error('Unable to initialize the shader program.')
    }
    // use program
    this.gl.useProgram(this.glProgram)
  }
  
  makeShader(src, type) {
    return new Promise((resolve, reject)=>{
      var shader = this.gl.createShader(type)
      this.gl.shaderSource(shader, src)
      this.gl.compileShader(shader)
  
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        reject({code: '', message: 'Error compiling shader: ' + this.gl.getShaderInfoLog(shader)})
      }
      resolve(shader)
    })
  }
  /* init shader end */

  listener(){
    document.addEventListener("visibilitychange", () => {
      this.hidden = document.hidden
      if(!this.isDestroy) {
        this.startDraw()
      }
    })

  }

 destory(){
   return new Promise((resolve, reject) => {
     this.isDestroy = true
     if(this.beautyId){
       cancelAnimationFrame(this.beautyId)
       this.beautyId = null
     }else if(this.intervalId){
       clearInterval(this.intervalId)
       this.intervalId = null
     }else{
       reject({code:'', message:'beauty is not turned on'})
     }
     resolve()
   })
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Beauty);


/***/ }),

/***/ "./rtcbase/src/lib/shader.js":
/*!***********************************!*\
  !*** ./rtcbase/src/lib/shader.js ***!
  \***********************************/
/*! exports provided: vertexShader, fragmentShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertexShader", function() { return vertexShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentShader", function() { return fragmentShader; });

let vertexShader = `precision highp float;
    attribute vec3 aPos;
    attribute vec2 aVertexTextureCoord;
    varying highp vec2 vTextureCoord;
    uniform vec2 u_resolution;
    void main(void){
        gl_Position = vec4(aPos, 1);
        vTextureCoord = aVertexTextureCoord;
    }`
    
let fragmentShader = `
    precision highp float;
    varying highp vec2 vTextureCoord;
    uniform sampler2D uSampler;
    uniform highp vec2 u_textureSize;
    uniform highp float u_params;

    const vec3 W = vec3(0.299,0.587,0.114);
    const mat3 saturateMatrix = mat3(
    1.1102,-0.0598,-0.061,
    -0.0774,1.0826,-0.1186,
    -0.0228,-0.0228,1.1772);

    float hardlight(float color)
    {
        if(color <= 0.5){
            color = color * color * 2.0;
        }else{
            color = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);
        }
    return color;
    }

    void main(void) {
        vec3 centralColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        if(u_params <= 0.0){
            gl_FragColor = vec4(centralColor, 1.0);
        }else{
            vec4 param = vec4(0.25, 0.5, 0.5, 0.4);
            param.x = 50.0 / (2.0 * u_params * 100.0);
            param.y = 100.0 / (2.0 * u_params * 100.0);
            param.z = u_params * 10.0 * 0.05;
            param.w = u_params * 10.0 * 0.04;
            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
            //vec3 pixels = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
            //gl_FragColor = vec4(pixels, 1.0);
            vec2 v_texCoord = vec2(vTextureCoord.s, vTextureCoord.t);
            float sampleColor = texture2D(uSampler, v_texCoord).g * 22.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(0,-10)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(0,10)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-10,0)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(10,0)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(5,-8)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(5,8)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-5,8)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-5,-8)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(8,-5)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(8,5)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-8,5)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-8,-5)).g * 1.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(0,-6)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(0,6)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(6,0)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-6,0)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-4,-4)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-4,4)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(4,-4)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(4,4)).g * 2.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-2,-2)).g * 3.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(-2,2)).g * 3.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(2,-2)).g * 3.0 +
                    texture2D(uSampler, v_texCoord + onePixel * vec2(2,2)).g * 3.0;
            sampleColor = sampleColor / 62.0;
            float highpass = centralColor.g - sampleColor + 0.5;
            for(int i = 0; i < 5 ; i++){
            highpass = hardlight(highpass);
            }
            float lumance = dot(centralColor, W);
            float alpha = pow(lumance, param.x);
            vec3 smoothColor = centralColor + (centralColor-vec3(highpass))*alpha*0.1;
            float tmp = 0.0;
            tmp = pow(smoothColor.r, param.y);
            if(tmp - smoothColor.r < 0.6){
                smoothColor.r = clamp(tmp,0.0,1.0); 
            }else{
                smoothColor.r = clamp(smoothColor.r,0.0,1.0); 
            }
            tmp = pow(smoothColor.g, param.y);
            if(tmp - smoothColor.g < 0.6){
                smoothColor.g = clamp(tmp,0.0,1.0);
            }else{
                smoothColor.g = clamp(smoothColor.g,0.0,1.0);
            }
            tmp = pow(smoothColor.b, param.y);
            if(tmp - smoothColor.b < 0.6){
                smoothColor.b = clamp(tmp,0.0,1.0);
            }else{
                smoothColor.b = clamp(smoothColor.b,0.0,1.0);
            }
            vec3 lvse = vec3(1.0)-(vec3(1.0)-smoothColor)*(vec3(1.0)-centralColor);
            vec3 bianliang = max(smoothColor, centralColor);
            vec3 rouguang = 2.0*centralColor*smoothColor + centralColor*centralColor - 2.0*centralColor*centralColor*smoothColor;
            vec4 tmpcolor = vec4(mix(centralColor, lvse, alpha), 1.0);
            tmpcolor.rgb = mix(tmpcolor.rgb, bianliang, alpha);
            tmpcolor.rgb = mix(tmpcolor.rgb, rouguang, param.z);
            vec3 satcolor = tmpcolor.rgb * saturateMatrix; 
            gl_FragColor = vec4(mix(tmpcolor.rgb, satcolor, param.w), 1.0);
        }
    }`


/***/ }),

/***/ "./rtcbase/src/lib/socket.io.js":
/*!**************************************!*\
  !*** ./rtcbase/src/lib/socket.io.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/*!
 * Socket.IO v2.4.0
 * (c) 2014-2021 Guillermo Rauch
 * Released under the MIT License.
 */
!function (t, e) {
   true ? module.exports = e() : undefined;
}(void 0, function () {
  return function (t) {
    function e(r) {
      if (n[r]) return n[r].exports;
      var o = n[r] = {
        exports: {},
        id: r,
        loaded: !1
      };
      return t[r].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports;
    }

    var n = {};
    return e.m = t, e.c = n, e.p = "", e(0);
  }([function (t, e, n) {
    function r(t, e) {
      "object" == typeof t && (e = t, t = void 0), e = e || {};
      var n,
          r = o(t),
          i = r.source,
          p = r.id,
          u = r.path,
          h = c[p] && u in c[p].nsps,
          f = e.forceNew || e["force new connection"] || !1 === e.multiplex || h;
      return f ? (a("ignoring socket cache for %s", i), n = s(i, e)) : (c[p] || (a("new io instance for %s", i), c[p] = s(i, e)), n = c[p]), r.query && !e.query && (e.query = r.query), n.socket(r.path, e);
    }

    var o = n(1),
        i = n(7),
        s = n(12),
        a = n(3)("socket.io-client");
    t.exports = e = r;
    var c = e.managers = {};
    e.protocol = i.protocol, e.connect = r, e.Manager = n(12), e.Socket = n(37);
  }, function (t, e, n) {
    function r(t, e) {
      var n = t;
      e = e || "undefined" != typeof location && location, null == t && (t = e.protocol + "//" + e.host), "string" == typeof t && ("/" === t.charAt(0) && (t = "/" === t.charAt(1) ? e.protocol + t : e.host + t), /^(https?|wss?):\/\//.test(t) || (i("protocol-less url %s", t), t = "undefined" != typeof e ? e.protocol + "//" + t : "https://" + t), i("parse %s", t), n = o(t)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/";
      var r = n.host.indexOf(":") !== -1,
          s = r ? "[" + n.host + "]" : n.host;
      return n.id = n.protocol + "://" + s + ":" + n.port, n.href = n.protocol + "://" + s + (e && e.port === n.port ? "" : ":" + n.port), n;
    }

    var o = n(2),
        i = n(3)("socket.io-client:url");
    t.exports = r;
  }, function (t, e) {
    function n(t, e) {
      var n = /\/{2,9}/g,
          r = e.replace(n, "/").split("/");
      return "/" != e.substr(0, 1) && 0 !== e.length || r.splice(0, 1), "/" == e.substr(e.length - 1, 1) && r.splice(r.length - 1, 1), r;
    }

    function r(t, e) {
      var n = {};
      return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (t, e, r) {
        e && (n[e] = r);
      }), n;
    }

    var o = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        i = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];

    t.exports = function (t) {
      var e = t,
          s = t.indexOf("["),
          a = t.indexOf("]");
      s != -1 && a != -1 && (t = t.substring(0, s) + t.substring(s, a).replace(/:/g, ";") + t.substring(a, t.length));

      for (var c = o.exec(t || ""), p = {}, u = 14; u--;) p[i[u]] = c[u] || "";

      return s != -1 && a != -1 && (p.source = e, p.host = p.host.substring(1, p.host.length - 1).replace(/;/g, ":"), p.authority = p.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), p.ipv6uri = !0), p.pathNames = n(p, p.path), p.queryKey = r(p, p.query), p;
    };
  }, function (t, e, n) {
    (function (r) {
      "use strict";

      function o() {
        return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
      }

      function i(t) {
        var n = this.useColors;

        if (t[0] = (n ? "%c" : "") + this.namespace + (n ? " %c" : " ") + t[0] + (n ? "%c " : " ") + "+" + e.humanize(this.diff), n) {
          var r = "color: " + this.color;
          t.splice(1, 0, r, "color: inherit");
          var o = 0,
              i = 0;
          t[0].replace(/%[a-zA-Z%]/g, function (t) {
            "%%" !== t && (o++, "%c" === t && (i = o));
          }), t.splice(i, 0, r);
        }
      }

      function s() {
        return "object" === ("undefined" == typeof console ? "undefined" : u(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }

      function a(t) {
        try {
          null == t ? e.storage.removeItem("debug") : e.storage.debug = t;
        } catch (n) {}
      }

      function c() {
        var t;

        try {
          t = e.storage.debug;
        } catch (n) {}

        return !t && "undefined" != typeof r && "env" in r && (t = r.env.DEBUG), t;
      }

      function p() {
        try {
          return window.localStorage;
        } catch (t) {}
      }

      var u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
        return typeof t;
      } : function (t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      };
      e = t.exports = n(5), e.log = s, e.formatArgs = i, e.save = a, e.load = c, e.useColors = o, e.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : p(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e.formatters.j = function (t) {
        try {
          return JSON.stringify(t);
        } catch (e) {
          return "[UnexpectedJSONParseError]: " + e.message;
        }
      }, e.enable(c());
    }).call(e, n(4));
  }, function (t, e) {
    function n() {
      throw new Error("setTimeout has not been defined");
    }

    function r() {
      throw new Error("clearTimeout has not been defined");
    }

    function o(t) {
      if (u === setTimeout) return setTimeout(t, 0);
      if ((u === n || !u) && setTimeout) return u = setTimeout, setTimeout(t, 0);

      try {
        return u(t, 0);
      } catch (e) {
        try {
          return u.call(null, t, 0);
        } catch (e) {
          return u.call(this, t, 0);
        }
      }
    }

    function i(t) {
      if (h === clearTimeout) return clearTimeout(t);
      if ((h === r || !h) && clearTimeout) return h = clearTimeout, clearTimeout(t);

      try {
        return h(t);
      } catch (e) {
        try {
          return h.call(null, t);
        } catch (e) {
          return h.call(this, t);
        }
      }
    }

    function s() {
      y && l && (y = !1, l.length ? d = l.concat(d) : g = -1, d.length && a());
    }

    function a() {
      if (!y) {
        var t = o(s);
        y = !0;

        for (var e = d.length; e;) {
          for (l = d, d = []; ++g < e;) l && l[g].run();

          g = -1, e = d.length;
        }

        l = null, y = !1, i(t);
      }
    }

    function c(t, e) {
      this.fun = t, this.array = e;
    }

    function p() {}

    var u,
        h,
        f = t.exports = {};
    !function () {
      try {
        u = "function" == typeof setTimeout ? setTimeout : n;
      } catch (t) {
        u = n;
      }

      try {
        h = "function" == typeof clearTimeout ? clearTimeout : r;
      } catch (t) {
        h = r;
      }
    }();
    var l,
        d = [],
        y = !1,
        g = -1;
    f.nextTick = function (t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
      d.push(new c(t, e)), 1 !== d.length || y || o(a);
    }, c.prototype.run = function () {
      this.fun.apply(null, this.array);
    }, f.title = "browser", f.browser = !0, f.env = {}, f.argv = [], f.version = "", f.versions = {}, f.on = p, f.addListener = p, f.once = p, f.off = p, f.removeListener = p, f.removeAllListeners = p, f.emit = p, f.prependListener = p, f.prependOnceListener = p, f.listeners = function (t) {
      return [];
    }, f.binding = function (t) {
      throw new Error("process.binding is not supported");
    }, f.cwd = function () {
      return "/";
    }, f.chdir = function (t) {
      throw new Error("process.chdir is not supported");
    }, f.umask = function () {
      return 0;
    };
  }, function (t, e, n) {
    "use strict";

    function r(t) {
      var n,
          r = 0;

      for (n in t) r = (r << 5) - r + t.charCodeAt(n), r |= 0;

      return e.colors[Math.abs(r) % e.colors.length];
    }

    function o(t) {
      function n() {
        if (n.enabled) {
          var t = n,
              r = +new Date(),
              i = r - (o || r);
          t.diff = i, t.prev = o, t.curr = r, o = r;

          for (var s = new Array(arguments.length), a = 0; a < s.length; a++) s[a] = arguments[a];

          s[0] = e.coerce(s[0]), "string" != typeof s[0] && s.unshift("%O");
          var c = 0;
          s[0] = s[0].replace(/%([a-zA-Z%])/g, function (n, r) {
            if ("%%" === n) return n;
            c++;
            var o = e.formatters[r];

            if ("function" == typeof o) {
              var i = s[c];
              n = o.call(t, i), s.splice(c, 1), c--;
            }

            return n;
          }), e.formatArgs.call(t, s);
          var p = n.log || e.log || console.log.bind(console);
          p.apply(t, s);
        }
      }

      var o;
      return n.namespace = t, n.enabled = e.enabled(t), n.useColors = e.useColors(), n.color = r(t), n.destroy = i, "function" == typeof e.init && e.init(n), e.instances.push(n), n;
    }

    function i() {
      var t = e.instances.indexOf(this);
      return t !== -1 && (e.instances.splice(t, 1), !0);
    }

    function s(t) {
      e.save(t), e.names = [], e.skips = [];
      var n,
          r = ("string" == typeof t ? t : "").split(/[\s,]+/),
          o = r.length;

      for (n = 0; n < o; n++) r[n] && (t = r[n].replace(/\*/g, ".*?"), "-" === t[0] ? e.skips.push(new RegExp("^" + t.substr(1) + "$")) : e.names.push(new RegExp("^" + t + "$")));

      for (n = 0; n < e.instances.length; n++) {
        var i = e.instances[n];
        i.enabled = e.enabled(i.namespace);
      }
    }

    function a() {
      e.enable("");
    }

    function c(t) {
      if ("*" === t[t.length - 1]) return !0;
      var n, r;

      for (n = 0, r = e.skips.length; n < r; n++) if (e.skips[n].test(t)) return !1;

      for (n = 0, r = e.names.length; n < r; n++) if (e.names[n].test(t)) return !0;

      return !1;
    }

    function p(t) {
      return t instanceof Error ? t.stack || t.message : t;
    }

    e = t.exports = o.debug = o["default"] = o, e.coerce = p, e.disable = a, e.enable = s, e.enabled = c, e.humanize = n(6), e.instances = [], e.names = [], e.skips = [], e.formatters = {};
  }, function (t, e) {
    function n(t) {
      if (t = String(t), !(t.length > 100)) {
        var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);

        if (e) {
          var n = parseFloat(e[1]),
              r = (e[2] || "ms").toLowerCase();

          switch (r) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * u;

            case "days":
            case "day":
            case "d":
              return n * p;

            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * c;

            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * a;

            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;

            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;

            default:
              return;
          }
        }
      }
    }

    function r(t) {
      return t >= p ? Math.round(t / p) + "d" : t >= c ? Math.round(t / c) + "h" : t >= a ? Math.round(t / a) + "m" : t >= s ? Math.round(t / s) + "s" : t + "ms";
    }

    function o(t) {
      return i(t, p, "day") || i(t, c, "hour") || i(t, a, "minute") || i(t, s, "second") || t + " ms";
    }

    function i(t, e, n) {
      if (!(t < e)) return t < 1.5 * e ? Math.floor(t / e) + " " + n : Math.ceil(t / e) + " " + n + "s";
    }

    var s = 1e3,
        a = 60 * s,
        c = 60 * a,
        p = 24 * c,
        u = 365.25 * p;

    t.exports = function (t, e) {
      e = e || {};
      var i = typeof t;
      if ("string" === i && t.length > 0) return n(t);
      if ("number" === i && isNaN(t) === !1) return e["long"] ? o(t) : r(t);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t));
    };
  }, function (t, e, n) {
    function r() {}

    function o(t) {
      var n = "" + t.type;

      if (e.BINARY_EVENT !== t.type && e.BINARY_ACK !== t.type || (n += t.attachments + "-"), t.nsp && "/" !== t.nsp && (n += t.nsp + ","), null != t.id && (n += t.id), null != t.data) {
        var r = i(t.data);
        if (r === !1) return m;
        n += r;
      }

      return f("encoded %j as %s", t, n), n;
    }

    function i(t) {
      try {
        return JSON.stringify(t);
      } catch (e) {
        return !1;
      }
    }

    function s(t, e) {
      function n(t) {
        var n = d.deconstructPacket(t),
            r = o(n.packet),
            i = n.buffers;
        i.unshift(r), e(i);
      }

      d.removeBlobs(t, n);
    }

    function a() {
      this.reconstructor = null;
    }

    function c(t) {
      var n = 0,
          r = {
        type: Number(t.charAt(0))
      };
      if (null == e.types[r.type]) return h("unknown packet type " + r.type);

      if (e.BINARY_EVENT === r.type || e.BINARY_ACK === r.type) {
        for (var o = ""; "-" !== t.charAt(++n) && (o += t.charAt(n), n != t.length););

        if (o != Number(o) || "-" !== t.charAt(n)) throw new Error("Illegal attachments");
        r.attachments = Number(o);
      }

      if ("/" === t.charAt(n + 1)) for (r.nsp = ""; ++n;) {
        var i = t.charAt(n);
        if ("," === i) break;
        if (r.nsp += i, n === t.length) break;
      } else r.nsp = "/";
      var s = t.charAt(n + 1);

      if ("" !== s && Number(s) == s) {
        for (r.id = ""; ++n;) {
          var i = t.charAt(n);

          if (null == i || Number(i) != i) {
            --n;
            break;
          }

          if (r.id += t.charAt(n), n === t.length) break;
        }

        r.id = Number(r.id);
      }

      if (t.charAt(++n)) {
        var a = p(t.substr(n)),
            c = a !== !1 && (r.type === e.ERROR || y(a));
        if (!c) return h("invalid payload");
        r.data = a;
      }

      return f("decoded %s as %j", t, r), r;
    }

    function p(t) {
      try {
        return JSON.parse(t);
      } catch (e) {
        return !1;
      }
    }

    function u(t) {
      this.reconPack = t, this.buffers = [];
    }

    function h(t) {
      return {
        type: e.ERROR,
        data: "parser error: " + t
      };
    }

    var f = n(3)("socket.io-parser"),
        l = n(8),
        d = n(9),
        y = n(10),
        g = n(11);
    e.protocol = 4, e.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], e.CONNECT = 0, e.DISCONNECT = 1, e.EVENT = 2, e.ACK = 3, e.ERROR = 4, e.BINARY_EVENT = 5, e.BINARY_ACK = 6, e.Encoder = r, e.Decoder = a;
    var m = e.ERROR + '"encode error"';
    r.prototype.encode = function (t, n) {
      if (f("encoding packet %j", t), e.BINARY_EVENT === t.type || e.BINARY_ACK === t.type) s(t, n);else {
        var r = o(t);
        n([r]);
      }
    }, l(a.prototype), a.prototype.add = function (t) {
      var n;
      if ("string" == typeof t) n = c(t), e.BINARY_EVENT === n.type || e.BINARY_ACK === n.type ? (this.reconstructor = new u(n), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", n)) : this.emit("decoded", n);else {
        if (!g(t) && !t.base64) throw new Error("Unknown type: " + t);
        if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
        n = this.reconstructor.takeBinaryData(t), n && (this.reconstructor = null, this.emit("decoded", n));
      }
    }, a.prototype.destroy = function () {
      this.reconstructor && this.reconstructor.finishedReconstruction();
    }, u.prototype.takeBinaryData = function (t) {
      if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
        var e = d.reconstructPacket(this.reconPack, this.buffers);
        return this.finishedReconstruction(), e;
      }

      return null;
    }, u.prototype.finishedReconstruction = function () {
      this.reconPack = null, this.buffers = [];
    };
  }, function (t, e, n) {
    function r(t) {
      if (t) return o(t);
    }

    function o(t) {
      for (var e in r.prototype) t[e] = r.prototype[e];

      return t;
    }

    t.exports = r, r.prototype.on = r.prototype.addEventListener = function (t, e) {
      return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this;
    }, r.prototype.once = function (t, e) {
      function n() {
        this.off(t, n), e.apply(this, arguments);
      }

      return n.fn = e, this.on(t, n), this;
    }, r.prototype.off = r.prototype.removeListener = r.prototype.removeAllListeners = r.prototype.removeEventListener = function (t, e) {
      if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
      var n = this._callbacks["$" + t];
      if (!n) return this;
      if (1 == arguments.length) return delete this._callbacks["$" + t], this;

      for (var r, o = 0; o < n.length; o++) if (r = n[o], r === e || r.fn === e) {
        n.splice(o, 1);
        break;
      }

      return 0 === n.length && delete this._callbacks["$" + t], this;
    }, r.prototype.emit = function (t) {
      this._callbacks = this._callbacks || {};

      for (var e = new Array(arguments.length - 1), n = this._callbacks["$" + t], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];

      if (n) {
        n = n.slice(0);

        for (var r = 0, o = n.length; r < o; ++r) n[r].apply(this, e);
      }

      return this;
    }, r.prototype.listeners = function (t) {
      return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [];
    }, r.prototype.hasListeners = function (t) {
      return !!this.listeners(t).length;
    };
  }, function (t, e, n) {
    function r(t, e) {
      if (!t) return t;

      if (s(t)) {
        var n = {
          _placeholder: !0,
          num: e.length
        };
        return e.push(t), n;
      }

      if (i(t)) {
        for (var o = new Array(t.length), a = 0; a < t.length; a++) o[a] = r(t[a], e);

        return o;
      }

      if ("object" == typeof t && !(t instanceof Date)) {
        var o = {};

        for (var c in t) o[c] = r(t[c], e);

        return o;
      }

      return t;
    }

    function o(t, e) {
      if (!t) return t;
      if (t && t._placeholder) return e[t.num];
      if (i(t)) for (var n = 0; n < t.length; n++) t[n] = o(t[n], e);else if ("object" == typeof t) for (var r in t) t[r] = o(t[r], e);
      return t;
    }

    var i = n(10),
        s = n(11),
        a = Object.prototype.toString,
        c = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === a.call(Blob),
        p = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === a.call(File);
    e.deconstructPacket = function (t) {
      var e = [],
          n = t.data,
          o = t;
      return o.data = r(n, e), o.attachments = e.length, {
        packet: o,
        buffers: e
      };
    }, e.reconstructPacket = function (t, e) {
      return t.data = o(t.data, e), t.attachments = void 0, t;
    }, e.removeBlobs = function (t, e) {
      function n(t, a, u) {
        if (!t) return t;

        if (c && t instanceof Blob || p && t instanceof File) {
          r++;
          var h = new FileReader();
          h.onload = function () {
            u ? u[a] = this.result : o = this.result, --r || e(o);
          }, h.readAsArrayBuffer(t);
        } else if (i(t)) for (var f = 0; f < t.length; f++) n(t[f], f, t);else if ("object" == typeof t && !s(t)) for (var l in t) n(t[l], l, t);
      }

      var r = 0,
          o = t;
      n(o), r || e(o);
    };
  }, function (t, e) {
    var n = {}.toString;

    t.exports = Array.isArray || function (t) {
      return "[object Array]" == n.call(t);
    };
  }, function (t, e) {
    function n(t) {
      return r && Buffer.isBuffer(t) || o && (t instanceof ArrayBuffer || i(t));
    }

    t.exports = n;

    var r = "function" == typeof Buffer && "function" == typeof Buffer.isBuffer,
        o = "function" == typeof ArrayBuffer,
        i = function (t) {
      return "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer;
    };
  }, function (t, e, n) {
    function r(t, e) {
      if (!(this instanceof r)) return new r(t, e);
      t && "object" == typeof t && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = e, this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor(e.randomizationFactor || .5), this.backoff = new f({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      }), this.timeout(null == e.timeout ? 2e4 : e.timeout), this.readyState = "closed", this.uri = t, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = [];
      var n = e.parser || a;
      this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this.autoConnect = e.autoConnect !== !1, this.autoConnect && this.open();
    }

    var o = n(13),
        i = n(37),
        s = n(8),
        a = n(7),
        c = n(39),
        p = n(40),
        u = n(3)("socket.io-client:manager"),
        h = n(36),
        f = n(41),
        l = Object.prototype.hasOwnProperty;
    t.exports = r, r.prototype.emitAll = function () {
      this.emit.apply(this, arguments);

      for (var t in this.nsps) l.call(this.nsps, t) && this.nsps[t].emit.apply(this.nsps[t], arguments);
    }, r.prototype.updateSocketIds = function () {
      for (var t in this.nsps) l.call(this.nsps, t) && (this.nsps[t].id = this.generateId(t));
    }, r.prototype.generateId = function (t) {
      return ("/" === t ? "" : t + "#") + this.engine.id;
    }, s(r.prototype), r.prototype.reconnection = function (t) {
      return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
    }, r.prototype.reconnectionAttempts = function (t) {
      return arguments.length ? (this._reconnectionAttempts = t, this) : this._reconnectionAttempts;
    }, r.prototype.reconnectionDelay = function (t) {
      return arguments.length ? (this._reconnectionDelay = t, this.backoff && this.backoff.setMin(t), this) : this._reconnectionDelay;
    }, r.prototype.randomizationFactor = function (t) {
      return arguments.length ? (this._randomizationFactor = t, this.backoff && this.backoff.setJitter(t), this) : this._randomizationFactor;
    }, r.prototype.reconnectionDelayMax = function (t) {
      return arguments.length ? (this._reconnectionDelayMax = t, this.backoff && this.backoff.setMax(t), this) : this._reconnectionDelayMax;
    }, r.prototype.timeout = function (t) {
      return arguments.length ? (this._timeout = t, this) : this._timeout;
    }, r.prototype.maybeReconnectOnOpen = function () {
      !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
    }, r.prototype.open = r.prototype.connect = function (t, e) {
      if (u("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this;
      u("opening %s", this.uri), this.engine = o(this.uri, this.opts);
      var n = this.engine,
          r = this;
      this.readyState = "opening", this.skipReconnect = !1;
      var i = c(n, "open", function () {
        r.onopen(), t && t();
      }),
          s = c(n, "error", function (e) {
        if (u("connect_error"), r.cleanup(), r.readyState = "closed", r.emitAll("connect_error", e), t) {
          var n = new Error("Connection error");
          n.data = e, t(n);
        } else r.maybeReconnectOnOpen();
      });

      if (!1 !== this._timeout) {
        var a = this._timeout;
        u("connect attempt will timeout after %d", a), 0 === a && i.destroy();
        var p = setTimeout(function () {
          u("connect attempt timed out after %d", a), i.destroy(), n.close(), n.emit("error", "timeout"), r.emitAll("connect_timeout", a);
        }, a);
        this.subs.push({
          destroy: function () {
            clearTimeout(p);
          }
        });
      }

      return this.subs.push(i), this.subs.push(s), this;
    }, r.prototype.onopen = function () {
      u("open"), this.cleanup(), this.readyState = "open", this.emit("open");
      var t = this.engine;
      this.subs.push(c(t, "data", p(this, "ondata"))), this.subs.push(c(t, "ping", p(this, "onping"))), this.subs.push(c(t, "pong", p(this, "onpong"))), this.subs.push(c(t, "error", p(this, "onerror"))), this.subs.push(c(t, "close", p(this, "onclose"))), this.subs.push(c(this.decoder, "decoded", p(this, "ondecoded")));
    }, r.prototype.onping = function () {
      this.lastPing = new Date(), this.emitAll("ping");
    }, r.prototype.onpong = function () {
      this.emitAll("pong", new Date() - this.lastPing);
    }, r.prototype.ondata = function (t) {
      this.decoder.add(t);
    }, r.prototype.ondecoded = function (t) {
      this.emit("packet", t);
    }, r.prototype.onerror = function (t) {
      u("error", t), this.emitAll("error", t);
    }, r.prototype.socket = function (t, e) {
      function n() {
        ~h(o.connecting, r) || o.connecting.push(r);
      }

      var r = this.nsps[t];

      if (!r) {
        r = new i(this, t, e), this.nsps[t] = r;
        var o = this;
        r.on("connecting", n), r.on("connect", function () {
          r.id = o.generateId(t);
        }), this.autoConnect && n();
      }

      return r;
    }, r.prototype.destroy = function (t) {
      var e = h(this.connecting, t);
      ~e && this.connecting.splice(e, 1), this.connecting.length || this.close();
    }, r.prototype.packet = function (t) {
      u("writing packet %j", t);
      var e = this;
      t.query && 0 === t.type && (t.nsp += "?" + t.query), e.encoding ? e.packetBuffer.push(t) : (e.encoding = !0, this.encoder.encode(t, function (n) {
        for (var r = 0; r < n.length; r++) e.engine.write(n[r], t.options);

        e.encoding = !1, e.processPacketQueue();
      }));
    }, r.prototype.processPacketQueue = function () {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var t = this.packetBuffer.shift();
        this.packet(t);
      }
    }, r.prototype.cleanup = function () {
      u("cleanup");

      for (var t = this.subs.length, e = 0; e < t; e++) {
        var n = this.subs.shift();
        n.destroy();
      }

      this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy();
    }, r.prototype.close = r.prototype.disconnect = function () {
      u("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close();
    }, r.prototype.onclose = function (t) {
      u("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", t), this._reconnection && !this.skipReconnect && this.reconnect();
    }, r.prototype.reconnect = function () {
      if (this.reconnecting || this.skipReconnect) return this;
      var t = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) u("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;else {
        var e = this.backoff.duration();
        u("will wait %dms before reconnect attempt", e), this.reconnecting = !0;
        var n = setTimeout(function () {
          t.skipReconnect || (u("attempting reconnect"), t.emitAll("reconnect_attempt", t.backoff.attempts), t.emitAll("reconnecting", t.backoff.attempts), t.skipReconnect || t.open(function (e) {
            e ? (u("reconnect attempt error"), t.reconnecting = !1, t.reconnect(), t.emitAll("reconnect_error", e.data)) : (u("reconnect success"), t.onreconnect());
          }));
        }, e);
        this.subs.push({
          destroy: function () {
            clearTimeout(n);
          }
        });
      }
    }, r.prototype.onreconnect = function () {
      var t = this.backoff.attempts;
      this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", t);
    };
  }, function (t, e, n) {
    t.exports = n(14), t.exports.parser = n(22);
  }, function (t, e, n) {
    function r(t, e) {
      return this instanceof r ? (e = e || {}, t && "object" == typeof t && (e = t, t = null), t ? (t = u(t), e.hostname = t.host, e.secure = "https" === t.protocol || "wss" === t.protocol, e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = u(e.host).host), this.secure = null != e.secure ? e.secure : "undefined" != typeof location && "https:" === location.protocol, e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.agent = e.agent || !1, this.hostname = e.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = e.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? 443 : 80), this.query = e.query || {}, "string" == typeof this.query && (this.query = h.decode(this.query)), this.upgrade = !1 !== e.upgrade, this.path = (e.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!e.forceJSONP, this.jsonp = !1 !== e.jsonp, this.forceBase64 = !!e.forceBase64, this.enablesXDR = !!e.enablesXDR, this.withCredentials = !1 !== e.withCredentials, this.timestampParam = e.timestampParam || "t", this.timestampRequests = e.timestampRequests, this.transports = e.transports || ["polling", "websocket"], this.transportOptions = e.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = e.policyPort || 843, this.rememberUpgrade = e.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = e.onlyBinaryUpgrades, this.perMessageDeflate = !1 !== e.perMessageDeflate && (e.perMessageDeflate || {}), !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = e.pfx || null, this.key = e.key || null, this.passphrase = e.passphrase || null, this.cert = e.cert || null, this.ca = e.ca || null, this.ciphers = e.ciphers || null, this.rejectUnauthorized = void 0 === e.rejectUnauthorized || e.rejectUnauthorized, this.forceNode = !!e.forceNode, this.isReactNative = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(), ("undefined" == typeof self || this.isReactNative) && (e.extraHeaders && Object.keys(e.extraHeaders).length > 0 && (this.extraHeaders = e.extraHeaders), e.localAddress && (this.localAddress = e.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, void this.open()) : new r(t, e);
    }

    function o(t) {
      var e = {};

      for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);

      return e;
    }

    var i = n(15),
        s = n(8),
        a = n(3)("engine.io-client:socket"),
        c = n(36),
        p = n(22),
        u = n(2),
        h = n(30);
    t.exports = r, r.priorWebsocketSuccess = !1, s(r.prototype), r.protocol = p.protocol, r.Socket = r, r.Transport = n(21), r.transports = n(15), r.parser = n(22), r.prototype.createTransport = function (t) {
      a('creating transport "%s"', t);
      var e = o(this.query);
      e.EIO = p.protocol, e.transport = t;
      var n = this.transportOptions[t] || {};
      this.id && (e.sid = this.id);
      var r = new i[t]({
        query: e,
        socket: this,
        agent: n.agent || this.agent,
        hostname: n.hostname || this.hostname,
        port: n.port || this.port,
        secure: n.secure || this.secure,
        path: n.path || this.path,
        forceJSONP: n.forceJSONP || this.forceJSONP,
        jsonp: n.jsonp || this.jsonp,
        forceBase64: n.forceBase64 || this.forceBase64,
        enablesXDR: n.enablesXDR || this.enablesXDR,
        withCredentials: n.withCredentials || this.withCredentials,
        timestampRequests: n.timestampRequests || this.timestampRequests,
        timestampParam: n.timestampParam || this.timestampParam,
        policyPort: n.policyPort || this.policyPort,
        pfx: n.pfx || this.pfx,
        key: n.key || this.key,
        passphrase: n.passphrase || this.passphrase,
        cert: n.cert || this.cert,
        ca: n.ca || this.ca,
        ciphers: n.ciphers || this.ciphers,
        rejectUnauthorized: n.rejectUnauthorized || this.rejectUnauthorized,
        perMessageDeflate: n.perMessageDeflate || this.perMessageDeflate,
        extraHeaders: n.extraHeaders || this.extraHeaders,
        forceNode: n.forceNode || this.forceNode,
        localAddress: n.localAddress || this.localAddress,
        requestTimeout: n.requestTimeout || this.requestTimeout,
        protocols: n.protocols || void 0,
        isReactNative: this.isReactNative
      });
      return r;
    }, r.prototype.open = function () {
      var t;
      if (this.rememberUpgrade && r.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) t = "websocket";else {
        if (0 === this.transports.length) {
          var e = this;
          return void setTimeout(function () {
            e.emit("error", "No transports available");
          }, 0);
        }

        t = this.transports[0];
      }
      this.readyState = "opening";

      try {
        t = this.createTransport(t);
      } catch (n) {
        return this.transports.shift(), void this.open();
      }

      t.open(), this.setTransport(t);
    }, r.prototype.setTransport = function (t) {
      a("setting transport %s", t.name);
      var e = this;
      this.transport && (a("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = t, t.on("drain", function () {
        e.onDrain();
      }).on("packet", function (t) {
        e.onPacket(t);
      }).on("error", function (t) {
        e.onError(t);
      }).on("close", function () {
        e.onClose("transport close");
      });
    }, r.prototype.probe = function (t) {
      function e() {
        if (f.onlyBinaryUpgrades) {
          var e = !this.supportsBinary && f.transport.supportsBinary;
          h = h || e;
        }

        h || (a('probe transport "%s" opened', t), u.send([{
          type: "ping",
          data: "probe"
        }]), u.once("packet", function (e) {
          if (!h) if ("pong" === e.type && "probe" === e.data) {
            if (a('probe transport "%s" pong', t), f.upgrading = !0, f.emit("upgrading", u), !u) return;
            r.priorWebsocketSuccess = "websocket" === u.name, a('pausing current transport "%s"', f.transport.name), f.transport.pause(function () {
              h || "closed" !== f.readyState && (a("changing transport and sending upgrade packet"), p(), f.setTransport(u), u.send([{
                type: "upgrade"
              }]), f.emit("upgrade", u), u = null, f.upgrading = !1, f.flush());
            });
          } else {
            a('probe transport "%s" failed', t);
            var n = new Error("probe error");
            n.transport = u.name, f.emit("upgradeError", n);
          }
        }));
      }

      function n() {
        h || (h = !0, p(), u.close(), u = null);
      }

      function o(e) {
        var r = new Error("probe error: " + e);
        r.transport = u.name, n(), a('probe transport "%s" failed because of error: %s', t, e), f.emit("upgradeError", r);
      }

      function i() {
        o("transport closed");
      }

      function s() {
        o("socket closed");
      }

      function c(t) {
        u && t.name !== u.name && (a('"%s" works - aborting "%s"', t.name, u.name), n());
      }

      function p() {
        u.removeListener("open", e), u.removeListener("error", o), u.removeListener("close", i), f.removeListener("close", s), f.removeListener("upgrading", c);
      }

      a('probing transport "%s"', t);
      var u = this.createTransport(t, {
        probe: 1
      }),
          h = !1,
          f = this;
      r.priorWebsocketSuccess = !1, u.once("open", e), u.once("error", o), u.once("close", i), this.once("close", s), this.once("upgrading", c), u.open();
    }, r.prototype.onOpen = function () {
      if (a("socket open"), this.readyState = "open", r.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause) {
        a("starting upgrade probes");

        for (var t = 0, e = this.upgrades.length; t < e; t++) this.probe(this.upgrades[t]);
      }
    }, r.prototype.onPacket = function (t) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (a('socket receive: type "%s", data "%s"', t.type, t.data), this.emit("packet", t), this.emit("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;

        case "pong":
          this.setPing(), this.emit("pong");
          break;

        case "error":
          var e = new Error("server error");
          e.code = t.data, this.onError(e);
          break;

        case "message":
          this.emit("data", t.data), this.emit("message", t.data);
      } else a('packet received with socket readyState "%s"', this.readyState);
    }, r.prototype.onHandshake = function (t) {
      this.emit("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat));
    }, r.prototype.onHeartbeat = function (t) {
      clearTimeout(this.pingTimeoutTimer);
      var e = this;
      e.pingTimeoutTimer = setTimeout(function () {
        "closed" !== e.readyState && e.onClose("ping timeout");
      }, t || e.pingInterval + e.pingTimeout);
    }, r.prototype.setPing = function () {
      var t = this;
      clearTimeout(t.pingIntervalTimer), t.pingIntervalTimer = setTimeout(function () {
        a("writing ping packet - expecting pong within %sms", t.pingTimeout), t.ping(), t.onHeartbeat(t.pingTimeout);
      }, t.pingInterval);
    }, r.prototype.ping = function () {
      var t = this;
      this.sendPacket("ping", function () {
        t.emit("ping");
      });
    }, r.prototype.onDrain = function () {
      this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
    }, r.prototype.flush = function () {
      "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (a("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"));
    }, r.prototype.write = r.prototype.send = function (t, e, n) {
      return this.sendPacket("message", t, e, n), this;
    }, r.prototype.sendPacket = function (t, e, n, r) {
      if ("function" == typeof e && (r = e, e = void 0), "function" == typeof n && (r = n, n = null), "closing" !== this.readyState && "closed" !== this.readyState) {
        n = n || {}, n.compress = !1 !== n.compress;
        var o = {
          type: t,
          data: e,
          options: n
        };
        this.emit("packetCreate", o), this.writeBuffer.push(o), r && this.once("flush", r), this.flush();
      }
    }, r.prototype.close = function () {
      function t() {
        r.onClose("forced close"), a("socket closing - telling transport to close"), r.transport.close();
      }

      function e() {
        r.removeListener("upgrade", e), r.removeListener("upgradeError", e), t();
      }

      function n() {
        r.once("upgrade", e), r.once("upgradeError", e);
      }

      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        var r = this;
        this.writeBuffer.length ? this.once("drain", function () {
          this.upgrading ? n() : t();
        }) : this.upgrading ? n() : t();
      }

      return this;
    }, r.prototype.onError = function (t) {
      a("socket error %j", t), r.priorWebsocketSuccess = !1, this.emit("error", t), this.onClose("transport error", t);
    }, r.prototype.onClose = function (t, e) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        a('socket close with reason: "%s"', t);
        var n = this;
        clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", t, e), n.writeBuffer = [], n.prevBufferLen = 0;
      }
    }, r.prototype.filterUpgrades = function (t) {
      for (var e = [], n = 0, r = t.length; n < r; n++) ~c(this.transports, t[n]) && e.push(t[n]);

      return e;
    };
  }, function (t, e, n) {
    function r(t) {
      var e,
          n = !1,
          r = !1,
          a = !1 !== t.jsonp;

      if ("undefined" != typeof location) {
        var c = "https:" === location.protocol,
            p = location.port;
        p || (p = c ? 443 : 80), n = t.hostname !== location.hostname || p !== t.port, r = t.secure !== c;
      }

      if (t.xdomain = n, t.xscheme = r, e = new o(t), "open" in e && !t.forceJSONP) return new i(t);
      if (!a) throw new Error("JSONP disabled");
      return new s(t);
    }

    var o = n(16),
        i = n(19),
        s = n(33),
        a = n(34);
    e.polling = r, e.websocket = a;
  }, function (t, e, n) {
    var r = n(17),
        o = n(18);

    t.exports = function (t) {
      var e = t.xdomain,
          n = t.xscheme,
          i = t.enablesXDR;

      try {
        if ("undefined" != typeof XMLHttpRequest && (!e || r)) return new XMLHttpRequest();
      } catch (s) {}

      try {
        if ("undefined" != typeof XDomainRequest && !n && i) return new XDomainRequest();
      } catch (s) {}

      if (!e) try {
        return new o[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (s) {}
    };
  }, function (t, e) {
    try {
      t.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
    } catch (n) {
      t.exports = !1;
    }
  }, function (t, e) {
    t.exports = function () {
      return "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")();
    }();
  }, function (t, e, n) {
    function r() {}

    function o(t) {
      if (c.call(this, t), this.requestTimeout = t.requestTimeout, this.extraHeaders = t.extraHeaders, "undefined" != typeof location) {
        var e = "https:" === location.protocol,
            n = location.port;
        n || (n = e ? 443 : 80), this.xd = "undefined" != typeof location && t.hostname !== location.hostname || n !== t.port, this.xs = t.secure !== e;
      }
    }

    function i(t) {
      this.method = t.method || "GET", this.uri = t.uri, this.xd = !!t.xd, this.xs = !!t.xs, this.async = !1 !== t.async, this.data = void 0 !== t.data ? t.data : null, this.agent = t.agent, this.isBinary = t.isBinary, this.supportsBinary = t.supportsBinary, this.enablesXDR = t.enablesXDR, this.withCredentials = t.withCredentials, this.requestTimeout = t.requestTimeout, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.extraHeaders = t.extraHeaders, this.create();
    }

    function s() {
      for (var t in i.requests) i.requests.hasOwnProperty(t) && i.requests[t].abort();
    }

    var a = n(16),
        c = n(20),
        p = n(8),
        u = n(31),
        h = n(3)("engine.io-client:polling-xhr"),
        f = n(18);
    if (t.exports = o, t.exports.Request = i, u(o, c), o.prototype.supportsBinary = !0, o.prototype.request = function (t) {
      return t = t || {}, t.uri = this.uri(), t.xd = this.xd, t.xs = this.xs, t.agent = this.agent || !1, t.supportsBinary = this.supportsBinary, t.enablesXDR = this.enablesXDR, t.withCredentials = this.withCredentials, t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized, t.requestTimeout = this.requestTimeout, t.extraHeaders = this.extraHeaders, new i(t);
    }, o.prototype.doWrite = function (t, e) {
      var n = "string" != typeof t && void 0 !== t,
          r = this.request({
        method: "POST",
        data: t,
        isBinary: n
      }),
          o = this;
      r.on("success", e), r.on("error", function (t) {
        o.onError("xhr post error", t);
      }), this.sendXhr = r;
    }, o.prototype.doPoll = function () {
      h("xhr poll");
      var t = this.request(),
          e = this;
      t.on("data", function (t) {
        e.onData(t);
      }), t.on("error", function (t) {
        e.onError("xhr poll error", t);
      }), this.pollXhr = t;
    }, p(i.prototype), i.prototype.create = function () {
      var t = {
        agent: this.agent,
        xdomain: this.xd,
        xscheme: this.xs,
        enablesXDR: this.enablesXDR
      };
      t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized;
      var e = this.xhr = new a(t),
          n = this;

      try {
        h("xhr open %s: %s", this.method, this.uri), e.open(this.method, this.uri, this.async);

        try {
          if (this.extraHeaders) {
            e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);

            for (var r in this.extraHeaders) this.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.extraHeaders[r]);
          }
        } catch (o) {}

        if ("POST" === this.method) try {
          this.isBinary ? e.setRequestHeader("Content-type", "application/octet-stream") : e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (o) {}

        try {
          e.setRequestHeader("Accept", "*/*");
        } catch (o) {}

        "withCredentials" in e && (e.withCredentials = this.withCredentials), this.requestTimeout && (e.timeout = this.requestTimeout), this.hasXDR() ? (e.onload = function () {
          n.onLoad();
        }, e.onerror = function () {
          n.onError(e.responseText);
        }) : e.onreadystatechange = function () {
          if (2 === e.readyState) try {
            var t = e.getResponseHeader("Content-Type");
            (n.supportsBinary && "application/octet-stream" === t || "application/octet-stream; charset=UTF-8" === t) && (e.responseType = "arraybuffer");
          } catch (r) {}
          4 === e.readyState && (200 === e.status || 1223 === e.status ? n.onLoad() : setTimeout(function () {
            n.onError("number" == typeof e.status ? e.status : 0);
          }, 0));
        }, h("xhr data %s", this.data), e.send(this.data);
      } catch (o) {
        return void setTimeout(function () {
          n.onError(o);
        }, 0);
      }

      "undefined" != typeof document && (this.index = i.requestsCount++, i.requests[this.index] = this);
    }, i.prototype.onSuccess = function () {
      this.emit("success"), this.cleanup();
    }, i.prototype.onData = function (t) {
      this.emit("data", t), this.onSuccess();
    }, i.prototype.onError = function (t) {
      this.emit("error", t), this.cleanup(!0);
    }, i.prototype.cleanup = function (t) {
      if ("undefined" != typeof this.xhr && null !== this.xhr) {
        if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = r : this.xhr.onreadystatechange = r, t) try {
          this.xhr.abort();
        } catch (e) {}
        "undefined" != typeof document && delete i.requests[this.index], this.xhr = null;
      }
    }, i.prototype.onLoad = function () {
      var t;

      try {
        var e;

        try {
          e = this.xhr.getResponseHeader("Content-Type");
        } catch (n) {}

        t = "application/octet-stream" === e || "application/octet-stream; charset=UTF-8" === e ? this.xhr.response || this.xhr.responseText : this.xhr.responseText;
      } catch (n) {
        this.onError(n);
      }

      null != t && this.onData(t);
    }, i.prototype.hasXDR = function () {
      return "undefined" != typeof XDomainRequest && !this.xs && this.enablesXDR;
    }, i.prototype.abort = function () {
      this.cleanup();
    }, i.requestsCount = 0, i.requests = {}, "undefined" != typeof document) if ("function" == typeof attachEvent) attachEvent("onunload", s);else if ("function" == typeof addEventListener) {
      var l = "onpagehide" in f ? "pagehide" : "unload";
      addEventListener(l, s, !1);
    }
  }, function (t, e, n) {
    function r(t) {
      var e = t && t.forceBase64;
      u && !e || (this.supportsBinary = !1), o.call(this, t);
    }

    var o = n(21),
        i = n(30),
        s = n(22),
        a = n(31),
        c = n(32),
        p = n(3)("engine.io-client:polling");
    t.exports = r;

    var u = function () {
      var t = n(16),
          e = new t({
        xdomain: !1
      });
      return null != e.responseType;
    }();

    a(r, o), r.prototype.name = "polling", r.prototype.doOpen = function () {
      this.poll();
    }, r.prototype.pause = function (t) {
      function e() {
        p("paused"), n.readyState = "paused", t();
      }

      var n = this;

      if (this.readyState = "pausing", this.polling || !this.writable) {
        var r = 0;
        this.polling && (p("we are currently polling - waiting to pause"), r++, this.once("pollComplete", function () {
          p("pre-pause polling complete"), --r || e();
        })), this.writable || (p("we are currently writing - waiting to pause"), r++, this.once("drain", function () {
          p("pre-pause writing complete"), --r || e();
        }));
      } else e();
    }, r.prototype.poll = function () {
      p("polling"), this.polling = !0, this.doPoll(), this.emit("poll");
    }, r.prototype.onData = function (t) {
      var e = this;
      p("polling got data %s", t);

      var n = function (t, n, r) {
        return "opening" === e.readyState && "open" === t.type && e.onOpen(), "close" === t.type ? (e.onClose(), !1) : void e.onPacket(t);
      };

      s.decodePayload(t, this.socket.binaryType, n), "closed" !== this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" === this.readyState ? this.poll() : p('ignoring poll - transport state "%s"', this.readyState));
    }, r.prototype.doClose = function () {
      function t() {
        p("writing close packet"), e.write([{
          type: "close"
        }]);
      }

      var e = this;
      "open" === this.readyState ? (p("transport open - closing"), t()) : (p("transport not open - deferring close"), this.once("open", t));
    }, r.prototype.write = function (t) {
      var e = this;
      this.writable = !1;

      var n = function () {
        e.writable = !0, e.emit("drain");
      };

      s.encodePayload(t, this.supportsBinary, function (t) {
        e.doWrite(t, n);
      });
    }, r.prototype.uri = function () {
      var t = this.query || {},
          e = this.secure ? "https" : "http",
          n = "";
      !1 !== this.timestampRequests && (t[this.timestampParam] = c()), this.supportsBinary || t.sid || (t.b64 = 1), t = i.encode(t), this.port && ("https" === e && 443 !== Number(this.port) || "http" === e && 80 !== Number(this.port)) && (n = ":" + this.port), t.length && (t = "?" + t);
      var r = this.hostname.indexOf(":") !== -1;
      return e + "://" + (r ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t;
    };
  }, function (t, e, n) {
    function r(t) {
      this.path = t.path, this.hostname = t.hostname, this.port = t.port, this.secure = t.secure, this.query = t.query, this.timestampParam = t.timestampParam, this.timestampRequests = t.timestampRequests, this.readyState = "", this.agent = t.agent || !1, this.socket = t.socket, this.enablesXDR = t.enablesXDR, this.withCredentials = t.withCredentials, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.forceNode = t.forceNode, this.isReactNative = t.isReactNative, this.extraHeaders = t.extraHeaders, this.localAddress = t.localAddress;
    }

    var o = n(22),
        i = n(8);
    t.exports = r, i(r.prototype), r.prototype.onError = function (t, e) {
      var n = new Error(t);
      return n.type = "TransportError", n.description = e, this.emit("error", n), this;
    }, r.prototype.open = function () {
      return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this;
    }, r.prototype.close = function () {
      return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this;
    }, r.prototype.send = function (t) {
      if ("open" !== this.readyState) throw new Error("Transport not open");
      this.write(t);
    }, r.prototype.onOpen = function () {
      this.readyState = "open", this.writable = !0, this.emit("open");
    }, r.prototype.onData = function (t) {
      var e = o.decodePacket(t, this.socket.binaryType);
      this.onPacket(e);
    }, r.prototype.onPacket = function (t) {
      this.emit("packet", t);
    }, r.prototype.onClose = function () {
      this.readyState = "closed", this.emit("close");
    };
  }, function (t, e, n) {
    function r(t, n) {
      var r = "b" + e.packets[t.type] + t.data.data;
      return n(r);
    }

    function o(t, n, r) {
      if (!n) return e.encodeBase64Packet(t, r);
      var o = t.data,
          i = new Uint8Array(o),
          s = new Uint8Array(1 + o.byteLength);
      s[0] = v[t.type];

      for (var a = 0; a < i.length; a++) s[a + 1] = i[a];

      return r(s.buffer);
    }

    function i(t, n, r) {
      if (!n) return e.encodeBase64Packet(t, r);
      var o = new FileReader();
      return o.onload = function () {
        e.encodePacket({
          type: t.type,
          data: o.result
        }, n, !0, r);
      }, o.readAsArrayBuffer(t.data);
    }

    function s(t, n, r) {
      if (!n) return e.encodeBase64Packet(t, r);
      if (m) return i(t, n, r);
      var o = new Uint8Array(1);
      o[0] = v[t.type];
      var s = new k([o.buffer, t.data]);
      return r(s);
    }

    function a(t) {
      try {
        t = d.decode(t, {
          strict: !1
        });
      } catch (e) {
        return !1;
      }

      return t;
    }

    function c(t, e, n) {
      for (var r = new Array(t.length), o = l(t.length, n), i = function (t, n, o) {
        e(n, function (e, n) {
          r[t] = n, o(e, r);
        });
      }, s = 0; s < t.length; s++) i(s, t[s], o);
    }

    var p,
        u = n(23),
        h = n(24),
        f = n(25),
        l = n(26),
        d = n(27);
    "undefined" != typeof ArrayBuffer && (p = n(28));
    var y = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
        g = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent),
        m = y || g;
    e.protocol = 3;
    var v = e.packets = {
      open: 0,
      close: 1,
      ping: 2,
      pong: 3,
      message: 4,
      upgrade: 5,
      noop: 6
    },
        b = u(v),
        w = {
      type: "error",
      data: "parser error"
    },
        k = n(29);
    e.encodePacket = function (t, e, n, i) {
      "function" == typeof e && (i = e, e = !1), "function" == typeof n && (i = n, n = null);
      var a = void 0 === t.data ? void 0 : t.data.buffer || t.data;
      if ("undefined" != typeof ArrayBuffer && a instanceof ArrayBuffer) return o(t, e, i);
      if ("undefined" != typeof k && a instanceof k) return s(t, e, i);
      if (a && a.base64) return r(t, i);
      var c = v[t.type];
      return void 0 !== t.data && (c += n ? d.encode(String(t.data), {
        strict: !1
      }) : String(t.data)), i("" + c);
    }, e.encodeBase64Packet = function (t, n) {
      var r = "b" + e.packets[t.type];

      if ("undefined" != typeof k && t.data instanceof k) {
        var o = new FileReader();
        return o.onload = function () {
          var t = o.result.split(",")[1];
          n(r + t);
        }, o.readAsDataURL(t.data);
      }

      var i;

      try {
        i = String.fromCharCode.apply(null, new Uint8Array(t.data));
      } catch (s) {
        for (var a = new Uint8Array(t.data), c = new Array(a.length), p = 0; p < a.length; p++) c[p] = a[p];

        i = String.fromCharCode.apply(null, c);
      }

      return r += btoa(i), n(r);
    }, e.decodePacket = function (t, n, r) {
      if (void 0 === t) return w;

      if ("string" == typeof t) {
        if ("b" === t.charAt(0)) return e.decodeBase64Packet(t.substr(1), n);
        if (r && (t = a(t), t === !1)) return w;
        var o = t.charAt(0);
        return Number(o) == o && b[o] ? t.length > 1 ? {
          type: b[o],
          data: t.substring(1)
        } : {
          type: b[o]
        } : w;
      }

      var i = new Uint8Array(t),
          o = i[0],
          s = f(t, 1);
      return k && "blob" === n && (s = new k([s])), {
        type: b[o],
        data: s
      };
    }, e.decodeBase64Packet = function (t, e) {
      var n = b[t.charAt(0)];
      if (!p) return {
        type: n,
        data: {
          base64: !0,
          data: t.substr(1)
        }
      };
      var r = p.decode(t.substr(1));
      return "blob" === e && k && (r = new k([r])), {
        type: n,
        data: r
      };
    }, e.encodePayload = function (t, n, r) {
      function o(t) {
        return t.length + ":" + t;
      }

      function i(t, r) {
        e.encodePacket(t, !!s && n, !1, function (t) {
          r(null, o(t));
        });
      }

      "function" == typeof n && (r = n, n = null);
      var s = h(t);
      return n && s ? k && !m ? e.encodePayloadAsBlob(t, r) : e.encodePayloadAsArrayBuffer(t, r) : t.length ? void c(t, i, function (t, e) {
        return r(e.join(""));
      }) : r("0:");
    }, e.decodePayload = function (t, n, r) {
      if ("string" != typeof t) return e.decodePayloadAsBinary(t, n, r);
      "function" == typeof n && (r = n, n = null);
      var o;
      if ("" === t) return r(w, 0, 1);

      for (var i, s, a = "", c = 0, p = t.length; c < p; c++) {
        var u = t.charAt(c);

        if (":" === u) {
          if ("" === a || a != (i = Number(a))) return r(w, 0, 1);
          if (s = t.substr(c + 1, i), a != s.length) return r(w, 0, 1);

          if (s.length) {
            if (o = e.decodePacket(s, n, !1), w.type === o.type && w.data === o.data) return r(w, 0, 1);
            var h = r(o, c + i, p);
            if (!1 === h) return;
          }

          c += i, a = "";
        } else a += u;
      }

      return "" !== a ? r(w, 0, 1) : void 0;
    }, e.encodePayloadAsArrayBuffer = function (t, n) {
      function r(t, n) {
        e.encodePacket(t, !0, !0, function (t) {
          return n(null, t);
        });
      }

      return t.length ? void c(t, r, function (t, e) {
        var r = e.reduce(function (t, e) {
          var n;
          return n = "string" == typeof e ? e.length : e.byteLength, t + n.toString().length + n + 2;
        }, 0),
            o = new Uint8Array(r),
            i = 0;
        return e.forEach(function (t) {
          var e = "string" == typeof t,
              n = t;

          if (e) {
            for (var r = new Uint8Array(t.length), s = 0; s < t.length; s++) r[s] = t.charCodeAt(s);

            n = r.buffer;
          }

          e ? o[i++] = 0 : o[i++] = 1;

          for (var a = n.byteLength.toString(), s = 0; s < a.length; s++) o[i++] = parseInt(a[s]);

          o[i++] = 255;

          for (var r = new Uint8Array(n), s = 0; s < r.length; s++) o[i++] = r[s];
        }), n(o.buffer);
      }) : n(new ArrayBuffer(0));
    }, e.encodePayloadAsBlob = function (t, n) {
      function r(t, n) {
        e.encodePacket(t, !0, !0, function (t) {
          var e = new Uint8Array(1);

          if (e[0] = 1, "string" == typeof t) {
            for (var r = new Uint8Array(t.length), o = 0; o < t.length; o++) r[o] = t.charCodeAt(o);

            t = r.buffer, e[0] = 0;
          }

          for (var i = t instanceof ArrayBuffer ? t.byteLength : t.size, s = i.toString(), a = new Uint8Array(s.length + 1), o = 0; o < s.length; o++) a[o] = parseInt(s[o]);

          if (a[s.length] = 255, k) {
            var c = new k([e.buffer, a.buffer, t]);
            n(null, c);
          }
        });
      }

      c(t, r, function (t, e) {
        return n(new k(e));
      });
    }, e.decodePayloadAsBinary = function (t, n, r) {
      "function" == typeof n && (r = n, n = null);

      for (var o = t, i = []; o.byteLength > 0;) {
        for (var s = new Uint8Array(o), a = 0 === s[0], c = "", p = 1; 255 !== s[p]; p++) {
          if (c.length > 310) return r(w, 0, 1);
          c += s[p];
        }

        o = f(o, 2 + c.length), c = parseInt(c);
        var u = f(o, 0, c);
        if (a) try {
          u = String.fromCharCode.apply(null, new Uint8Array(u));
        } catch (h) {
          var l = new Uint8Array(u);
          u = "";

          for (var p = 0; p < l.length; p++) u += String.fromCharCode(l[p]);
        }
        i.push(u), o = f(o, c);
      }

      var d = i.length;
      i.forEach(function (t, o) {
        r(e.decodePacket(t, n, !0), o, d);
      });
    };
  }, function (t, e) {
    t.exports = Object.keys || function (t) {
      var e = [],
          n = Object.prototype.hasOwnProperty;

      for (var r in t) n.call(t, r) && e.push(r);

      return e;
    };
  }, function (t, e, n) {
    function r(t) {
      if (!t || "object" != typeof t) return !1;

      if (o(t)) {
        for (var e = 0, n = t.length; e < n; e++) if (r(t[e])) return !0;

        return !1;
      }

      if ("function" == typeof Buffer && Buffer.isBuffer && Buffer.isBuffer(t) || "function" == typeof ArrayBuffer && t instanceof ArrayBuffer || s && t instanceof Blob || a && t instanceof File) return !0;
      if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return r(t.toJSON(), !0);

      for (var i in t) if (Object.prototype.hasOwnProperty.call(t, i) && r(t[i])) return !0;

      return !1;
    }

    var o = n(10),
        i = Object.prototype.toString,
        s = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === i.call(Blob),
        a = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === i.call(File);
    t.exports = r;
  }, function (t, e) {
    t.exports = function (t, e, n) {
      var r = t.byteLength;
      if (e = e || 0, n = n || r, t.slice) return t.slice(e, n);
      if (e < 0 && (e += r), n < 0 && (n += r), n > r && (n = r), e >= r || e >= n || 0 === r) return new ArrayBuffer(0);

      for (var o = new Uint8Array(t), i = new Uint8Array(n - e), s = e, a = 0; s < n; s++, a++) i[a] = o[s];

      return i.buffer;
    };
  }, function (t, e) {
    function n(t, e, n) {
      function o(t, r) {
        if (o.count <= 0) throw new Error("after called too many times");
        --o.count, t ? (i = !0, e(t), e = n) : 0 !== o.count || i || e(null, r);
      }

      var i = !1;
      return n = n || r, o.count = t, 0 === t ? e() : o;
    }

    function r() {}

    t.exports = n;
  }, function (t, e) {
    function n(t) {
      for (var e, n, r = [], o = 0, i = t.length; o < i;) e = t.charCodeAt(o++), e >= 55296 && e <= 56319 && o < i ? (n = t.charCodeAt(o++), 56320 == (64512 & n) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), o--)) : r.push(e);

      return r;
    }

    function r(t) {
      for (var e, n = t.length, r = -1, o = ""; ++r < n;) e = t[r], e > 65535 && (e -= 65536, o += d(e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), o += d(e);

      return o;
    }

    function o(t, e) {
      if (t >= 55296 && t <= 57343) {
        if (e) throw Error("Lone surrogate U+" + t.toString(16).toUpperCase() + " is not a scalar value");
        return !1;
      }

      return !0;
    }

    function i(t, e) {
      return d(t >> e & 63 | 128);
    }

    function s(t, e) {
      if (0 == (4294967168 & t)) return d(t);
      var n = "";
      return 0 == (4294965248 & t) ? n = d(t >> 6 & 31 | 192) : 0 == (4294901760 & t) ? (o(t, e) || (t = 65533), n = d(t >> 12 & 15 | 224), n += i(t, 6)) : 0 == (4292870144 & t) && (n = d(t >> 18 & 7 | 240), n += i(t, 12), n += i(t, 6)), n += d(63 & t | 128);
    }

    function a(t, e) {
      e = e || {};

      for (var r, o = !1 !== e.strict, i = n(t), a = i.length, c = -1, p = ""; ++c < a;) r = i[c], p += s(r, o);

      return p;
    }

    function c() {
      if (l >= f) throw Error("Invalid byte index");
      var t = 255 & h[l];
      if (l++, 128 == (192 & t)) return 63 & t;
      throw Error("Invalid continuation byte");
    }

    function p(t) {
      var e, n, r, i, s;
      if (l > f) throw Error("Invalid byte index");
      if (l == f) return !1;
      if (e = 255 & h[l], l++, 0 == (128 & e)) return e;

      if (192 == (224 & e)) {
        if (n = c(), s = (31 & e) << 6 | n, s >= 128) return s;
        throw Error("Invalid continuation byte");
      }

      if (224 == (240 & e)) {
        if (n = c(), r = c(), s = (15 & e) << 12 | n << 6 | r, s >= 2048) return o(s, t) ? s : 65533;
        throw Error("Invalid continuation byte");
      }

      if (240 == (248 & e) && (n = c(), r = c(), i = c(), s = (7 & e) << 18 | n << 12 | r << 6 | i, s >= 65536 && s <= 1114111)) return s;
      throw Error("Invalid UTF-8 detected");
    }

    function u(t, e) {
      e = e || {};
      var o = !1 !== e.strict;
      h = n(t), f = h.length, l = 0;

      for (var i, s = []; (i = p(o)) !== !1;) s.push(i);

      return r(s);
    }
    /*! https://mths.be/utf8js v2.1.2 by @mathias */


    var h,
        f,
        l,
        d = String.fromCharCode;
    t.exports = {
      version: "2.1.2",
      encode: a,
      decode: u
    };
  }, function (t, e) {
    !function (t) {
      "use strict";

      e.encode = function (e) {
        var n,
            r = new Uint8Array(e),
            o = r.length,
            i = "";

        for (n = 0; n < o; n += 3) i += t[r[n] >> 2], i += t[(3 & r[n]) << 4 | r[n + 1] >> 4], i += t[(15 & r[n + 1]) << 2 | r[n + 2] >> 6], i += t[63 & r[n + 2]];

        return o % 3 === 2 ? i = i.substring(0, i.length - 1) + "=" : o % 3 === 1 && (i = i.substring(0, i.length - 2) + "=="), i;
      }, e.decode = function (e) {
        var n,
            r,
            o,
            i,
            s,
            a = .75 * e.length,
            c = e.length,
            p = 0;
        "=" === e[e.length - 1] && (a--, "=" === e[e.length - 2] && a--);
        var u = new ArrayBuffer(a),
            h = new Uint8Array(u);

        for (n = 0; n < c; n += 4) r = t.indexOf(e[n]), o = t.indexOf(e[n + 1]), i = t.indexOf(e[n + 2]), s = t.indexOf(e[n + 3]), h[p++] = r << 2 | o >> 4, h[p++] = (15 & o) << 4 | i >> 2, h[p++] = (3 & i) << 6 | 63 & s;

        return u;
      };
    }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  }, function (t, e) {
    function n(t) {
      return t.map(function (t) {
        if (t.buffer instanceof ArrayBuffer) {
          var e = t.buffer;

          if (t.byteLength !== e.byteLength) {
            var n = new Uint8Array(t.byteLength);
            n.set(new Uint8Array(e, t.byteOffset, t.byteLength)), e = n.buffer;
          }

          return e;
        }

        return t;
      });
    }

    function r(t, e) {
      e = e || {};
      var r = new i();
      return n(t).forEach(function (t) {
        r.append(t);
      }), e.type ? r.getBlob(e.type) : r.getBlob();
    }

    function o(t, e) {
      return new Blob(n(t), e || {});
    }

    var i = "undefined" != typeof i ? i : "undefined" != typeof WebKitBlobBuilder ? WebKitBlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder && MozBlobBuilder,
        s = function () {
      try {
        var t = new Blob(["hi"]);
        return 2 === t.size;
      } catch (e) {
        return !1;
      }
    }(),
        a = s && function () {
      try {
        var t = new Blob([new Uint8Array([1, 2])]);
        return 2 === t.size;
      } catch (e) {
        return !1;
      }
    }(),
        c = i && i.prototype.append && i.prototype.getBlob;

    "undefined" != typeof Blob && (r.prototype = Blob.prototype, o.prototype = Blob.prototype), t.exports = function () {
      return s ? a ? Blob : o : c ? r : void 0;
    }();
  }, function (t, e) {
    e.encode = function (t) {
      var e = "";

      for (var n in t) t.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n]));

      return e;
    }, e.decode = function (t) {
      for (var e = {}, n = t.split("&"), r = 0, o = n.length; r < o; r++) {
        var i = n[r].split("=");
        e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
      }

      return e;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      var n = function () {};

      n.prototype = e.prototype, t.prototype = new n(), t.prototype.constructor = t;
    };
  }, function (t, e) {
    "use strict";

    function n(t) {
      var e = "";

      do e = s[t % a] + e, t = Math.floor(t / a); while (t > 0);

      return e;
    }

    function r(t) {
      var e = 0;

      for (u = 0; u < t.length; u++) e = e * a + c[t.charAt(u)];

      return e;
    }

    function o() {
      var t = n(+new Date());
      return t !== i ? (p = 0, i = t) : t + "." + n(p++);
    }

    for (var i, s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), a = 64, c = {}, p = 0, u = 0; u < a; u++) c[s[u]] = u;

    o.encode = n, o.decode = r, t.exports = o;
  }, function (t, e, n) {
    function r() {}

    function o(t) {
      i.call(this, t), this.query = this.query || {}, c || (c = a.___eio = a.___eio || []), this.index = c.length;
      var e = this;
      c.push(function (t) {
        e.onData(t);
      }), this.query.j = this.index, "function" == typeof addEventListener && addEventListener("beforeunload", function () {
        e.script && (e.script.onerror = r);
      }, !1);
    }

    var i = n(20),
        s = n(31),
        a = n(18);
    t.exports = o;
    var c,
        p = /\n/g,
        u = /\\n/g;
    s(o, i), o.prototype.supportsBinary = !1, o.prototype.doClose = function () {
      this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), i.prototype.doClose.call(this);
    }, o.prototype.doPoll = function () {
      var t = this,
          e = document.createElement("script");
      this.script && (this.script.parentNode.removeChild(this.script), this.script = null), e.async = !0, e.src = this.uri(), e.onerror = function (e) {
        t.onError("jsonp poll error", e);
      };
      var n = document.getElementsByTagName("script")[0];
      n ? n.parentNode.insertBefore(e, n) : (document.head || document.body).appendChild(e), this.script = e;
      var r = "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent);
      r && setTimeout(function () {
        var t = document.createElement("iframe");
        document.body.appendChild(t), document.body.removeChild(t);
      }, 100);
    }, o.prototype.doWrite = function (t, e) {
      function n() {
        r(), e();
      }

      function r() {
        if (o.iframe) try {
          o.form.removeChild(o.iframe);
        } catch (t) {
          o.onError("jsonp polling iframe removal error", t);
        }

        try {
          var e = '<iframe src="javascript:0" name="' + o.iframeId + '">';
          i = document.createElement(e);
        } catch (t) {
          i = document.createElement("iframe"), i.name = o.iframeId, i.src = "javascript:0";
        }

        i.id = o.iframeId, o.form.appendChild(i), o.iframe = i;
      }

      var o = this;

      if (!this.form) {
        var i,
            s = document.createElement("form"),
            a = document.createElement("textarea"),
            c = this.iframeId = "eio_iframe_" + this.index;
        s.className = "socketio", s.style.position = "absolute", s.style.top = "-1000px", s.style.left = "-1000px", s.target = c, s.method = "POST", s.setAttribute("accept-charset", "utf-8"), a.name = "d", s.appendChild(a), document.body.appendChild(s), this.form = s, this.area = a;
      }

      this.form.action = this.uri(), r(), t = t.replace(u, "\\\n"), this.area.value = t.replace(p, "\\n");

      try {
        this.form.submit();
      } catch (h) {}

      this.iframe.attachEvent ? this.iframe.onreadystatechange = function () {
        "complete" === o.iframe.readyState && n();
      } : this.iframe.onload = n;
    };
  }, function (t, e, n) {
    function r(t) {
      var e = t && t.forceBase64;
      e && (this.supportsBinary = !1), this.perMessageDeflate = t.perMessageDeflate, this.usingBrowserWebSocket = o && !t.forceNode, this.protocols = t.protocols, this.usingBrowserWebSocket || (l = i), s.call(this, t);
    }

    var o,
        i,
        s = n(21),
        a = n(22),
        c = n(30),
        p = n(31),
        u = n(32),
        h = n(3)("engine.io-client:websocket");
    if ("undefined" != typeof WebSocket ? o = WebSocket : "undefined" != typeof self && (o = self.WebSocket || self.MozWebSocket), "undefined" == typeof window) try {
      i = n(35);
    } catch (f) {}
    var l = o || i;
    t.exports = r, p(r, s), r.prototype.name = "websocket", r.prototype.supportsBinary = !0, r.prototype.doOpen = function () {
      if (this.check()) {
        var t = this.uri(),
            e = this.protocols,
            n = {};
        this.isReactNative || (n.agent = this.agent, n.perMessageDeflate = this.perMessageDeflate, n.pfx = this.pfx, n.key = this.key, n.passphrase = this.passphrase, n.cert = this.cert, n.ca = this.ca, n.ciphers = this.ciphers, n.rejectUnauthorized = this.rejectUnauthorized), this.extraHeaders && (n.headers = this.extraHeaders), this.localAddress && (n.localAddress = this.localAddress);

        try {
          this.ws = this.usingBrowserWebSocket && !this.isReactNative ? e ? new l(t, e) : new l(t) : new l(t, e, n);
        } catch (r) {
          return this.emit("error", r);
        }

        void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners();
      }
    }, r.prototype.addEventListeners = function () {
      var t = this;
      this.ws.onopen = function () {
        t.onOpen();
      }, this.ws.onclose = function () {
        t.onClose();
      }, this.ws.onmessage = function (e) {
        t.onData(e.data);
      }, this.ws.onerror = function (e) {
        t.onError("websocket error", e);
      };
    }, r.prototype.write = function (t) {
      function e() {
        n.emit("flush"), setTimeout(function () {
          n.writable = !0, n.emit("drain");
        }, 0);
      }

      var n = this;
      this.writable = !1;

      for (var r = t.length, o = 0, i = r; o < i; o++) !function (t) {
        a.encodePacket(t, n.supportsBinary, function (o) {
          if (!n.usingBrowserWebSocket) {
            var i = {};

            if (t.options && (i.compress = t.options.compress), n.perMessageDeflate) {
              var s = "string" == typeof o ? Buffer.byteLength(o) : o.length;
              s < n.perMessageDeflate.threshold && (i.compress = !1);
            }
          }

          try {
            n.usingBrowserWebSocket ? n.ws.send(o) : n.ws.send(o, i);
          } catch (a) {
            h("websocket closed before onclose event");
          }

          --r || e();
        });
      }(t[o]);
    }, r.prototype.onClose = function () {
      s.prototype.onClose.call(this);
    }, r.prototype.doClose = function () {
      "undefined" != typeof this.ws && this.ws.close();
    }, r.prototype.uri = function () {
      var t = this.query || {},
          e = this.secure ? "wss" : "ws",
          n = "";
      this.port && ("wss" === e && 443 !== Number(this.port) || "ws" === e && 80 !== Number(this.port)) && (n = ":" + this.port), this.timestampRequests && (t[this.timestampParam] = u()), this.supportsBinary || (t.b64 = 1), t = c.encode(t), t.length && (t = "?" + t);
      var r = this.hostname.indexOf(":") !== -1;
      return e + "://" + (r ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t;
    }, r.prototype.check = function () {
      return !(!l || "__initialize" in l && this.name === r.prototype.name);
    };
  }, function (t, e) {}, function (t, e) {
    var n = [].indexOf;

    t.exports = function (t, e) {
      if (n) return t.indexOf(e);

      for (var r = 0; r < t.length; ++r) if (t[r] === e) return r;

      return -1;
    };
  }, function (t, e, n) {
    function r(t, e, n) {
      this.io = t, this.nsp = e, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, n && n.query && (this.query = n.query), this.io.autoConnect && this.open();
    }

    var o = n(7),
        i = n(8),
        s = n(38),
        a = n(39),
        c = n(40),
        p = n(3)("socket.io-client:socket"),
        u = n(30),
        h = n(24);
    t.exports = e = r;
    var f = {
      connect: 1,
      connect_error: 1,
      connect_timeout: 1,
      connecting: 1,
      disconnect: 1,
      error: 1,
      reconnect: 1,
      reconnect_attempt: 1,
      reconnect_failed: 1,
      reconnect_error: 1,
      reconnecting: 1,
      ping: 1,
      pong: 1
    },
        l = i.prototype.emit;
    i(r.prototype), r.prototype.subEvents = function () {
      if (!this.subs) {
        var t = this.io;
        this.subs = [a(t, "open", c(this, "onopen")), a(t, "packet", c(this, "onpacket")), a(t, "close", c(this, "onclose"))];
      }
    }, r.prototype.open = r.prototype.connect = function () {
      return this.connected ? this : (this.subEvents(), this.io.reconnecting || this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting"), this);
    }, r.prototype.send = function () {
      var t = s(arguments);
      return t.unshift("message"), this.emit.apply(this, t), this;
    }, r.prototype.emit = function (t) {
      if (f.hasOwnProperty(t)) return l.apply(this, arguments), this;
      var e = s(arguments),
          n = {
        type: (void 0 !== this.flags.binary ? this.flags.binary : h(e)) ? o.BINARY_EVENT : o.EVENT,
        data: e
      };
      return n.options = {}, n.options.compress = !this.flags || !1 !== this.flags.compress, "function" == typeof e[e.length - 1] && (p("emitting packet with ack id %d", this.ids), this.acks[this.ids] = e.pop(), n.id = this.ids++), this.connected ? this.packet(n) : this.sendBuffer.push(n), this.flags = {}, this;
    }, r.prototype.packet = function (t) {
      t.nsp = this.nsp, this.io.packet(t);
    }, r.prototype.onopen = function () {
      if (p("transport is open - connecting"), "/" !== this.nsp) if (this.query) {
        var t = "object" == typeof this.query ? u.encode(this.query) : this.query;
        p("sending connect packet with query %s", t), this.packet({
          type: o.CONNECT,
          query: t
        });
      } else this.packet({
        type: o.CONNECT
      });
    }, r.prototype.onclose = function (t) {
      p("close (%s)", t), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", t);
    }, r.prototype.onpacket = function (t) {
      var e = t.nsp === this.nsp,
          n = t.type === o.ERROR && "/" === t.nsp;
      if (e || n) switch (t.type) {
        case o.CONNECT:
          this.onconnect();
          break;

        case o.EVENT:
          this.onevent(t);
          break;

        case o.BINARY_EVENT:
          this.onevent(t);
          break;

        case o.ACK:
          this.onack(t);
          break;

        case o.BINARY_ACK:
          this.onack(t);
          break;

        case o.DISCONNECT:
          this.ondisconnect();
          break;

        case o.ERROR:
          this.emit("error", t.data);
      }
    }, r.prototype.onevent = function (t) {
      var e = t.data || [];
      p("emitting event %j", e), null != t.id && (p("attaching ack callback to event"), e.push(this.ack(t.id))), this.connected ? l.apply(this, e) : this.receiveBuffer.push(e);
    }, r.prototype.ack = function (t) {
      var e = this,
          n = !1;
      return function () {
        if (!n) {
          n = !0;
          var r = s(arguments);
          p("sending ack %j", r), e.packet({
            type: h(r) ? o.BINARY_ACK : o.ACK,
            id: t,
            data: r
          });
        }
      };
    }, r.prototype.onack = function (t) {
      var e = this.acks[t.id];
      "function" == typeof e ? (p("calling ack %s with %j", t.id, t.data), e.apply(this, t.data), delete this.acks[t.id]) : p("bad ack %s", t.id);
    }, r.prototype.onconnect = function () {
      this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered();
    }, r.prototype.emitBuffered = function () {
      var t;

      for (t = 0; t < this.receiveBuffer.length; t++) l.apply(this, this.receiveBuffer[t]);

      for (this.receiveBuffer = [], t = 0; t < this.sendBuffer.length; t++) this.packet(this.sendBuffer[t]);

      this.sendBuffer = [];
    }, r.prototype.ondisconnect = function () {
      p("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect");
    }, r.prototype.destroy = function () {
      if (this.subs) {
        for (var t = 0; t < this.subs.length; t++) this.subs[t].destroy();

        this.subs = null;
      }

      this.io.destroy(this);
    }, r.prototype.close = r.prototype.disconnect = function () {
      return this.connected && (p("performing disconnect (%s)", this.nsp), this.packet({
        type: o.DISCONNECT
      })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
    }, r.prototype.compress = function (t) {
      return this.flags.compress = t, this;
    }, r.prototype.binary = function (t) {
      return this.flags.binary = t, this;
    };
  }, function (t, e) {
    function n(t, e) {
      var n = [];
      e = e || 0;

      for (var r = e || 0; r < t.length; r++) n[r - e] = t[r];

      return n;
    }

    t.exports = n;
  }, function (t, e) {
    function n(t, e, n) {
      return t.on(e, n), {
        destroy: function () {
          t.removeListener(e, n);
        }
      };
    }

    t.exports = n;
  }, function (t, e) {
    var n = [].slice;

    t.exports = function (t, e) {
      if ("string" == typeof e && (e = t[e]), "function" != typeof e) throw new Error("bind() requires a function");
      var r = n.call(arguments, 2);
      return function () {
        return e.apply(t, r.concat(n.call(arguments)));
      };
    };
  }, function (t, e) {
    function n(t) {
      t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0;
    }

    t.exports = n, n.prototype.duration = function () {
      var t = this.ms * Math.pow(this.factor, this.attempts++);

      if (this.jitter) {
        var e = Math.random(),
            n = Math.floor(e * this.jitter * t);
        t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n;
      }

      return 0 | Math.min(t, this.max);
    }, n.prototype.reset = function () {
      this.attempts = 0;
    }, n.prototype.setMin = function (t) {
      this.ms = t;
    }, n.prototype.setMax = function (t) {
      this.max = t;
    }, n.prototype.setJitter = function (t) {
      this.jitter = t;
    };
  }]);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/webpack/node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./rtcbase/src/modules/Room.js":
/*!*************************************!*\
  !*** ./rtcbase/src/modules/Room.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Room; });
/* harmony import */ var _common_Connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Connection */ "./rtcbase/src/common/Connection.js");
/* harmony import */ var _utils_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Events */ "./rtcbase/src/utils/Events.js");
/* harmony import */ var _common_Socket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Socket */ "./rtcbase/src/common/Socket.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Stream */ "./rtcbase/src/modules/Stream.js");
/* harmony import */ var _utils_ErizoMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/ErizoMap */ "./rtcbase/src/utils/ErizoMap.js");
/* harmony import */ var _utils_Base64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/Base64 */ "./rtcbase/src/utils/Base64.js");
/* harmony import */ var _common_Definition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/Definition */ "./rtcbase/src/common/Definition.js");
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");
/* global navigator window fetch */









const DISCONNECTED = 0;
const CONNECTING = 1;
const CONNECTED = 2;
const DISCONNECTING = 3;
const stateDiscribeList = ['DISCONNECTED', 'CONNECTING', 'CONNECTED', 'DISCONNECTING'];

class Room extends _utils_Events__WEBPACK_IMPORTED_MODULE_1__["EventDispatcher"] {
  constructor(specInput) {
    super(specInput);
    
    this.spec = specInput;
    this.roomID = '';
    this.clientID = '';
    this.localuser = {};
    this.forceTurn = this.spec.forceTurn;
    this.mode = this.spec.mode;
    if (this.mode !== 'rtc' && this.mode !== 'live') {
      this.mode = 'rtc';
    }
    this.Connection = _common_Connection__WEBPACK_IMPORTED_MODULE_0__["default"];
    this.state = DISCONNECTED;
    const socket = new _common_Socket__WEBPACK_IMPORTED_MODULE_2__["Socket"]();
    this.socket = socket;
    this.remoteStreams = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_4__["default"])();
    this.localStreams = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_4__["default"])();
    this.publishingStreams = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_4__["default"])();
    this.mixRtpStream = null;

    // 监听媒体设备变化事件
    // Todo 事件有可能在用户未监听时抛出
    if(navigator.mediaDevices) {
      navigator.mediaDevices.ondevicechange = (event) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('media devices change', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].DEVICE_CHANGE_EVENT });
        const deviceChangeEvt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["RoomEvent"]({
          type: 'device-change',
          message: 'media devices change'
        });
        this.dispatchEvent(deviceChangeEvt);
      };
    }
    // 监听浏览器刷新&关闭，并上报事件
    window.addEventListener('beforeunload', (event) => {
      let kEvent = this.state === CONNECTED ? _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].EVENT_BEFOREUNLOAD_WHEN_CONNECTED : _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].EVENT_BEFOREUNLOAD_WHEN_UNCONNECTED;
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].fetch('beforeunload', { k: kEvent });
    }, false);

    // 监听网络状态
    window.addEventListener('offline', (e) => { 
      const network = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["RoomEvent"]({
        type: 'network-change',
        message: 'offline'
      })
      this.dispatchEvent(network);
    });
    window.addEventListener('online', (e) => { 
      const network = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["RoomEvent"]({
        type: 'network-change',
        message: 'online'
      })
      this.dispatchEvent(network);
    });

    // 定时上报
    global.setInterval(this.pubSubStatsLog.bind(this), 3000);
    // 开启所有监听
    this.on('room-disconnected', this.clearAll.bind(this));
    socket.on('remoteUserEnterRoom', this.socketOnRemoteUserEnterRoom.bind(this));
    socket.on('remoteUserQuitRoom', this.socketOnRemoteUserQuitRoom.bind(this));
    socket.on('onAddStream', this.socketOnAddStream.bind(this));
    socket.on('onRemoveStream', this.socketOnRemoveStream.bind(this));
    socket.on('onPublished', this.socketOnPublished.bind(this));
    socket.on('onPublishInit', this.socketOnPublishInit.bind(this));
    socket.on('signaling_message_vhall', this.socketOnErizoMessage.bind(this));
    socket.on('onUpdateAttributeStream', this.socketOnUpdateAttributeStream.bind(this));
    socket.on('disconnect', this.socketOnDisconnect.bind(this));
    socket.on('error', this.socketOnError.bind(this));
    socket.on('connection_failed', this.socketOnICEConnectionFailed.bind(this));
    socket.on('broadcastMuteStream', this.socketOnBroadcastMuteStream.bind(this));
    socket.on('userDeleted', this.socketOnUserDeleted.bind(this));
    socket.on('customSignalling', this.socketOnCustomSignalling.bind(this));
    //以下废弃
    /*
    socket.on('usersPermissionChanged', this.socketOnUsersPermissionChanged.bind(this));
    socket.on('onAddMixRtpStream', this.socketOnAddMixRtpStream.bind(this));
    socket.on('onRemoveMixRtpStream', this.socketOnRemoveMixRtpStream.bind(this));
    socket.on('onBandwidthAlert', this.socketOnBandwidthAlert.bind(this));
    socket.on('StreamApply', this.socketOnStreamApply.bind(this));
    socket.on('StreamConsent', this.socketOnStreamConsent.bind(this));
    socket.on('StreamReject', this.socketOnStreamReject.bind(this));
    */
  }
  // Private functions
  removeStream(streamInput, reason = 'default') {
    const stream = streamInput;
    stream.stopMonitorStats();
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].stopPlayMessageLog(stream);
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].stopPublishMessageLog(stream);
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].stopReportFrame(stream);

    // close stream
    if (stream.stream) {
      stream.close(`${reason}-removeStream`);
      delete stream.stream;
    }
    // Close peerConnection
    if (stream.pc) {
      stream.pc.close();
      delete stream.pc;
    }
  };

  onStreamFailed(streamInput, reason = 'onStreamFailed') {
    const stream = streamInput;
    if (this.state !== DISCONNECTED && stream) {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`stream-failed, reason: ${reason}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_STREAM_FAILED, streamId: stream.getID() });
      stream.failed = true;
      const streamFailedEvt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({
        type: 'stream-failed',
        msg: 'Stream failed after connection',
        reason,
        stream,
      });
      this.dispatchEvent(streamFailedEvt);
      if (stream.local) {
        this.unpublish(stream, () => { }, reason);
      } else {
        this.unsubscribe(stream, () => { }, reason);
      }
    }
  };

  socketOnAddStream(event) {
    let arg = event.args[0];
    const streamId = arg.id;
    if (this.localStreams.has(streamId)) {
      return;
    }
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug('new stream added', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].NEW_STREAM_ADD, streamId });
    const stream = new _Stream__WEBPACK_IMPORTED_MODULE_3__["default"](this.Connection, {
      streamID: streamId,
      local: false,
      audio: arg.audio,
      video: arg.video,
      screen: arg.screen,
      attributes: arg.attributes,
      user: arg.user,
      simulcast: arg.simulcast,
      streamType: arg.streamType,
      initMuted: arg.muteStream
    });
    stream.room = this;
    this.remoteStreams.add(streamId, stream);
    const roomInfo = arg.roomInfo;
    const evt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'stream-added', stream, roomInfo });
    this.dispatchEvent(evt);
  }

  socketOnPublished(event) {
    let arg = event.args[0];
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('LocalStream published success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].PUBLISH_RESULT, streamId: arg.id });
    if (this.localStreams.has(arg.id)) {
      const stream = this.localStreams.get(arg.id);
      // todo: getOverseas
      stream.isPublished = true;
      stream.startMonitorStats();
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].startPublishMessageLog(stream);
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].startReportFrame(stream);
      const evt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'stream-published', stream });
      this.dispatchEvent(evt);
    } else {
      const msg = 'stream not found when socketOnPublished';
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_STREAM_NOT_FOUND, streamId: arg.id });
    }
  }

  socketOnPublishInit(event) {
    let arg = event.args[0];
    const streamId = arg.streamId;
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug('localStream publish init', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].PUBLISH_RESULT, streamId: streamId });

    let info = this.publishingStreams.get(streamId);
    const stream = info.stream;
    stream.setID(streamId);
    stream.room = this;
    stream.on('internal-set-attributes', this.updateAttributesFromStreamEvent);
    this.localStreams.add(streamId, stream);
    this.createLocalStreamErizoConnection(stream, info.options);
    this.publishingStreams.remove(streamId);
  }

  socketOnErizoMessage(event) {
    let arg = event.args[0];
    let remote;
    let stream;
    if (this.mixRtpStream && arg.peerId && arg.peerId === this.mixRtpStream.getID()) {
      stream = this.mixRtpStream;
      remote = true;
    } else if (arg.peerId) {
      stream = this.remoteStreams.get(arg.peerId);
      remote = true;
    } else {
      stream = this.localStreams.get(arg.streamId);
      remote = false;
    }

    if (stream && !stream.failed) {
      if (remote && arg.mess.type === 'answer') {
        const msg = 'receive remote stream answer:';
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].PROCESS_REMOTE_ANSWER, streamId: stream.getID(), Collapsed: arg.mess });
      } else if (remote && arg.mess.type === 'ready') {
        const msg = 'receive remote stream ready:';
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].RECV_REMOTE_READY, streamId: stream.getID(), Collapsed: arg.mess });
      } else if (arg.mess.type === 'answer') {
        const msg = 'receive local stream answer:';
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].PROCESS_LOCAL_ANSWER, streamId: stream.getID(), Collapsed: arg.mess });
      } else if (arg.mess.type === 'ready') {
        const msg = 'receive local stream ready:';
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].RECV_LOCAL_READY, streamId: stream.getID(), Collapsed: arg.mess });
      }
      stream.pc.processSignalingMessage(arg.mess);
    }
  }

  socketOnUpdateAttributeStream(event) {
    let arg = event.args[0];
    const stream = this.remoteStreams.get(arg.id);
    const evt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({
      type: 'stream-attributes-update',
      attrs: arg.attrs,
      stream
    });
    stream.updateLocalAttributes(arg.attrs);
    stream.dispatchEvent(evt);
  }

  socketOnRemoveStream(event) {
    let arg = event.args[0];
    const streamId = arg.id;
    if (this.localStreams.has(streamId)) {
      const stream = this.localStreams.get(streamId);
      const msg = 'server remove local stream';
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_REMOTE_LOCAL_STREAM, streamId: stream.getID() });
      this.onStreamFailed(stream, 'removed-server');
      return;
    }
    if (this.remoteStreams.has(streamId)) {
      const stream = this.remoteStreams.get(streamId);
      const msg = 'server remove remote stream';
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].REMOVE_REMOTE_STREAM, streamId: stream.getID() });
      this.remoteStreams.remove(streamId);
      this.removeStream(stream, 'OnRemoveStream');
      const roomInfo = arg.roomInfo;
      const evt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'stream-removed', stream, roomInfo });
      this.dispatchEvent(evt);
    }
  }

  socketOnDisconnect(reason, closeCode) {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(`websocket OnDisconnect code: ${closeCode}, reason: ${reason}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].DISCONNECT_SERVER });
    if (this.state !== DISCONNECTED) {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('Forced to disconnect from the signaling service', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_DISCONNECT });
      this.state = DISCONNECTING;
      const disconnectEvt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["RoomEvent"]({
        type: 'room-disconnected',
        message: 'unexpected-disconnection'
      });
      this.dispatchEvent(disconnectEvt);
    }
  }

  socketOnError() {
    const msg = 'room connect error';
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CONNECT_SERVER });
    this.state = DISCONNECTING;
    const disconnectEvt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["RoomEvent"]({
      type: 'room-disconnected',
      message: 'unexpected-disconnection'
    });
    this.dispatchEvent(disconnectEvt);
  }

  socketOnICEConnectionFailed(event) {
    let arg = event.args[0];
    let stream;
    if (!arg.streamId) {
      return;
    }

    if (arg.type === 'publish') {
      const msg = 'Publish local stream, On ICE connection failed from server';
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CONNECT_LOCAL_PEER, streamId: arg.streamId });
      stream = this.localStreams.get(arg.streamId);
    } else if (this.mixRtpStream && arg.streamId === this.mixRtpStream.getID()) {
      const msg = 'Subscribe mix-rtp stream, On ICE connection failed from server';
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_REMOTE_PEER, streamId: arg.streamId });
      stream = this.mixRtpStream;
    } else {
      const msg = 'Subscribe remote stream, On ICE connection failed from server';
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_REMOTE_PEER, streamId: arg.streamId });
      stream = this.remoteStreams.get(arg.streamId);
    }
    this.onStreamFailed(stream, 'ice-failed-server');
  }

  socketOnBroadcastMuteStream(event) {
    let arg = event.args[0];
    const streamId = arg.id;
    let stream;
    if (this.localStreams.has(streamId)) {
      stream = this.localStreams.get(streamId);
    }
    if (this.remoteStreams.has(streamId)) {
      stream = this.remoteStreams.get(streamId);
    }
    const evt2 = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'room-stream-mute', msg: arg, stream });
    this.dispatchEvent(evt2);
  }

  socketOnUserDeleted(event) {
    let arg = event.args[0];
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(`socket on userDeleted: ${arg.id}`);
    const evt2 = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'room-user-deleted', msg: arg.id });
    this.dispatchEvent(evt2);
  }

  socketOnCustomSignalling(event) {
    let arg = event.args[0];
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(`sokect on Custom Signalling: ${arg}`);
    const evt2 = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'room-custom-signalling', msg: arg });
    this.dispatchEvent(evt2);
  }

  socketOnRemoteUserEnterRoom(event) {
    let arg = event.args[0];
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(`Remote User Enter Room: ${JSON.stringify(arg)}`);
    const evt2 = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'enter-room', msg: arg });
    this.dispatchEvent(evt2);
  }

  socketOnRemoteUserQuitRoom(event) {
    let arg = event.args[0];
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(`Remote User Quit Room: ${JSON.stringify(arg)}`);
    const evt2 = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'quit-room', msg: arg });
    this.dispatchEvent(evt2);
  }

  getErizoConnectionOptions(stream, options, isRemote) {
    const connectionOpts = {
      callback: (message) => {
        if (isRemote && message.type === 'offer') {
          const msg = 'Send remote stream offer:';
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_REMOTE_OFFER, streamId: stream.getID(), Collapsed: message });
        } else if (isRemote && message.type === 'candidate') {
          const msg = 'Send remote stream candidate:';
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_REMOTE_CAND, streamId: stream.getID(), Collapsed: message });
        } else if (message.type === 'offer') {
          const msg = 'Send local stream offer:';
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_LOCAL_OFFER, streamId: stream.getID(), Collapsed: message });
        } else if (message.type === 'candidate') {
          const msg = 'Send local stream candidate:';
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_LOCAL_CAND, streamId: stream.getID(), Collapsed: message });
        }
        this.socket.sendMessage('signaling_message', {
          streamId: stream.getID(),
          msg: message,
        }, () => { });
      },
      audio: options.audio && stream.hasAudio(),
      video: options.video && stream.hasVideo(),
      audioProfle: stream.getAudioProfile(),
      maxAudioBW: options.maxAudioBW,
      maxVideoBW: options.maxVideoBW,
      limitMaxVideoBW: this.spec.maxVideoBW,
      iceServers: this.iceServers,
      forceTurn: options.forceTurn,
      enableOpusNack: (this.spec.enableOpusNack !== false),
      simulcast: options.simulcast,
      streamId: stream.getID(),
    };
    if (!isRemote) {
      connectionOpts.startVideoBW = options.startVideoBW;
      connectionOpts.hardMinVideoBW = options.hardMinVideoBW;
    }
    return connectionOpts;
  }

  createRemoteStreamErizoConnection(streamInput, options) {
    const stream = streamInput;
    let msg = 'create peerconnection for remote stream';
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CREATE_REMOTE_PEER, streamId: stream.getID() });
    return new Promise((resolve) => {
      stream.pc = this.Connection.buildConnection(this.getErizoConnectionOptions(stream, options, true));
      stream.pc.onaddstream = (evt) => {
        stream.stream = evt.stream;
        stream.startMonitorStats();
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].startPlayMessageLog(stream);
        resolve(stream);
      };
      stream.pc.oniceconnectionstatechange = (state) => {
        if (state === 'failed') {
          msg = `Subscribe remote stream, On ICE connection failed, state: ${state}`;
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_REMOTE_PEER, streamId: stream.getID() });
          this.onStreamFailed(stream, 'ice-failed-client');
        } else {
          msg = `Subscribe remote stream, On ICE connection change, state: ${state}`;
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_REMOTE_PEER, streamId: stream.getID() });
          if (state === 'completed') {
            stream.reportICEStatus(_common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SUBSCRIBE_ICE_STATUS);
          }
        }
      };

      stream.pc.createOffer(true);
    });
  }

  createLocalStreamErizoConnection(streamInput, options) {
    const stream = streamInput;
    let msg = 'create peerconnection for localStream';
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CREATE_LOCAL_PEER, streamId: stream.getID() });
    const Constraints = this.getErizoConnectionOptions(stream, options);
    stream.pc = this.Connection.buildConnection(Constraints);
    console.warn('进行发送peernecttion........',stream, stream.cloneVideo && stream.cloneStream);
    if(stream.cloneVideo && stream.cloneStream){
      stream.pc.addStream(stream.cloneStream);
    }else{
      stream.pc.addStream(stream.stream);
    }
    stream.pc.oniceconnectionstatechange = (state) => {
      if (state === 'failed') {
        msg = `Publish local stream, On ICE connection failed, state: ${state}`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CONNECT_LOCAL_PEER, streamId: stream.getID() });
        this.onStreamFailed(stream, 'ice-failed-client');
      } else {
        msg = `Publish local stream, On ICE connection change, state: ${state}`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { streamId: stream.getID() });
        if (state === 'completed') {
          stream.reportICEStatus(_common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].PUBLISH_ICE_STATUS);
        }
      }
    };
    
    stream.pc.createOffer();
  }

  updateAttributesFromStreamEvent(evt) {
    const stream = evt.stream;
    const attrs = evt.attrs;
    if (stream.local) {
      stream.updateLocalAttributes(attrs);
      this.socket.sendMessage('updateStreamAttributes', { id: stream.getID(), attrs });
    } else {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('You can not update attributes in a remote stream');
    }
  }

  createSdpConstraints(type, stream, options) {
    return {
      state: type,
      audio: stream.hasAudio(),
      video: stream.hasVideo(),
      screen: stream.hasScreen(),
      attributes: stream.getAttributes(),
      metadata: options.metadata,
      muteStream: options.muteStream
    };
  }

  publishErizo(streamInput, options, callback = () => { }) {
    return new Promise((resolve, reject) => {
      const stream = streamInput;
      const constraints = this.createSdpConstraints('erizo', stream, options);
      constraints.minVideoBW = options.minVideoBW;
      constraints.scheme = options.scheme;
      constraints.streamType = stream.streamType;
      constraints.profile = stream.profile;
      constraints.mix = options.mix;
      constraints.streamId = stream.getID();
      constraints.simulcast = options.simulcast;
      constraints.videoCodecPreference = options.videoCodecPreference;
      constraints.newModel = true;
      constraints.forceTurn = options.forceTurn;
      constraints.isMuxRtmp = stream.isMuxRtmp;
      constraints.muxRtmpUrl = stream.muxRtmpUrl;
      if (constraints.isMuxRtmp) {
        constraints.mix = false;
      }
      constraints.mixOption = stream.mixOption;

      this.publishingStreams.add(stream.getID(), { stream, options });
      const msg = `Publish signalling is about to be sent. constraints: ${JSON.stringify(constraints)}`;
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_PUBLISH, streamId: stream.getID() });
      this.socket.sendMessage('publish', constraints, (result) => {
        callback(result.msg.id);
        resolve(stream);
      }, (error) => {
        const msg = `Error when publishing the stream: ${JSON.stringify(error)}`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_PUBLISH_RESULT });
        callback(undefined, error);
        reject(error);
      });
    });
  }

  subscribeErizo(streamInput, optionsInput, callback = () => { }) {
    return new Promise((resolve, reject) => {
      const stream = streamInput;
      const options = optionsInput;
      options.maxVideoBW = this.spec.maxVideoBW;
      options.audio = (options.audio === undefined) ? true : options.audio;
      options.video = (options.video === undefined) ? true : options.video;
      stream.checkOptions(options);
      const constraint = {
        streamId: stream.getID(),
        audio: options.audio && stream.hasAudio(),
        video: options.video && stream.hasVideo(),
        metadata: options.metadata,
        muteStream: options.muteStream,
        dual: options.dual,
        forceTurn: options.forceTurn
      };

      const msg = `subscribe signalling is about to be sent. constraints: ${JSON.stringify(constraint)}`;
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_SUBSCRIBE, streamId: stream.getID() });
      this.socket.sendMessage('subscribe', constraint, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('stream subscribed', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SUBSCRIBE_RESULT, streamId: stream.getID() });
        // todo: getOverseas
        this.createRemoteStreamErizoConnection(stream, options).then(resolve).catch(reject);
        callback(true);
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('Error subscribing to stream', {
          k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_SUBSCRIBE_RESULT, streamId: stream.getID()
        });
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  clearAll() {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('clear all in room');
    this.state = DISCONNECTED;
    this.clientID = '';
    this.socket.state = this.socket.DISCONNECTED;

    // Remove all streams
    this.remoteStreams.forEach((stream, id) => {
      this.removeStream(stream, 'clearAll');
      this.remoteStreams.remove(id);
      if (stream && !stream.failed) {
        const evt2 = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["StreamEvent"]({ type: 'stream-removed', stream });
        this.dispatchEvent(evt2);
      }
    });
    this.remoteStreams = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_4__["default"])();

    // Close Peer Connections
    this.localStreams.forEach((stream, id) => {
      this.removeStream(stream, 'clearAll');
      this.localStreams.remove(id);
    });
    this.localStreams = Object(_utils_ErizoMap__WEBPACK_IMPORTED_MODULE_4__["default"])();

    if (this.mixRtpStream) {
      this.removeStream(this.mixRtpStream, 'clearAll');
    }

    // Close socket
    try {
      this.socket.disconnect();
    } catch (error) {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('Socket already disconnected');
    }
  }

  pubSubStatsLog() {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].pubSubStatsLog(this.localStreams, this.remoteStreams);
  }

  // 以下对外接口
  connect(options = {}) {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('start room connect', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CALL_CONNECT_API });
    return new Promise((resolve, reject) => {
      const token = _utils_Base64__WEBPACK_IMPORTED_MODULE_5__["default"].decodeBase64(this.spec.token);
      const Token = JSON.parse(token);

      // 1- Connect to Erizo-Controller
      if (this.state !== DISCONNECTED) {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('room already connected');
        const evt = { type: 'room-already-connected', streams: [] };
        return resolve(evt);
      }
      this.state = CONNECTING;
      const optionsInput = options;
      optionsInput.version = _common_Definition__WEBPACK_IMPORTED_MODULE_6__["Version"].version;
      optionsInput.pf = _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].pf;
      optionsInput.mode = this.mode;
      this.socket.connect(Token, optionsInput, (response) => {
        let stream;
        const streamList = [];
        const streams = response.streams || [];
        const roomId = response.id;
        this.iceServers = response.iceServers;
        this.state = CONNECTED;
        this.spec.defaultVideoBW = response.defaultVideoBW;
        this.spec.maxVideoBW = response.maxVideoBW;
        this.localuser = response.user;
        this.clientID = response.clientId;

        // 2- Retrieve list of streams
        const streamIndices = Object.keys(streams);
        for (let index = 0; index < streamIndices.length; index += 1) {
          const arg = streams[streamIndices[index]];
          stream = new _Stream__WEBPACK_IMPORTED_MODULE_3__["default"](this.Connection, {
            streamID: arg.id,
            local: false,
            audio: arg.audio,
            video: arg.video,
            screen: arg.screen,
            simulcast: arg.simulcast,
            attributes: arg.attributes,
            user: arg.user,
            streamType: arg.streamType,
            initMuted: arg.muteStream
          });
          streamList.push(stream);
          this.remoteStreams.add(arg.id, stream);
        }

        // 3 - Update RoomID
        this.roomID = roomId;
        // 自定义上报字段，业务端传入otherOption
        const upLogOptions ={
          cid: this.clientID,
          uid: this.localuser.id,
          aid: this.roomID,
          url: this.spec.upLogUrl,
          biz_role: this.spec.otherOption ? (this.spec.otherOption.biz_role || '') : this.spec.biz_role,
          biz_id: this.spec.otherOption ? (this.spec.otherOption.biz_id || '') : this.spec.biz_id,
          biz_des01: this.spec.otherOption ? (this.spec.otherOption.biz_des01 || ''):this.spec.biz_des01,
          bu: this.spec.bu,
          vid: this.spec.vid,
          app_id: this.spec.app_id ? this.spec.app_id : 0,
          sd: Token.token.host
        };
        // socket.log.init(upLogOptions);
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].init(upLogOptions, this.spec.otherOption);
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].reportVersion();
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info(`room connect success, roomID: ${this.roomID}, uid: ${this.localuser.id}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CONNECT_SERVER });
        const evt = { type: 'room-connected', streams: streamList, mixRtpStream: this.mixRtpStream };
        resolve(evt);
      }, (error) => {
        // TODO upload connection Signalling Failure Log
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`room connect failed, error: ${JSON.stringify(error)}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CONNECT_SERVER });
        this.state = DISCONNECTED;
        const evt = { type: 'room-error', message: error };
        reject(evt);
      });
    });
  }

  disconnect() {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('call disconnect api.', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CALL_DISCONNECT_API });
    this.state = DISCONNECTING;
    // 1- Disconnect from room
    const evt = { type: 'room-disconnected', message: 'expected-disconnection' };
    const disconnectEvt = new _utils_Events__WEBPACK_IMPORTED_MODULE_1__["RoomEvent"](evt);
    this.dispatchEvent(disconnectEvt);
    /**
     * Todo
     * 应该在执行完CleanAll以后再返回，
     * 但是由于派发room-disconnected事件后会执行CleanAll，
     * 不派发事件无法向下兼容，为了避免重复暂时不写。
     * 待后期各个产品线全接入PaaS的SDK后，移除事件派发可添加CleanAll调用。
     */
    return new Promise((resolve) => resolve(evt));
  }

  publish(streamInput, optionsInput = {}, callback = () => { }) {
    const msg = `call publish api, options: ${JSON.stringify(optionsInput)}`;
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CALL_PUBLISH_API, streamId: streamInput.getID() });
    return new Promise((resolve, reject) => {
      // hint: this.localuser.permissions is empty before 2021.04, so need compatible
      if (this.localuser === undefined || (!this.localuser.permissions[_common_Definition__WEBPACK_IMPORTED_MODULE_6__["Permission"].PUBLISH] && this.localuser.role !== 'administrator')) {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('no permission to publish', { streamId: streamInput.getID() })
        reject('no permission');
        return;
      }

      const stream = streamInput;
      stream.user = this.localuser;
      const options = optionsInput;
      if (stream.bandWidth !== undefined) {
        options.minVideoBW = stream.bandWidth[0];
        options.maxVideoBW = stream.bandWidth[1];
      }
      options.maxVideoBW = options.maxVideoBW || this.spec.defaultVideoBW;
      options.maxVideoBW = options.maxVideoBW > this.spec.maxVideoBW ? this.spec.maxVideoBW : options.maxVideoBW;
      options.startVideoBW = options.maxVideoBW;
      options.hardMinVideoBW = options.minVideoBW;
      options.simulcast = stream.simulcast;
      options.videoCodecPreference = stream.videoCodecPreference;
      options.forceTurn = options.forceTurn || this.forceTurn;
      options.muteStream = {
        audio: stream.audioMuted,
        video: stream.videoMuted
      };

      console.error('stream------', stream);
      window.roomStream = stream
      // 1- If the stream is not local or it is a failed stream we do nothing.
      if (stream && stream.local && !this.localStreams.has(stream.getID()) && stream.hasMedia()) {
        // 2- Publish Media Stream to Erizo-Controller
        this.publishErizo(stream, options, callback).then(resolve).catch(reject);
      } else {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('Trying to publish invalid stream', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CALL_PUBLISH_API, streamId: streamInput.getID() });
        callback(undefined, 'Invalid Stream');
        reject('Invalid Stream');
      }
    });
  }

  unpublish(streamInput, callback = () => { }, reason = 'default') {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('call unpublish api.', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CALL_UNPUBLISH_API, streamId: streamInput.getID() });
    return new Promise((resolve, reject) => {
      // hint: this.localuser.permissions is empty before 2021.04, so need compatible
      // if (this.localuser === undefined || (!this.localuser.permissions[Permission.PUBLISH] && this.localuser.role !== 'administrator')) {
      //   log.info('no permission to unpublish', { streamId: streamInput.getID() })
      //   reject('no permission');
      //   return;
      // }

      const stream = streamInput;
      // Unpublish stream from Erizo-Controller
      if (stream && stream.local) {
        // Media stream
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('unpublish signalling is about to be sent', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_UNPUBLISH, streamId: streamInput.getID() });
        this.socket.sendMessage('unpublish', { streamId: stream.getID(), reason }, () => {
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('Stream unpublished.', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].UNPUBLISH_RESULT, streamId: stream.getID() });
          callback(true);
          resolve();
        }, (error) => {
          _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('Error unpublish stream.', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_UNPUBLISH_RESULT, streamId: stream.getID() });
          callback(undefined, error.msg.message);
          reject(error.msg.message);
          return;
        });
        stream.room = undefined;
        if (stream.hasMedia()) {
          this.removeStream(stream, 'unpublish');
          delete stream.failed;
        }
        this.localStreams.remove(stream.getID());
        stream.isPublished = false;
        stream.removeEventListener('internal-set-attributes', this.updateAttributesFromStreamEvent);
      } else {
        const error = 'Cannot unpublish, stream does not exist or is not local';
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(error, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CALL_UNPUBLISH_API, streamId: stream.getID() });
        callback(undefined, error);
        reject(error);
      }
    });
  }

  subscribe(streamInput, optionsInput = {}, callback = () => { }) {
    const msg = `call subscribe api, options: ${JSON.stringify(optionsInput)}`;
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CALL_SUBSCRIBE_API, streamId: streamInput.getID() });
    return new Promise((resolve, reject) => {
      const stream = streamInput;
      const options = optionsInput;

      if (!stream || stream.local || !stream.hasMedia()) {
        let error = 'error on subscribe';
        if (!stream) {
          error = 'cannot subscribe to invalid stream';
        } else if (stream.local) {
          error = 'cannot subscribe to local stream';
        } else if (!stream.hasMedia()) {
          error = 'cannot subscribe to stream which has no audio and video';
        }
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(error, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CALL_SUBSCRIBE_API, streamId: stream.getID() });
        callback(undefined, error);
        reject(error);
        return;
      }

      // 1- Subscribe to Stream
      if (!stream.hasVideo() && !stream.hasScreen()) {
        options.video = false;
      }
      if (!stream.hasAudio()) {
        options.audio = false;
      }
      const muteAudio = options.muteStream && options.muteStream.audio !== undefined ? options.muteStream.audio : false;
      const muteVideo = options.muteStream && options.muteStream.video !== undefined ? options.muteStream.video : false;
      options.muteStream = {
        audio: stream.audioMuted || muteAudio,
        video: stream.videoMuted || muteVideo
      };
      options.forceTurn = options.forceTurn || this.forceTurn;
      delete stream.failed;
      this.subscribeErizo(stream, options, callback).then(resolve).catch(reject);
    });
  }

  // It unsubscribes from the stream, removing the HTML element.
  unsubscribe(streamInput, callback = () => { }, reason = 'default') {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('Call unsubscribe api.', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CALL_UNSUBSCRIBE_API, streamId: streamInput.getID() });
    return new Promise((resolve, reject) => {
      const stream = streamInput;
      if (!stream || stream.local) {
        let error = 'error on unsubscribe';
        callback(undefined, error);
        reject(error);
        return;
      }
      // Unsubscribe from stream
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('UNsubscribe signalling is about to be sent', {
        k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_UNSUBSCRIBE, streamId: stream.getID()
      });
      this.socket.sendMessage('unsubscribe', { streamId: stream.getID(), reason }, () => {
        this.removeStream(stream, 'unsubscribe');
        delete stream.failed;
        callback(true);
        resolve();
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error('Error unsubscribe stream.', {
          k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_UNSUBSCRIBE_RESULT, streamId: stream.getID()
        });
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  sendControlMessage(stream, type, action) {
    if (stream && stream.getID()) {
      const msg = { type: 'control', action };
      this.socket.sendMessage('signaling_message', { streamId: stream.getID(), msg });
    }
  }

  deleteUser(userName, callback = () => { }) {
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('deleteUser', { userId: userName }, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  setClientRole(role) {
    return new Promise((resolve, reject) => {
      if (["administrator", "presenter", "viewer", "viewerWithData"].indexOf(role) < 0) {
        reject('invalid param');
        return;
      }

      this.socket.sendMessage('setClientRole', { role }, (response) => {
        this.localuser.role = response.msg.user.role;
        this.localuser.permissions = response.msg.user.permissions;
        resolve('success');
      }, (error) => {
        reject(error.msg.message);
      });
    });
  }

  configRoomBroadCast(configStr, mode = 'mix') {
    return new Promise((resolve, reject) => {
      let configJson;
      // todo: check config
      try {
        configJson = JSON.parse(configStr);
      } catch (e) {
        configJson = configStr;
      }
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('call configRoomBroadCast api: ', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_CONFIGROOMBROADCAST, Collapsed: configJson });
      this.socket.sendMessage('ConfigRoomBroadCast', { config: configStr, mode }, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('configRoomBroadCast success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].CONFIGROOMBROADCAST_RESULT });
        resolve('success');
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`configRoomBroadCast failed: ${error.code}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_CONFIGROOMBROADCAST_RESULT });
        reject(error.code);
      });
    });
  }

  setMixLayoutMode(config, mode = 'mix') {
    return new Promise((resolve, reject) => {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug(`call setMixLayoutMode api: ${config}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_SETMIXLAYOUTMODE});
      this.socket.sendMessage('SetMixLayoutMode', { config, mode }, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('setMixLayoutMode success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SETMIXLAYOUTMODE_RESULT });
        resolve('success');
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`setMixLayoutMode failed: ${error.code}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_SETMIXLAYOUTMODE_RESULT });
        reject(error.code);
      });
    });
  }

  setMixAdaptiveLayoutMode(config, mode = 'mix') {
    return new Promise((resolve, reject) => {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug(`call setMixAdaptiveLayoutMode api: ${config}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_SETMIXADAPTIVELAYOUTMODE});
      this.socket.sendMessage('setMixAdaptiveLayoutMode', { config: config, mode }, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('setMixAdaptiveLayoutMode success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SETMIXADAPTIVELAYOUTMODE_RESULT });
        resolve('success');
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`setMixAdaptiveLayoutMode failed: ${error.code}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_SETMIXADAPTIVELAYOUTMODE_RESULT });
        reject(error.code);
      });
    });
  }

  setStreamMixOption(config, mode = 'mix') {
    return new Promise((resolve, reject) => {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug('call setStreamMixOption api: ', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_SETSTREAMMIXOPTION, Collapsed: config });
      this.socket.sendMessage('setStreamMixOption', { config: config, mode }, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('setStreamMixOption success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SETSTREAMMIXOPTION_RESULT });
        resolve('success');
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`setStreamMixOption failed: ${error.code}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_SETSTREAMMIXOPTION_RESULT });
        reject(error.code);
      });
    });
  }

  setMixLayoutMainScreen(config, mode = 'mix') {
    return new Promise((resolve, reject) => {
      _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug(`call setMixLayoutMainScreen api: ${config}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_SETMIXLAYOUTMAINSCREEN });
      this.socket.sendMessage('SetMixLayoutMainScreen', { config, mode }, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('setMixLayoutMainScreen success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SETMIXLAYOUTMAINSCREEN_RESULT });
        resolve('success');
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`setMixLayoutMainScreen failed: ${error.code}`, {
          k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_SETMIXLAYOUTMAINSCREEN_RESULT
        });
        reject(error.code);
      });
    });
  }

  startRoomBroadCast(mode = 'mix') {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug('Call startRoomBroadCast api', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_STARTROOMBROADCAST });
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('StartRoomBroadCast', { mode }, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('startRoomBroadCast success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].STARTROOMBROADCAST_RESULT });
        resolve('success');
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`startRoomBroadCast failed: ${error.code}`, {
          k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_STARTROOMBROADCAST_RESULT
        });
        reject(error.code);
      });
    });
  }

  stopRoomBroadCast(mode = 'mix') {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug('Call stopRoomBroadCast api', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SEND_STOPROOMBROADCAST });
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('StopRoomBroadCast', { mode }, () => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].info('stopRoomBroadCast success', { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].STOPROOMBROADCAST_RESULT });
        resolve('success');
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`stopRoomBroadCast failed: ${error.code}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].ER_STOPROOMBROADCAST_RESULT });
        reject(error.code);
      });
    });
  }

  getRoomStats(callback = () => { }) {
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('getRoomStats', {}, (result) => {
        callback(result);
        resolve(result);
      }, (error) => {
        _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].error(`getRoomStats failed: ${error.code}`);
        callback('failed', error.code);
        reject(error.code);
      });
    });
  }

  getStreamStats(stream, callback = () => { }) {
    if (!this.socket) {
      return 'Error getting stats - no socket';
    }
    if (!stream) {
      return 'Error getting stats - no stream';
    }

    this.socket.sendMessage('getStreamStats', { streamId: stream.getID() }, (result) => {
      if (result) {
        callback(result.msg.result);
      }
    });
    return undefined;
  }

  getStreamsByAttribute(name, value) {
    const streams = [];

    this.remoteStreams.forEach((stream) => {
      if (stream.getAttributes() !== undefined && stream.getAttributes()[name] === value) {
        streams.push(stream);
      }
    });

    return streams;
  }

  getConnectionState() {
    return stateDiscribeList[this.state];
  }

  getStats(streamId) {
    let stream;
    if (this.localStreams.has(streamId)) {
      stream = this.localStreams.get(streamId);
    } else if (this.remoteStreams.has(streamId)) {
      stream = this.remoteStreams.get(streamId);
    } else {
      return undefined;
    }
    return stream.getStats();
  }

  getUploadPacketLossRate() {
    const arr = [];
    this.localStreams.forEach((localStream) => {
      arr.push(localStream.getPacketLossRate());
    });
    if (arr.length < 1) {
      return 0;
    }
    return Math.max(...arr);
  }

  getDownloadPacketLossRate() {
    const arr = [];
    this.remoteStreams.forEach((remoteStream) => {
      arr.push(remoteStream.getPacketLossRate());
    });
    if (arr.length < 1) {
      return 0;
    }
    return Math.max(...arr);
  }

  customSignalling(signalling, callback) {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug('customSignalling');
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('customSignalling', signalling, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  setMaxUserCount(maxNum, callback = () => { }) {
    _common_uplog__WEBPACK_IMPORTED_MODULE_7__["default"].debug(`setMaxUserCount: ${maxNum}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_6__["K"].SET_MAX_USERCOUNT });
    return new Promise((resolve, reject) => {
      if (Object.prototype.toString.call(maxNum) !== '[object Number]') {
        callback(undefined, 'The number must be an Number');
        reject('The number must be an Number');
        return;
      }

      if (maxNum < 0) {
        callback(undefined, 'The number must be an positive integer');
        reject('The number must be an positive integer');
        return;
      }

      this.socket.sendMessage('setMaxUserCount', maxNum, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  setTurn(forceTurn_ = true) {
    this.forceTurn = forceTurn_;
  }

  //以下暂不使用/暂不维护/暂不删除
  /*
  modifyUserPermissions(userId, role, callback = () => { }) {
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('modifyUserPermissions', { id: userId, role }, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  socketOnUsersPermissionChanged(event) {
    let arg = event.args[0];
    log.info(`usersPermissionChanged ${arg}`);
    arg.forEach((user) => {
      this.localStreams.forEach((localStream) => {
        const localUser = localStream.getUser();
        if (localUser.id === user.id) {
          localUser.role = user.role;
          localUser.permission = user.permission;
          localStream.setUser(localUser);
        }
      });

      this.remoteStreams.forEach((remoteStream) => {
        const remoteUser = remoteStream.getUser();
        if (remoteUser.id === user.id) {
          remoteUser.role = user.role;
          remoteUser.permission = user.permission;
          remoteStream.setUser(remoteUser);
        }
      });

      if (this.localuser.id === user.id) {
        this.localuser.role = user.role;
        this.localuser.permission = user.permission;
      }
    });

    const evt2 = new StreamEvent({ type: 'users-permission-changed', msg: arg });
    this.dispatchEvent(evt2);
  }

  subscribeData(streamInput, options, callback = () => { }) {
    return new Promise((resolve, reject) => {
      const stream = streamInput;
      this.socket.sendMessage('subscribe',
        {
          streamId: stream.getID(),
          data: options.data,
          metadata: options.metadata
        }, () => {
          log.info('Stream subscribed');
          const evt = new StreamEvent({ type: 'stream-subscribed', stream });
          this.dispatchEvent(evt);
          callback(true);
          resolve();
        }, (error) => {
          log.error(`Error subscribing to stream: ${error.msg.message}`);
          callback(undefined, error.msg.message);
          reject(error.msg.message);
        });
    });
  }

  getOverseas(streamInput, isSub) {
    const stream = streamInput;
    const opt = { streamId: streamInput.getID(), isSub };
    this.socket.sendMessage('getOverseas', opt, (response) => {
      if (response && response.msg && typeof response.msg.result === 'boolean') {
        stream.overseas = response.msg.result;
      } else {
        stream.overseas = false;
      }
    }, () => {
      stream.overseas = false;
    });
  }

  sendMuteStream(streamId, config, callback = () => { }) {
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('sendMuteStream', { id: streamId, config }, (result, error) => {
        if (result === null) {
          callback(undefined, error);
          reject(error);
          return;
        }
        callback(result);
        resolve(result);
      });
    });
  }

  streamapply(userName, callback = () => { }) {
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('StreamApply', { userId: userName }, () => {
        callback(true);
        resolve();
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  consent(userName, callback = () => { }) {
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('StreamConsent', { userId: userName }, () => {
        callback(true);
        resolve();
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  reject(userName, callback = () => { }) {
    return new Promise((resolve, reject) => {
      this.socket.sendMessage('StreamReject', { userId: userName }, () => {
        callback(true);
        resolve();
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }
  socketOnBandwidthAlert(event) {
    let arg = event.args[0];
    if (arg.streamID) {
      const stream = this.remoteStreams.get(arg.streamID);
      if (stream && !stream.failed) {
        const evt = new StreamEvent({
          type: 'bandwidth-alert',
          stream,
          msg: arg.message,
          bandwidth: arg.bandwidth
        });
        stream.dispatchEvent(evt);
      }
    }
  }
  socketOnAddMixRtpStream(event) {
    let arg = event.args[0];
    log.info('New mix-rtp stream add', { streamId: arg.id });
    if (this.mixRtpStream) {
      return;
    }
    this.mixRtpStream = new Stream(this.Connection, {
      streamID: arg.id,
      local: false,
      audio: arg.audio,
      video: arg.video,
      data: arg.data,
      screen: arg.screen,
      attributes: arg.attributes,
      user: arg.user,
      simulcast: arg.simulcast,
      streamType: arg.streamType,
      initMuted: arg.muteStream
    });
    this.mixRtpStream.room = this;
    const evt = new StreamEvent({ type: 'mixRtpStream-added', stream: this.mixRtpStream });
    this.dispatchEvent(evt);
  }

  socketOnRemoveMixRtpStream(event) {
    let arg = event.args[0];
    log.info('Server Remove mix-rtp stream', { streamId: arg.id });
    if (this.mixRtpStream) {
      const stream = this.mixRtpStream;
      stream.stopMonitorStats();
      log.stopPlayMessageLog(stream);
      log.playMessageLog(stream); // last log for this stream
      this.removeStream(stream);
      this.mixRtpStream = null;
      const evt = new StreamEvent({ type: 'mixRtpStream-removed', stream });
      this.dispatchEvent(evt);
    }
  }

  socketOnStreamApply(event) {
    let arg = event.args[0];
    log.info(`sokect on StreamApply: ${arg}`);
    const username = arg.id;
    const evt2 = new StreamEvent({ type: 'room-stream-apply', msg: username });
    this.dispatchEvent(evt2);
  }

  socketOnStreamConsent(event) {
    let arg = event.args[0];
    const username = arg.id;
    const evt2 = new StreamEvent({ type: 'room-stream-consent', msg: username });
    this.dispatchEvent(evt2);
  }

  socketOnStreamReject(event) {
    let arg = event.args[0];
    const username = arg.id;
    const evt2 = new StreamEvent({ type: 'room-stream-reject', msg: username });
    this.dispatchEvent(evt2);
  }

  setBlackList(options, callback = () => { }) {
    log.info(`黑名单设置: ${options}`);
    return new Promise((resolve, reject) => {
      if (options.enable === undefined || Object.prototype.toString.call(options.enable) !== '[object Boolean]') {
        callback(undefined, 'enable must be a Boolean');
        reject('enable must be a Boolean');
        return;
      }
      if (options.users !== undefined && Object.prototype.toString.call(options.users) !== '[object Array]') {
        callback(undefined, 'users must be an Array');
        reject('users must be an Array');
        return;
      }
      this.socket.sendMessage('setBlackList', options, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  addBlackList(users, callback = () => { }) {
    log.info(`添加黑名单成员: ${users}`);
    return new Promise((resolve, reject) => {
      if (Object.prototype.toString.call(users) !== '[object Array]') {
        callback(undefined, 'users must be an Array');
        reject('users must be an Array');
        return;
      }
      this.socket.sendMessage('addBlackList', users, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  delBlackList(users, callback = () => { }) {
    log.info(`删除黑名单成员: ${users}`);
    return new Promise((resolve, reject) => {
      if (Object.prototype.toString.call(users) !== '[object Array]') {
        callback(undefined, 'users must be an Array');
        reject('users must be an Array');
        return;
      }
      this.socket.sendMessage('delBlackList', users, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  getBlackList(callback = () => { }) {
    log.info('获取黑名单');
    return new Promise((resolve, reject) => {
      const options = {};
      this.socket.sendMessage('getBlackList', options, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  setWhiteList(options, callback = () => { }) {
    log.info(`白名单设置: ${options}`);
    return new Promise((resolve, reject) => {
      if (options.enable === undefined || Object.prototype.toString.call(options.enable) !== '[object Boolean]') {
        callback(undefined, 'enable must be a Boolean');
        reject('enable must be a Boolean');
        return;
      }
      if (options.users !== undefined && Object.prototype.toString.call(options.users) !== '[object Array]') {
        callback(undefined, 'users must be an Array');
        reject('users must be an Array');
        return;
      }
      this.socket.sendMessage('setWhiteList', options, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  addWhiteList(users, callback = () => { }) {
    log.info(`添加白名单成员: ${users}`);
    return new Promise((resolve, reject) => {
      if (Object.prototype.toString.call(users) !== '[object Array]') {
        callback(undefined, 'users must be an Array');
        reject('users must be an Array');
        return;
      }
      this.socket.sendMessage('addWhiteList', users, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  delWhiteList(users, callback = () => { }) {
    log.info(`删除白名单成员: ${users}`);
    return new Promise((resolve, reject) => {
      if (Object.prototype.toString.call(users) !== '[object Array]') {
        callback(undefined, 'users must be an Array');
        reject('users must be an Array');
        return;
      }
      this.socket.sendMessage('delWhiteList', users, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }

  getWhiteList(callback = () => { }) {
    log.info('获取白名单');
    return new Promise((resolve, reject) => {
      const options = {};
      this.socket.sendMessage('getWhiteList', options, () => {
        callback('success');
        resolve('success');
      }, (error) => {
        callback(undefined, error.msg.message);
        reject(error.msg.message);
      });
    });
  }
  */

  //以下废弃
  /*
  addStreamToMix(stream, callback = () => { }) {
    return new Promise((resolve, reject) => {
      if (!stream || !stream.getID() || stream.getID() === 'local') {
        callback(false, 'stream not found');
        reject('stream not found');
        return;
      }

      this.socket.sendMessage('addStreamToMix', { streamId: stream.getID() }, () => {
        callback(true);
        resolve();
      }, (error) => {
        callback(false, error);
        reject(error);
      });
    });
  }

  delStreamFromMix(stream) {
    if (!stream || !stream.getID() || stream.getID() === 'local') {
      log.error('Delete Stream From Mix error, stream not found.');
      return;
    }

    this.socket.sendMessage('delStreamFromMix', { streamId: stream.getID() });
  }

  publishExternal(streamInput, options, callback = () => { }) {
    const stream = streamInput;
    let type;
    let arg;
    if (stream.url) {
      type = 'file';
      arg = stream.url;
    } else {
      type = 'recording';
      arg = stream.recording;
    }
    log.info(`Checking publish options for: ${stream.getID()}`);
    stream.checkOptions(options);
    const constraints = this.createSdpConstraints(type, stream, options);
    constraints.sdp = arg;
    this.socket.sendMessage('publish', constraints, (result) => {
      this.populateStreamFunctions(result.msg.streamId, stream, undefined, callback);
    }, (error) => {
      const msg = `Error when publishing the stream: ${error}`;
      log.error(msg, { k: K.ER_PUBLISH_RESULT });
      // Unauth -1052488119
      // Network -5
      callback(undefined, error);
    });
  }
  */
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./rtcbase/src/modules/Stream.js":
/*!***************************************!*\
  !*** ./rtcbase/src/modules/Stream.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stream; });
/* harmony import */ var _utils_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Events */ "./rtcbase/src/utils/Events.js");
/* harmony import */ var _common_Connection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Connection */ "./rtcbase/src/common/Connection.js");
/* harmony import */ var _views_VideoPlayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../views/VideoPlayer */ "./rtcbase/src/views/VideoPlayer.js");
/* harmony import */ var _views_AudioPlayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../views/AudioPlayer */ "./rtcbase/src/views/AudioPlayer.js");
/* harmony import */ var _common_Definition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/Definition */ "./rtcbase/src/common/Definition.js");
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");
/* harmony import */ var _lib_beauty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/beauty */ "./rtcbase/src/lib/beauty.js");
/* global window document */









// from https://www.w3.org/TR/webrtc-stats/#rtctatstype-*
const streamStatsModel = {
  inboundRtp: [],
  outboundRtp: [],
  candidatePair: [],
  mediaSource: [],
  remoteInboundRtp: [],
  track: [],
  transport: [],
  calculated: {
    t_kbitrateReceived: 0,
    t_kbitrateSent: 0,
    v_kbitrateReceived: 0,
    v_kbitrateSent: 0,
    v_frameRate: 0,
    a_kbitrateReceived: 0,
    a_kbitrateSent: 0,
    v_pkt_sent: 0,
    v_nack_sent: 0,
    v_pkt_recv: 0,
    v_nack_recv: 0
  }
};

class Stream extends _utils_Events__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {
  constructor(altConnection, specInput) {
    super();

    this.beautyRtc = new _lib_beauty__WEBPACK_IMPORTED_MODULE_6__["default"]()
    this.spec = specInput;
    this.beautyOption = this.spec.beautyOption;
    this.cloneStream = null;
    this.stream = this.spec.stream;
    this.room = null;
    this.showing = false;
    this.local = false;
    this.mirror = (this.spec.mirror === true); // default false
    this.facingMode = this.spec.facingMode;
    if (["user", "environment", "left", "right"].indexOf(this.facingMode) < 0) {
      this.facingMode = undefined;
    }

    // 是否需要音视频数据
    this.videoTrack = this.spec.videoTrack;
    this.audioTrack = this.spec.audioTrack;
    this.video = !!(this.spec.video);
    this.audio = !!(this.spec.audio);

    // 桌面共享，默认开启麦克风选项
    this.screen = this.spec.screen;
    this.screenSpeaker = this.spec.screenSpeaker !== undefined ? this.spec.screenSpeaker : true;
    this.hasInsertedStream = this.spec.hasInsertedStream;
    this.insertedStream = this.spec.insertedStream;
    this.profile = undefined;
    this.audioProfle = undefined;
    this.videoSize = this.spec.videoSize;
    this.videoFrameRate = this.spec.videoFrameRate;
    this.extensionId = this.spec.extensionId;
    this.desktopStreamId = this.spec.desktopStreamId;
    this.streamId = this.spec.streamID || `${Math.floor(100000000000000000 + (Math.random() * 900000000000000000))}`;
    this.user = this.spec.user || { id: this.streamId, role: 'administrator', permissions: {}, attributes: '' };
    this.audioMuted = false;
    this.videoMuted = false;
    this.initMuted = this.spec.initMuted;
    this.videoCodecPreference = this.spec.videoCodecPreference;
    this.simulcast = this.spec.simulcast ? { numSpatialLayers: 2 } : undefined;
    if (this.videoCodecPreference && this.videoCodecPreference.toLowerCase() === 'h264') {
      this.simulcast = undefined;
    }
    this.isMuxRtmp = false;
    this.muxRtmpUrl = undefined;
    this.mixOption = this.spec.mixOption;
    this.overseas = false;
    this.Connection = altConnection === undefined ? _common_Connection__WEBPACK_IMPORTED_MODULE_1__["default"] : altConnection;
    this.audioOutputDeviceId = undefined;
    this.startMonitorTime = Date.now();
    this.streamStats = JSON.parse(JSON.stringify(streamStatsModel));
    // 0: pure audio, 1: only video, 2: AV, 3: screen, 4: rtp-mix
    this.streamType = this.spec.streamType !== undefined ? this.spec.streamType : 2; //允许外部指定streamType
    this.monitorStatsHandle = null;
    this.packetLossRate = 0; // 0 - 100
    // for up log
    this.upLogTime = Date.now();
    this.videoStunkCheckCount = 0;
    if (this.spec.local === undefined || this.spec.local === true) {
      this.local = true;
    }
    this.isPublished = !this.local;
    if (this.videoSize !== undefined &&
      (!(this.videoSize instanceof Array) ||
        this.videoSize.length !== 4)) {
      throw Error('Invalid Video Size');
    }

    // profile
    if (this.spec.profile !== undefined) {
      this.setVideoParams(this.spec.profile);
    }
    if (this.local) {
      const msg = `create localStream, opt: ${JSON.stringify(this.spec)}`;
      _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].CONSTRUCT_LOCAL_STREAM, streamId: this.getID() });
    }

    console.warn('this.beautyOption--------', this.beautyOption, );
    // 美颜
    
    this.cloneVideo = this.beautyRtc.createVideo(this.getID())
    this.cloneStream = new MediaStream()
    window.cloneStream = this.cloneStream
    if(this.beautyOption && this.beautyOption.flag){
      this.startBeauty(this.beautyOption)
    }
  }

  async setBeautyLevel(level){
    return Promise.resolve(this.beautyRtc.setLevel(level))
  }

 async startBeauty(opt){
    this.setBeautyLevel(opt.level)
    console.warn(`this.spec.profile......`, this.spec.profile);
    let complexOpt = {
      source: this.cloneVideo, // 虚拟Video
      canvasOpt: {
        width: this.spec.profile && this.spec.profile.videoSize[2] || '1280',
        height: this.spec.profile && this.spec.profile.videoSize[3] || '720',
        id: this.getID()
      }
    }
    await this.beautyRtc.init(complexOpt)
    await this.addBeautyClone(this.stream)
    this.beautyRtc.startDraw()
  }

  async replaceBeauty(){
    _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`start beauty, replace videoTracks`);
    let canvasStream = this.beautyRtc.getCanvasCap()
    let newTrack = canvasStream.getVideoTracks()[0]

    if (!newTrack || !this.stream ) {
      return Promise.reject('parameters not invalid');
    }
    
    var oldTrack = this.cloneStream.getVideoTracks()[0];
    if (!oldTrack) {
      return Promise.reject('current MediaStreamTrack not found')
    }

    await this.replaceStream(newTrack, oldTrack)
  }

  replaceStream(newTrack, oldTrack){
    return new Promise((resolve, reject)=>{
      const kind = newTrack.kind;
      //如本地流已发布，则先操作RTCRtpSender
      if (this.pc) {
        const sender = this.pc.peerConnection.getSenders().find(function(t) { return t.track.kind == kind; });
        if (sender) {
          sender.replaceTrack(newTrack).then(() => {
            this.cloneStream.addTrack(newTrack);
            this.cloneStream.removeTrack(oldTrack);
            resolve('success');
          }).catch((err) => {
            reject('beauty: RTCRtpSender replaceTrack failed');
            _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`beauty: sender replaceTrack failed: ${err}`);
          });
        }else{
          resolve('success');
        }
      } else {
        this.cloneStream.addTrack(newTrack);
        this.cloneStream.removeTrack(oldTrack);
        resolve('success');
      }
    })
  }

  // 添加视频源等...
  async addBeautyClone(stream){
    this.cloneStream.addTrack(stream.getVideoTracks()[0])
    this.cloneVideo.srcObject = stream
    this.cloneVideo.play()
  }

  async destroyBeauty(){
    let newTrack = this.stream.getVideoTracks()[0]
    let oldTrack = this.cloneStream.getVideoTracks()[0]
    await this.replaceStream(newTrack, oldTrack)
    await this.beautyRtc.destory()
  }
  
  // set rtp->rtmp parameters
  setMuxRtmp(muxRtmpUrl_) {
    if (!this.local) {
      return false;
    }
    if (muxRtmpUrl_.indexOf('rtmp://') === 0) {
      this.videoCodecPreference = _common_Definition__WEBPACK_IMPORTED_MODULE_4__["Definition"].CODECS_H264;
      this.simulcast = undefined;
      this.isMuxRtmp = true;
      this.muxRtmpUrl = muxRtmpUrl_;
      return true;
    } else {
      return false;
    }
  }
  clearMuxRtmp() {
    if (!this.local) {
      return false;
    }
    this.isMuxRtmp = false;
    this.muxRtmpUrl = '';
    return true;
  }

  setMixOption(option) {
    if (!this.local || this.isPublished) {
      return false;
    }
    this.mixOption = option;
    return true;
  }

  setVideoParams(profile) {
    this.profile = profile;
    this.videoSize = profile.videoSize;
    this.videoFrameRate = profile.videoFrameRate;
    this.bandWidth = profile.bitRate;
    this.ratio = profile.ratio;
  }

  switchVideoProfile(profile) {
    return new Promise((resolve, reject) => {
      const track = this.getVideoTrack();
      if (track !== undefined) {
        const videoSize = profile.videoSize;
        const videoFrameRate = profile.videoFrameRate;
        const ratio = profile.ratio;
        const bitRate = profile.bitRate;
        const videoOpt = {};
        if (videoSize !== undefined) {
          videoOpt.width = { ideal: videoSize[2] };
          videoOpt.height = { ideal: videoSize[3] };
        }
        if (videoFrameRate !== undefined) {
          if (this.Connection.getBrowser() !== 'safari') {
            videoOpt.frameRate = { ideal: videoFrameRate[1] };
          } else {
            videoOpt.frameRate = { max: this.hasScreen() ? videoFrameRate[1] : 30 };
          }
        }
        this.videoOpt = videoOpt;
        track.applyConstraints(videoOpt).then(() => {
          _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].info(`switchVideoProfile and applyConstraints success: ${JSON.stringify(videoOpt)}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].SWITCH_VIDEO_PROFILE, streamId: this.getID() });
          this.updateConfiguration({ maxVideoBW: bitRate[1] });
          resolve();
        }).catch(e => {
          _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`switchVideoProfile and applyConstraints error: ${e}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].ER_SWITCH_VIDEO_PROFILE, streamId: this.getID() });
          reject();
        });
      } else {
        reject();
      }
    });
  }

  setVideoProfile(profile) {
    if (profile !== undefined && this.local && this.hasVideo()) {
      _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`setVideoProfile profile: ${JSON.stringify(profile)}`, { streamId: this.getID() });
      if (this.stream) {
        this.switchVideoProfile(profile).then(() => {
          this.setVideoParams(profile);
        }).catch(() => {
          //
        });
      } else {
        this.setVideoParams(profile);
      }
    }
  }

  setScreenProfile(profile) {
    if (profile !== undefined && this.local && this.hasScreen() && this.stream === undefined) {
      this.setVideoParams(profile);
    }
  }

  setAudioProfile(profile) {
    if (profile !== undefined && this.local) {
      this.audioProfle = profile;
    }
  }

  refreshUpLogTime() {
    this.upLogTime = Date.now();
  }

  initStreamType() {
    this.video = (this.stream.getVideoTracks().length > 0);
    this.audio = (this.stream.getAudioTracks().length > 0);
    if (this.spec.streamType === undefined) {
      if (this.hasScreen()) {
        this.streamType = 3;
      } else if (this.hasVideo() && this.hasAudio()) {
        this.streamType = 2;
      } else if (this.hasVideo()) {
        this.streamType = 1;
      } else if (this.hasAudio()) {
        this.streamType = 0;
      }
    }
  }

  // Initializes the stream and tries to retrieve a stream from local video and audio
  // We need to call this method before we can publish it in the room.
  init() {
    return new Promise((resolve, reject) => {
      // two way for screenShare:
      // 1. {video: false, screen: true}
      // 2. {video: {deviceId: 'desktopScreen'}}
      let videoOpt = this.spec.video;
      if (this.spec.screen === true) {
        this.screen = true;
        this.simulcast = undefined;
      } else if (videoOpt && videoOpt.deviceId === 'desktopScreen') {
        delete videoOpt.deviceId;
        this.screen = true;
        this.simulcast = undefined;
      } else {
        this.screen = false;
      }
      // check parameters
      if ((!this.spec.audio && !this.spec.video && !this.screen) 
            && (!this.audioTrack && !this.videoTrack) && (!this.hasInsertedStream || !this.insertedStream)) {
        return reject({ type: 'localStream-parameters-error', msg: 'localStream-parameters-error' });
      }

      if (videoOpt) {
        videoOpt = videoOpt === true ? {} : videoOpt;
        if (videoOpt.deviceId) {
          videoOpt.deviceId = { exact: videoOpt.deviceId };
        }
        videoOpt.facingMode = this.facingMode; //{ exact: this.facingMode }
        if (this.videoSize !== undefined) {
          videoOpt.width = { ideal: this.videoSize[2] };
          videoOpt.height = { ideal: this.videoSize[3] };
        }
        if (this.videoFrameRate !== undefined) {
          /**
           * safari 13 问题:
           * 使用外接摄像头bug，不能配置帧率，或帧率只能限制在5fps.
           * 为了向后兼容，选择不配置ideal帧率，让浏览器默认
           * 最终参考：https://docs.agora.io/cn/Interactive%20Broadcast/API%20Reference/web/interfaces/agorartc.stream.html#setvideoprofile
           */
          if (this.Connection.getBrowser() !== 'safari') {
            videoOpt.frameRate = { ideal: this.videoFrameRate[1] };
          } else {
            videoOpt.frameRate = { max: this.hasScreen() ? this.videoFrameRate[1] : 30 };
          }
        }
        if(this.spec.profile){
          videoOpt.aspectRatio = { ideal: this.spec.profile.ratio }
        }
      }
      this.videoOpt = videoOpt;
      if (this.spec.audio && this.spec.audio.deviceId) {
        this.spec.audio.deviceId = { exact: this.spec.audio.deviceId };
      }

      const opt = {
        streamId: this.getID(),
        video: videoOpt,
        audio: this.spec.audio,
        screen: this.screen,
        screenSpeaker: this.screenSpeaker,
        hasInsertedStream: this.hasInsertedStream,
        insertedStream: this.insertedStream,
        extensionId: this.extensionId,
        desktopStreamId: this.desktopStreamId,
        audioTrack: this.audioTrack,
        videoTrack: this.videoTrack,
      };

      this.Connection.GetUserMedia(opt, (stream) => {
        // if insertedStream, get resolution from MediaStreamTrack and decide bandwidth
        if (this.hasInsertedStream && this.insertedStream) {
          const vTrack = this.insertedStream.getVideoTracks()[0];
          this.setProfile(vTrack)
        }
        // if audioTrack/videoTrack，replace track
        if (this.audioTrack) {
          const oldAudioTrack = stream.getAudioTracks()[0];
          if (oldAudioTrack) { stream.removeTrack(oldAudioTrack) };
          stream.addTrack(this.audioTrack);
        }
        if (this.videoTrack) {
          const oldVideoTrack = stream.getVideoTracks()[0];
          if (!this.spec.profile) this.setProfile(this.videoTrack);
          if (oldVideoTrack) { stream.removeTrack(oldVideoTrack) };
          stream.addTrack(this.videoTrack);
        }

        console.error('this.cloneVideo----', this.cloneVideo);

        
        if(this.cloneVideo) {
          this.addBeautyClone(stream)
        }
        // process mediaStream
        this.stream = stream;
        window.onlyStream = stream
        this.initStreamType();
        const msg = `init localStream success, opt: ${JSON.stringify(opt)}`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].INIT_LOCAL_STREAM, streamId: this.getID() });
        this.stream.getTracks().forEach((trackInput) => {
          const track = trackInput;
          track.onended = () => {
            this.stream.getTracks().forEach((secondTrackInput) => {
              secondTrackInput.onended = null;
            });
            _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`getTracks stream-ended. streamId: ${this.getID()}, track kind: ${track.kind}`,
              { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].ER_STREAM_ENDED, streamId: this.getID() });
            const streamEvent = new _utils_Events__WEBPACK_IMPORTED_MODULE_0__["StreamEvent"]({
              type: 'stream-ended',
              stream: this,
              msg: track.kind
            });
            this.dispatchEvent(streamEvent);
          };
        });
        return resolve();
      }, (error) => {
        const msg = `init localStream failed. opt: ${
          JSON.stringify(opt)}, name: ${error}, code: ${error.code}, message: ${error.message}`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].ER_INIT_STREAM, streamId: this.getID() });
        return reject({ type: 'localStream-getusermedia-error', msg: error });
      });
    });
  }

  // 针对VideoTrack设置 profile
  setProfile(vTrack){
    if (vTrack) {
      const vWidth = vTrack.getSettings().width;
      const vHeight = vTrack.getSettings().height;
      const vResolution = vWidth * vHeight;
      if (vResolution >= 1280*720) {
        this.bandWidth = [600, 1200];
      } else if (vResolution >= 848*480) {
        this.bandWidth = [400, 800];
      } else {
        this.bandWidth = [260, 520];
      }
    }
  }

  setVideoContentHint(hint) {
    if (!this.local) return;
    if (['motion', 'detail', 'text'].indexOf(hint) < 0) return;
    const track = this.getVideoTrack();
    if (track) {
      track.contentHint = hint;
    }
  }

  // Public functions
  getID() {
    return this.streamId;
  }

  setID(id) {
    this.streamId = id;
  }

  getUser() {
    let user;
    if (this.local && !this.user) {
      user = 'local';
    } else {
      user = this.user;
    }
    return user;
  }

  getUserId() {
    let userId;
    if (this.local && !this.user) {
      userId = 'local';
    } else {
      userId = this.user.id;
    }
    return userId;
  }

  setUser(user) {
    this.user = user;
  }

  getAudioProfile() {
    return this.audioProfle;
  }

  getVideoSettings() {
    let vsettings;
    let videotrack;
    if (this.stream) {
      videotrack = (this.stream.getVideoTracks())[0];
      vsettings = videotrack.getSettings();
    } else {
      vsettings = 'default';
    }
    return vsettings;
  }

  getVideoTrack() {
    let videoTrack;
    if (this.stream) {
      videoTrack = (this.stream.getVideoTracks())[0];
    }
    return videoTrack;
  }

  getAudioTrack() {
    let audioTrack;
    if (this.stream) {
      audioTrack = (this.stream.getAudioTracks())[0];
    }
    return audioTrack;
  }

  // Get attributes of this stream.
  getAttributes() {
    return this.spec.attributes;
  }

  // Changes the attributes of this stream in the room.
  setAttributes(attrs) {
    if (this.local) {
      this.dispatchEvent(new _utils_Events__WEBPACK_IMPORTED_MODULE_0__["StreamEvent"]({ type: 'internal-set-attributes', stream: this, attrs }));
      return;
    }
    _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error('Failed to set attributes data. This Stream object has not been published.');
  }

  updateLocalAttributes(attrs) {
    this.spec.attributes = attrs;
  }

  // Indicates if the stream has audio activated
  hasAudio() {
    return this.audio;
  }

  // Indicates if the stream has video activated
  hasVideo() {
    return this.video;
  }

  // Indicates if the stream has screen activated
  hasScreen() {
    return this.screen;
  }

  hasMedia() {
    return this.audio || this.video || this.screen;
  }

  isPlaying() {
    return this.showing;
  }
  
  // 此play 属于新建Video和Audio元素
  play(elementID, optionsInput = {}) {
    _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`start play stream ${this.getID()}, option: ${JSON.stringify(optionsInput)}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].PLAY_STREAM, streamId: this.getID() });
    const options = optionsInput || {};
    this.elementID = elementID;
    let player;
    if (this.hasVideo() || this.hasScreen()) {
      // Draw on HTML
      if (elementID !== undefined) {
        player = new _views_VideoPlayer__WEBPACK_IMPORTED_MODULE_2__["default"]({
          id: this.getID(),
          stream: this,
          elementID,
          options
        });
        if (this.audioOutputDeviceId !== undefined) {
          player.setAudioOutput(this.audioOutputDeviceId, () => { }, () => { });
        }
        this.player = player;
        this.showing = true;

        const avElement = this.player !== undefined ? (this.player.video || this.player.audio) : undefined;
        if (this.volume !== undefined) {
          avElement.volume = parseFloat(this.volume / 100).toFixed(2);
        }
      }
    } else if (this.hasAudio()) {
      player = new _views_AudioPlayer__WEBPACK_IMPORTED_MODULE_3__["default"]({
        id: this.getID(),
        stream: this,
        elementID,
        options
      });
      if (this.audioOutputDeviceId !== undefined) {
        player.setAudioOutput(this.audioOutputDeviceId, () => { }, () => { });
      }
      this.player = player;
      this.showing = true;
    }
    const streamEvent = new _utils_Events__WEBPACK_IMPORTED_MODULE_0__["StreamEvent"]({
      type: 'stream-play-abord',
      stream: this
    })
    // play是对已有的Video/Audio 元素进行播放
    player.play().then(()=>{}).catch(error=>{
      if (error.name === 'NotAllowedError'){
        this.dispatchEvent(streamEvent);
      }
    })
  }

  stop() {
    _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`stop play stream ${this.getID()}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].STOP_STREAM, streamId: this.getID() });
    if (this.showing) {
      if (this.player !== undefined) {
        this.player.destroy();
        this.showing = false;
      }
    }
  }

  close(reason = 'default') {
    if (this.local) {
      _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`close local stream ${this.getID()}, reason: ${reason}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].CLOSE_LOCAL_STREAM, streamId: this.getID() });
      this.stop();
      if (this.stream !== undefined) {
        this.stream.getTracks().forEach((trackInput) => {
          const track = trackInput;
          track.onended = null;
          track.stop();
        });
      }
      this.stream = undefined;
      if (this.room) {
        this.room.unpublish(this, () => { }, `${reason}-close`);
      }
    } else {
      this.stop();
    }
  }

  setAudioOutput(deviceId, success = () => { }, failure = () => { }) {
    return new Promise((resolve, reject) => {
      this.audioOutputDeviceId = deviceId;
      if (this.showing) {
        if (!this.player || (!this.player.media)) {
          const msg = 'stream player video/audio element not found';
          _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`${msg}`);
          failure(msg);
          reject(msg);
          return;
        }
        this.player.setAudioOutput(this.audioOutputDeviceId, success, failure).then(resolve).catch(reject);
      } else {
        success();
        resolve();
      }
    });
  }

  setAudioVolume(volume) {
    this.volume = volume;
    if (this.showing) {
    const avElement = this.player !== undefined ? this.player.media : undefined;
    if (avElement !== undefined) {
        const v = Math.max(0, Math.min(100, parseInt(volume, 10)));
        avElement.volume = parseFloat(v / 100).toFixed(2);
      }
    }
  }

  getAudioVolume(){
   return this.player.getAudioVolume()
  }
 
  replaceTrack(type, newTrack) {
    return new Promise((resolve, reject) => {
      // 检查传入参数，并检查当前是否可执行
      if ((type !== 'video' && type !== 'audio') || !newTrack ||
          !this.stream || !this.local || this.hasScreen() || this.hasInsertedStream) {
        reject('parameters not invalid');
        return;
      }

      //检查新track类型
      const kind = newTrack.kind;
      if (kind !== 'video' && kind !== 'audio') {
        reject('MediaStreamTrack not invalid')
      }
      //检查原流中是否有替换对象track
      var oldTrack = undefined;
      if (type === 'video') {
        oldTrack = this.stream.getVideoTracks()[0];
        if (!oldTrack) {
          reject('current MediaStreamTrack not found')
        }
      }
      if (type === 'audio') {
        oldTrack = this.stream.getAudioTracks()[0];
        if (!oldTrack) {
          reject('current MediaStreamTrack not found')
        }
      }

      //如本地流已发布，则先操作RTCRtpSender
      if (this.pc) {
        const sender = this.pc.peerConnection.getSenders().find(function(t) { return t.track.kind == kind; });
        if (sender) {
          sender.replaceTrack(newTrack).then(() => {
            oldTrack.onended = null;
            oldTrack.stop();
            this.stream.removeTrack(oldTrack);
            this.stream.addTrack(newTrack);
            resolve('stream replaceTrack success');
          }).catch((err) => {
            reject('RTCRtpSender replaceTrack failed');
            _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`sender replaceTrack failed: ${err}`);
          });
        }else{
          resolve('stream replaceTrack success');
        }
      } else {
        oldTrack.onended = null;
        oldTrack.stop();
        this.stream.removeTrack(oldTrack);
        this.stream.addTrack(newTrack);
        resolve('stream replaceTrack success');
      }
    });
  }

  switchDevice(type, deviceId, _streamObj) {
    return new Promise((resolve, reject) => {
      if ((type !== 'video' && type !== 'audio') ||
          (!this.hasVideo() && type === 'video') ||
          (!this.hasAudio() && type === 'audio') ||
          !this.stream || !this.local || this.hasScreen() || this.hasInsertedStream) {
        reject('parameters not invalid');
        return;
      }
      const opt = {
        streamId: this.getID(),
        screen: false
      };
      if (type === 'video') {
        const videoOpt = JSON.parse(JSON.stringify(this.videoOpt));
        videoOpt.deviceId = { exact: deviceId };
        opt.video = videoOpt;
        opt.audio = false;
      } else if (type === 'audio') {
        opt.video = false;
        opt.audio = { deviceId: { exact: deviceId } };
      }
      
      try {
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`switch device , type: ${type} , deviceId:${deviceId}`, { streamId: this.getID() });
        this.Connection.GetUserMedia(opt, (_stream) => {
          if (type === 'video') {
            const newVideoTrack = _stream.getVideoTracks()[0];
            this.replaceTrack('video', newVideoTrack).then(()=>{
              if(_streamObj && _streamObj.videoMuted) this.muteVideo()
              if(_streamObj && _streamObj.profile) this.setVideoProfile(_streamObj.profile)
            }).catch((err) => { _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(err); reject(err); });
          } else if (type === 'audio') {
            const newAudioTrack = _stream.getAudioTracks()[0];
            this.replaceTrack('audio', newAudioTrack).then(()=>{
              if(_streamObj && _streamObj.audioMuted) this.muteAudio()
              if(_streamObj && _streamObj.profile) this.setVideoProfile(_streamObj.profile)
            }).catch((err) => { _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(err); reject(err); });
          }
          resolve('switchDevice success');
        }, err => {
          _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`switchDevice error: ${err}`);
          reject(err);
        });
      } catch (error) {
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`switchDevice exception: ${error}`);
        reject(error);
      }
    });
  }

  getFrame(w = 0, h = 0) {
    if (this.player === undefined || this.stream === undefined) {
      return null;
    }
    const video = this.player.video;
    const style = document.defaultView.getComputedStyle(video);
    let width = w;
    let height = h;
    if (w === 0) {
      width = parseInt(style.getPropertyValue('width'), 10);
    }
    if (h === 0) {
      height = parseInt(style.getPropertyValue('height'), 10);
    }
    const canvas = document.createElement('canvas');

    canvas.id = 'testing';
    canvas.width = width;
    canvas.height = height;
    canvas.setAttribute('style', 'display: none');
    const context = canvas.getContext('2d');

    context.drawImage(video, 0, 0, width, height);
    return canvas;
  }

  getVideoFrameURL(format, encoderOptions = 0.92, width = 0, height = 0) {
    const canvas = this.getFrame(width, height);
    if (canvas === null) {
      return null;
    }
    if (format) {
      return canvas.toDataURL(format, encoderOptions);
    }
    return canvas.toDataURL();
  }

  checkOptions(configInput, isUpdate) {
    const config = configInput;
    // TODO: Check for any incompatible options
    if (isUpdate === true) { // We are updating the stream
      if (config.audio || config.screen) {
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error('Cannot update type of subscription');
        config.audio = undefined;
        config.screen = undefined;
      }
    } else if (this.local === false) { // check what we can subscribe to
      if (config.video === true && this.hasVideo() === false) {
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error('Trying to subscribe to video when there is no ' +
          'video, won\'t subscribe to video');
        config.video = false;
      }
      if (config.audio === true && this.hasAudio() === false) {
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error('Trying to subscribe to audio when there is no ' +
          'audio, won\'t subscribe to audio');
        config.audio = false;
      }
    }
  }

  muteStream(callback = () => { }) {
    if (this.stream) {
      for (let index = 0; index < this.stream.getVideoTracks().length; index += 1) {
        const track = this.stream.getVideoTracks()[index];
        track.enabled = !this.videoMuted;
      }
      for (let index = 0; index < this.stream.getAudioTracks().length; index += 1) {
        const track = this.stream.getAudioTracks()[index];
        track.enabled = !this.audioMuted;
      }
    }
    const config = { muteStream: { audio: this.audioMuted, video: this.videoMuted }, localStream: this.local };
    this.checkOptions(config, true);
    if (this.pc) {
      this.pc.updateSpec(config, callback);
    }
  }

  muteAudio(isMuted = true, callback = () => { }) {
    if (typeof isMuted === 'boolean') {
      _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`set audio mute: ${isMuted}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].CALL_MUTE_AUDIO, streamId: this.getID() });
      this.audioMuted = isMuted;
      this.muteStream(callback);
    }
  }

  muteVideo(isMuted = true, callback = () => { }) {
    if (typeof isMuted === 'boolean') {
      _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].debug(`set video mute: ${isMuted}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].CALL_MUTE_VIDEO, streamId: this.getID() });
      this.videoMuted = isMuted;
      this.muteStream(callback);
    }
  }

  unmuteAudio(callback = () => { }) {
    this.muteAudio(false, callback);
  }

  unmuteVideo(callback = () => { }) {
    this.muteVideo(false, callback);
  }

  getMutedStatus() {
    return { audioMuted: this.audioMuted, videoMuted: this.videoMuted };
  }

  _setStaticQualityLayer(spatialLayer, temporalLayer, callback = () => { }) {
    const config = { qualityLayer: { spatialLayer, temporalLayer } };
    this.checkOptions(config, true);
    this.pc.updateSpec(config, callback);
  }

  _setDynamicQualityLayer(callback) {
    const config = { qualityLayer: { spatialLayer: -1, temporalLayer: -1 } };
    this.checkOptions(config, true);
    this.pc.updateSpec(config, callback);
  }

  setRemoteVideoStreamType(type, callback) {
    if (type === 0 || type === 1) {
      const config = { dual: type };
      this.checkOptions(config, true);
      this.pc.updateSpec(config, callback);
    } else {
      _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error('setRemoteVideoStreamType type must 0 or 1');
      callback('error');
    }
  }

  updateConfiguration(config, callback = () => { }) {
    if (config === undefined) { return; }
    if (this.pc) {
      this.checkOptions(config, true);
      this.pc.updateSpec(config, callback);
    } else {
      callback('This stream has no peerConnection attached, ignoring');
    }
  }

  checkVideoStunk(currentFramerate) {
    if (this.local && this.isPublished && (this.hasVideo() || this.hasScreen()) && !this.videoMuted) {
      if (currentFramerate === 0) {
        this.videoStunkCheckCount += 1;
        if (this.videoStunkCheckCount >= 15) {
          this.videoStunkCheckCount = 0;
          _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].error(`checkVideoStunk stream-stunk in 15s, streamId: ${this.getID()}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_4__["K"].ER_STREAM_STUNK, streamId: this.getID() });
          const streamEvent = new _utils_Events__WEBPACK_IMPORTED_MODULE_0__["StreamEvent"]({
            type: 'stream-stunk',
            stream: this,
            msg: 'video stunk in 15s'
          });
          this.dispatchEvent(streamEvent);
          // todo   关闭美颜的定时
        }
      } else {
        this.videoStunkCheckCount = 0;
      }
    }
  }

  setPacketLossRate() {
    if (this.local) {
      const vPktSent = this.streamStats.calculated.v_pkt_sent;
      const vNackSent = this.streamStats.calculated.v_nack_sent;
      const percent = vPktSent > 0 ? vNackSent / vPktSent : 0;
      this.packetLossRate = Math.min((percent * 100).toFixed(2), 100);
    } else {
      const vPktRecv = this.streamStats.calculated.v_pkt_recv;
      const vNackRecv = this.streamStats.calculated.v_nack_recv;
      const percent = vPktRecv > 0 ? vNackRecv / (vNackRecv + vPktRecv) : 0;
      this.packetLossRate = Math.min((percent * 100).toFixed(2), 100);
    }
  }

  reportICEStatus(k) {
    this.pc.getStats((stats) => {
      if (stats) {
        let localCandidateId = '';
        let remoteCandidateId = '';
        let ICEStatus = { 'local': {}, 'remote': {} };
        stats.forEach((stat) => {
          if (stat.type === 'candidate-pair' || stat.type === 'candidatepair') {
            if (stat.state === 'succeeded' && stat.nominated === true) {
              localCandidateId = stat.localCandidateId;
              remoteCandidateId = stat.remoteCandidateId;
            }
          }
        });
        if (localCandidateId.length > 0 && remoteCandidateId.length > 0) {
          stats.forEach((stat) => {
            if (stat.type === 'local-candidate' && stat.id === localCandidateId) {
              ICEStatus['local']['cType'] = stat.candidateType;
              ICEStatus['local']['ip'] = stat.ip;
              ICEStatus['local']['port'] = stat.port;
              ICEStatus['local']['nType'] = stat.networkType;
            } else if (stat.type === 'remote-candidate' && stat.id === remoteCandidateId) {
              ICEStatus['remote']['cType'] = stat.candidateType;
              ICEStatus['remote']['ip'] = stat.ip;
              ICEStatus['remote']['port'] = stat.port;
            }
          });
        }
        _common_uplog__WEBPACK_IMPORTED_MODULE_5__["default"].info(`${JSON.stringify(ICEStatus)}`, { k, streamId: this.getID() });
      }
    });
  }

  monitorStats() {
    this.pc.getStats((stats) => {
      if (stats) {
        const nowStats = JSON.parse(JSON.stringify(streamStatsModel));
        stats.forEach((stat) => {
          if (stat.type === 'inbound-rtp' || stat.type === 'inboundrtp') {
            nowStats.inboundRtp.push(stat);
            if (this.streamStats.inboundRtp.length > 0) {
              if (stat.mediaType === 'audio') {
                const newbytesReceived = stat.bytesReceived;
                let oldbytesReceived = 0;
                this.streamStats.inboundRtp.forEach((streamStat) => {
                  if (streamStat.kind === 'audio') {
                    oldbytesReceived = streamStat.bytesReceived;
                  }
                });
                nowStats.calculated.a_kbitrateReceived += parseInt((newbytesReceived - oldbytesReceived) / 1000, 10) * 8;
              } else if (stat.mediaType === 'video') {
                const newbytesReceived = stat.bytesReceived;
                let oldbytesReceived = 0;
                this.streamStats.inboundRtp.forEach((streamStat) => {
                  if (streamStat.kind === 'video') {
                    oldbytesReceived = streamStat.bytesReceived;
                  }
                });
                nowStats.calculated.v_kbitrateReceived += parseInt((newbytesReceived - oldbytesReceived) / 1000, 10) * 8;

                const newPacketsRecv = stat.packetsReceived;
                let oldPacketsRecv = 0;
                const newNackCount = stat.nackCount;
                let oldNackCount = 0;
                this.streamStats.inboundRtp.forEach((streamStat) => {
                  if (streamStat.kind === 'video') {
                    oldPacketsRecv = streamStat.packetsReceived;
                    oldNackCount = streamStat.nackCount;
                  }
                });
                nowStats.calculated.v_pkt_recv = newPacketsRecv - oldPacketsRecv;
                nowStats.calculated.v_nack_recv = newNackCount - oldNackCount;
                this.setPacketLossRate();
              }
            }
          } else if (stat.type === 'outbound-rtp' || stat.type === 'outboundrtp') {
            nowStats.outboundRtp.push(stat);
            if (this.streamStats.outboundRtp.length > 0) {
              if (stat.mediaType === 'audio') {
                const anewbytesSent = stat.bytesSent;
                let aoldbytesSent = 0;
                this.streamStats.outboundRtp.forEach((streamStat) => {
                  if (streamStat.kind === 'audio') {
                    aoldbytesSent = streamStat.bytesSent;
                  }
                });
                nowStats.calculated.a_kbitrateSent += parseInt((anewbytesSent - aoldbytesSent) / 1000, 10) * 8;
              } else if (stat.mediaType === 'video') {
                const newbytesSent = stat.bytesSent;
                let oldbytesSent = 0;
                const newPacketsSent = stat.packetsSent;
                let oldPacketsSent = 0;
                const newNackCount = stat.nackCount;
                let oldNackCount = 0;
                this.streamStats.outboundRtp.forEach((streamStat) => {
                  if (streamStat.kind === 'video' && streamStat.ssrc === stat.ssrc) {
                    oldbytesSent = streamStat.bytesSent;
                    oldPacketsSent = streamStat.packetsSent;
                    oldNackCount = streamStat.nackCount;
                    nowStats.calculated.v_kbitrateSent += parseInt((newbytesSent - oldbytesSent) / 1000, 10) * 8;
                    nowStats.calculated.v_pkt_sent += newPacketsSent - oldPacketsSent;
                    nowStats.calculated.v_nack_sent += newNackCount - oldNackCount;
                  }
                });
                this.setPacketLossRate();
              }
            }
          } else if (stat.type === 'track') {
            nowStats.track.push(stat);
            if (this.streamStats.track.length > 0) {
              if (stat.kind === 'video') {
                const newFramesSent = this.local ? stat.framesSent : stat.framesReceived;
                let oldFramesSent = 0;
                this.streamStats.track.forEach((streamStat) => {
                  if (streamStat.kind === 'video') {
                    oldFramesSent = this.local ? streamStat.framesSent : streamStat.framesReceived;
                  }
                });
                const framerate = newFramesSent - oldFramesSent;
                nowStats.calculated.v_frameRate = framerate;
                this.checkVideoStunk(framerate);
              }
            }
          } else if (stat.type === 'transport') {
            nowStats.transport.push(stat);
            if (this.streamStats.transport.length > 0) {
              const oldbytesReceived = this.streamStats.transport[0].bytesReceived;
              const oldbytesSent = this.streamStats.transport[0].bytesSent;
              const oldtimestamp = this.streamStats.transport[0].timestamp;
              const newbytesReceived = stat.bytesReceived;
              const newbytesSent = stat.bytesSent;
              const newtimestamp = stat.timestamp;
              const durationMS = newtimestamp - oldtimestamp;
              const kbitrateReceived = parseInt((newbytesReceived - oldbytesReceived) / durationMS, 10) * 8;
              const kbitrateSent = parseInt((newbytesSent - oldbytesSent) / durationMS, 10) * 8;
              nowStats.calculated.t_kbitrateReceived = kbitrateReceived;
              nowStats.calculated.t_kbitrateSent = kbitrateSent;
            }
          } else if (stat.type === 'candidate-pair' || stat.type === 'candidatepair') {
            if ((stat.state === 'succeeded' || stat.state === 'in-progress') &&
                 stat.nominated === true && stat.writable === true) {
              nowStats.candidatePair.push(stat);
            }
          } else if (stat.type === 'remote-inbound-rtp') {
            nowStats.remoteInboundRtp.push(stat);
          } else if (stat.type === 'media-source') {
            nowStats.mediaSource.push(stat);
          }
        });
        this.streamStats = nowStats;
      }
    });
  }

  startMonitorStats() {
    if (this.monitorStatsHandle === null) {
      this.startMonitorTime = Date.now();
      this.monitorStatsHandle = global.setInterval(this.monitorStats.bind(this), 1000);
    }
  }

  stopMonitorStats() {
    if (this.monitorStatsHandle) {
      global.clearInterval(this.monitorStatsHandle);
      this.monitorStatsHandle = undefined;
    }
  }

  getStats() {
    return this.streamStats;
  }

  getPacketLossRate() {
    return this.packetLossRate;
  }

  published() {
    return this.isPublished;
  }

  getAudioLevel() {
    let level = 0;
    if (this.local) {
      this.streamStats.mediaSource.forEach((stat) => {
        if (stat.kind === 'audio' && stat.audioLevel !== undefined) {
          level = stat.audioLevel;
        }
      });
    } else {
      this.streamStats.track.forEach((stat) => {
        if (stat.kind === 'audio' && stat.audioLevel !== undefined) {
          level = stat.audioLevel;
        }
      });
    }
    return level;
  }
  
  playTag(){
    return this.player.play()
  }

  pauseTag(){
    return this.player.pause()
  }

  setFullscreen(opt){
    return new Promise((resolve, reject)=>{
      this.player.setFullscreen(opt).then(()=>{resolve()}).catch(err=>{reject(err)})
    })
  }
  exitFullscreen(opt){
    return new Promise((resolve, reject)=>{
      this.player.exitFullscreen(opt).then(()=>{resolve()}).catch(err=>{reject(err)})
    })
  }

  /*
  // Sends data through this stream.
  sendData(msg) {
    if (this.local && this.hasData()) {
      this.dispatchEvent(new StreamEvent({ type: 'internal-send-data', stream: this, msg }));
      return;
    }
    log.error('Failed to send data. This Stream object has not been published.');
  }

  seekFileTime(currentSeekTime, callback = () => { }) {
    if (this.room && this.room.p2p) {
      log.error('seekFileTime is not implemented in p2p streams');
      callback('error');
      return;
    }
    if (typeof (currentSeekTime) === 'number') {
      const config = { seekTime: currentSeekTime };
      if (this.pc) {
        this.pc.updateSpec(config, callback);
      } else {
        log.error('seekFileTime not a pc');
        callback('error');
      }
    } else {
      log.error('seekFileTime currentSeekTime must number');
      callback('error');
    }
  }

  fileCtrl(cmd, callback = () => { }) {
    if (this.room && this.room.p2p) {
      log.error('fileCtl is not implemented in p2p streams');
      callback('error');
      return;
    }
    if (cmd === 'play' || cmd === 'pause') {
      const config = { fileCtl: cmd };
      if (this.pc) {
        this.pc.updateSpec(config, callback);
      } else {
        log.error('fileCtrl not a pc');
        callback('error');
      }
    } else {
      log.error('fileCtrl cmd must "play or pause"');
      callback('error');
    }
  }

  controlHandler(handlersInput, publisherSideInput, enable) {
    let publisherSide = publisherSideInput;
    let handlers = handlersInput;
    if (publisherSide !== true) {
      publisherSide = false;
    }

    handlers = (typeof handlers === 'string') ? [handlers] : handlers;
    handlers = (handlers instanceof Array) ? handlers : [];

    if (handlers.length > 0) {
      this.room.sendControlMessage(this, 'control', {
        name: 'controlhandlers',
        enable,
        publisherSide,
        handlers
      });
    }
  }

  disableHandlers(handlers, publisherSide) {
    this.controlHandler(handlers, publisherSide, false);
  }

  enableHandlers(handlers, publisherSide) {
    this.controlHandler(handlers, publisherSide, true);
  };

  getVideoFrame() {
    const canvas = this.getFrame();
    if (canvas === null) {
      return null;
    }
    return canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
  }
  */
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./rtcbase/src/modules/Tools.js":
/*!**************************************!*\
  !*** ./rtcbase/src/modules/Tools.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tools; });
/* harmony import */ var _common_Connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Connection */ "./rtcbase/src/common/Connection.js");
/* harmony import */ var _common_Definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Definition */ "./rtcbase/src/common/Definition.js");
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");
/* harmony import */ var _utils_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Logger */ "./rtcbase/src/utils/Logger.js");
/* global navigator */





class Tools {
  constructor() {
  }

  setLogLevel(level){
    return _utils_Logger__WEBPACK_IMPORTED_MODULE_3__["default"].setLogLevel(level)
  }

  // 开启/关闭日志上报
  setLogUpload(level){
    return _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].setReportFlag(level)
  }

  checkSystemRequirements() {
    var isWebSocketSupported = !!(window.WebSocket);
    var isWebRTCSupported = !!(window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection);
    var isScreenShareSupported = !!(navigator.getDisplayMedia || (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia));
    var isGetUserMediaSupported = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia || (navigator.mediaDevices && navigator.mediaDevices.getUserMedia));
    var isEnumerateDevicesSupported = !!(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);
    var isSDKSupported = isWebRTCSupported && isGetUserMediaSupported && isWebSocketSupported && isEnumerateDevicesSupported;

    var videoElement = document.createElement('video');
    var isVideoCaptureStreamSupported = !!(videoElement.captureStream);
    var canvasElement = document.createElement('canvas');
    var isCanvasCaptureStreamSupported = !!(canvasElement.captureStream);

    return {
      result: isSDKSupported,
      detail: {
        isWebRTCSupported,
        isWebSocketSupported,
        isScreenShareSupported,
        isGetUserMediaSupported,
        isEnumerateDevicesSupported,
        isVideoCaptureStreamSupported,
        isCanvasCaptureStreamSupported,
      }
    }
  }

  isScreenShareSupported() {
    var isScreenShareSupported = !!(navigator.getDisplayMedia || (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia));
    return isScreenShareSupported;
  }

  isMobileDevice() {
    return _common_Connection__WEBPACK_IMPORTED_MODULE_0__["default"].isMobileDevice();
  }

  getBrowserInfo() {
    return _common_Connection__WEBPACK_IMPORTED_MODULE_0__["default"].getBrowserInfo();
  }

  getBrowser() {
    return _common_Connection__WEBPACK_IMPORTED_MODULE_0__["default"].getBrowser();
  }

  getOS() {
    return _common_Connection__WEBPACK_IMPORTED_MODULE_0__["default"].getOS();
  }

  getBrowserDevices(callback = () => {}, error = () => {}) {
    return new Promise((resolve, reject) => {
      _common_Connection__WEBPACK_IMPORTED_MODULE_0__["default"].EnumerateDevices((devices) => {
        const msg = 'Get device list: ';
        _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_1__["K"].REPORT_DEVICES, Collapsed: devices });
        callback(devices);
        resolve(devices);
      }, (err) => {
        const msg = `Get devices error: ${JSON.stringify(err)}`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_1__["K"].ER_GET_DEVICES });
        error(err);
        reject(err);
      });
    });
  }

  hasExtension(callback, extensionId) {
    return new Promise((resolve) => {
      _common_Connection__WEBPACK_IMPORTED_MODULE_0__["default"].getExtensionVersion((version) => {
        if (version) {
          const msg = `Extension version: ${version}`;
          _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_1__["K"].REPORT_PLUGIN_VERSION });
        }
        callback(version);
        resolve(version);
      }, extensionId);
    });
  }

  VideoConstraints(options, callback, scanList = _common_Definition__WEBPACK_IMPORTED_MODULE_1__["QUICKSCAN"]) {
    if (scanList.length === 0) {
      callback([]);
      return;
    }
    const frameRate = options.frameRate || 15;
    const resolutionList = JSON.parse(JSON.stringify(scanList));
    const videoOpt = {};
    const detection = resolutionList.shift();
    videoOpt.width = { exact: detection.width };
    videoOpt.height = { exact: detection.height };
    videoOpt.frameRate = { exact: frameRate };
    videoOpt.deviceId = { exact: options.deviceId };

    const opt = {
      video: videoOpt,
      audio: false,
    };

    navigator.mediaDevices.getUserMedia(opt).then((mediaStream) => {
      if (mediaStream) {
        mediaStream.getTracks().forEach((track) => {
          track.stop();
        });
        resolutionList.unshift(detection);
        callback(resolutionList);
      } else {
        this.VideoConstraints(options, (resolutions) => {
          if (resolutions.length) {
            callback(resolutions);
          } else {
            callback([]);
          }
        }, resolutionList);
      }
    }).catch((error) => {
      if (error && error.name !== 'OverconstrainedError') {
        const msg = `getUserMedia for resolution error: ${error.name}`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].error(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_1__["K"].ER_GET_RESOLUTION_LIST });
      }
      this.VideoConstraints(options, (resolutions) => {
        if (resolutions.length) {
          callback(resolutions);
        } else {
          callback([]);
        }
      }, resolutionList);
    });
  }

  getVideoConstraints(options, callback = () => {}, scanList = _common_Definition__WEBPACK_IMPORTED_MODULE_1__["QUICKSCAN"]) {
    return new Promise((resolve) => {
      const resolutionList = JSON.parse(JSON.stringify(scanList));
      if (options.deviceId === 'desktopScreen') {
        callback([resolutionList.shift()]);
        resolve([resolutionList.shift()]);
        return;
      }
      this.VideoConstraints(options, (resolutions) => {
        if (resolutions.length) {
          const msg = `Get device '${options.deviceId}' resolution list: `;
          _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].info(msg, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_1__["K"].REPORT_RESOLUTION_LIST, Collapsed: resolutions });
        }
        callback(resolutions);
        resolve(resolutions);
      }, scanList);
    });
  }

  getVideoConstraintsV2(options, callback = () => {}, scanList = _common_Definition__WEBPACK_IMPORTED_MODULE_1__["QUICKSCAN_V2"]) {
    return this.getVideoConstraints(options, callback, scanList);
  }
}


/***/ }),

/***/ "./rtcbase/src/utils/Base64.js":
/*!*************************************!*\
  !*** ./rtcbase/src/utils/Base64.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* global unescape */

const Base64 = (() => {
  let base64Str;
  let base64Count;

  const END_OF_INPUT = -1;
  const base64Chars = [
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', '+', '/',
  ];

  const reverseBase64Chars = [];

  for (let i = 0; i < base64Chars.length; i += 1) {
    reverseBase64Chars[base64Chars[i]] = i;
  }

  const setBase64Str = (str) => {
    base64Str = str;
    base64Count = 0;
  };

  const readBase64 = () => {
    if (!base64Str) {
      return END_OF_INPUT;
    }
    if (base64Count >= base64Str.length) {
      return END_OF_INPUT;
    }
    const c = base64Str.charCodeAt(base64Count) & 0xff;  // eslint-disable-line no-bitwise
    base64Count += 1;
    return c;
  };

  const encodeBase64 = (str) => {
    let result;
    let lineCount;
    let done;
    setBase64Str(str);
    result = '';
    const inBuffer = new Array(3);
    lineCount = 0;
    done = false;
    while (!done && (inBuffer[0] = readBase64()) !== END_OF_INPUT) {
      inBuffer[1] = readBase64();
      inBuffer[2] = readBase64();
      // eslint-disable-next-line no-bitwise
      result += (base64Chars[inBuffer[0] >> 2]);
      if (inBuffer[1] !== END_OF_INPUT) {
        // eslint-disable-next-line no-bitwise
        result += (base64Chars[((inBuffer[0] << 4) & 0x30) | (inBuffer[1] >> 4)]);
        if (inBuffer[2] !== END_OF_INPUT) {
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[((inBuffer[1] << 2) & 0x3c) | (inBuffer[2] >> 6)]);
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[inBuffer[2] & 0x3F]);
        } else {
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[((inBuffer[1] << 2) & 0x3c)]);
          result = `${result}=`;
          done = true;
        }
      } else {
        // eslint-disable-next-line no-bitwise
        result += (base64Chars[((inBuffer[0] << 4) & 0x30)]);
        result = `${result}=`;
        result = `${result}=`;
        done = true;
      }
      lineCount += 4;
      if (lineCount >= 76) {
        result = `${result}\n`;
        lineCount = 0;
      }
    }
    return result;
  };

  const readReverseBase64 = () => {
    if (!base64Str) {
      return END_OF_INPUT;
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
      if (base64Count >= base64Str.length) {
        return END_OF_INPUT;
      }
      const nextCharacter = base64Str.charAt(base64Count);
      base64Count += 1;
      if (reverseBase64Chars[nextCharacter]) {
        return reverseBase64Chars[nextCharacter];
      }
      if (nextCharacter === 'A') {
        return 0;
      }
    }
  };

  const ntos = (value) => {
    let n = value.toString(16);
    if (n.length === 1) {
      n = `0${n}`;
    }
    n = `%${n}`;
    return unescape(n);
  };

  const decodeBase64 = (str) => {
    let result;
    let done;
    setBase64Str(str);
    result = '';
    const inBuffer = new Array(4);
    done = false;
    while (!done &&
              (inBuffer[0] = readReverseBase64()) !== END_OF_INPUT &&
              (inBuffer[1] = readReverseBase64()) !== END_OF_INPUT) {
      inBuffer[2] = readReverseBase64();
      inBuffer[3] = readReverseBase64();
      // eslint-disable-next-line no-bitwise,no-mixed-operators
      result += ntos((((inBuffer[0] << 2) & 0xff) | inBuffer[1] >> 4));
      if (inBuffer[2] !== END_OF_INPUT) {
        // eslint-disable-next-line no-bitwise,no-mixed-operators
        result += ntos((((inBuffer[1] << 4) & 0xff) | inBuffer[2] >> 2));
        if (inBuffer[3] !== END_OF_INPUT) {
          // eslint-disable-next-line no-bitwise
          result += ntos((((inBuffer[2] << 6) & 0xff) | inBuffer[3]));
        } else {
          done = true;
        }
      } else {
        done = true;
      }
    }
    return result;
  };

  return {
    encodeBase64,
    decodeBase64,
  };
})();

/* harmony default export */ __webpack_exports__["default"] = (Base64);


/***/ }),

/***/ "./rtcbase/src/utils/ErizoMap.js":
/*!***************************************!*\
  !*** ./rtcbase/src/utils/ErizoMap.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* global unescape */

const ErizoMap = () => {
  const that = {};
  const values = {};

  that.add = (id, value) => {
    values[id] = value;
  };

  that.get = id => values[id];

  that.has = id => values[id] !== undefined;

  that.forEach = (func) => {
    const keys = Object.keys(values);
    for (let index = 0; index < keys.length; index += 1) {
      const key = keys[index];
      const value = values[key];
      func(value, key);
    }
  };

  that.keys = () => Object.keys(values);

  that.remove = (id) => {
    delete values[id];
  };

  return that;
};

/* harmony default export */ __webpack_exports__["default"] = (ErizoMap);


/***/ }),

/***/ "./rtcbase/src/utils/Events.js":
/*!*************************************!*\
  !*** ./rtcbase/src/utils/Events.js ***!
  \*************************************/
/*! exports provided: EventDispatcher, LicodeEvent, RoomEvent, StreamEvent, PublisherEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LicodeEvent", function() { return LicodeEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoomEvent", function() { return RoomEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamEvent", function() { return StreamEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PublisherEvent", function() { return PublisherEvent; });
/* global */

/*
 * Class EventDispatcher provides event handling to sub-classes.
 * It is inherited from Publisher, Room, etc.
 */
class EventDispatcher {
  constructor() {
    this.dispatcher = {
      eventListeners: {},
      // 监听只分发一次
      onceListeners: {}
    };
    this.on = this.addEventListener;
    this.off = this.removeEventListener;
  }

  addEventListener(eventType, listener) {
    if (this.dispatcher.eventListeners[eventType] === undefined) {
      this.dispatcher.eventListeners[eventType] = [];
    }
    this.dispatcher.eventListeners[eventType].push(listener);
  }

  // It removes an available event listener.
  removeEventListener(eventType, listener) {
    if (!this.dispatcher.eventListeners[eventType]) {
      return;
    }
    const index = this.dispatcher.eventListeners[eventType].indexOf(listener);
    if (index !== -1) {
      this.dispatcher.eventListeners[eventType].splice(index, 1);
    }
  }

  addOnceListener(eventType, listener) {
    if (!this.dispatcher.onceListeners[eventType]) {
      this.dispatcher.onceListeners[eventType] = [];
    }

    this.dispatcher.onceListeners[eventType].push(listener);
  }

  removeOnceListener(eventType, listener) {
    if (!this.dispatcher.onceListeners[eventType]) {
      return;
    }
    const index = this.dispatcher.onceListeners[eventType].indexOf(listener);
    if (index !== -1) {
      this.dispatcher.onceListeners[eventType].splice(index, 1);
    }
  }

  // It dispatch a new event to the event listeners, based on the type
  // of event. All events are intended to be LicodeEvents.
  dispatchEvent(event) {
    if (!event || !event.type) {
      throw new Error('Undefined event');
    }
    const listeners = this.dispatcher.eventListeners[event.type] || [];
    for (let i = 0; i < listeners.length; i += 1) {
      listeners[i](event);
    }

    const onceListeners = this.dispatcher.onceListeners[event.type] || [];
    for (let i = 0; i < onceListeners.length; i += 1) {
      onceListeners[i](event);
    }
    delete this.dispatcher.onceListeners[event.type];
  };
}

// **** EVENTS ****

/*
 * Class LicodeEvent represents a generic Event in the library.
 * It handles the type of event, that is important when adding
 * event listeners to EventDispatchers and dispatching new events.
 * A LicodeEvent can be initialized this way:
 * var event = LicodeEvent({type: "room-disconnected"});
 */
class LicodeEvent {
  constructor(spec) {
    this.type = spec.type;
  }
}

/*
 * Class RoomEvent represents an Event that happens in a Room. It is a
 * LicodeEvent.
 * It is usually initialized as:
 * var roomEvent = RoomEvent({type:"room-disconnected", streams:[stream1, stream2]});
 * Event types:
 * 'room-disconnected' - shows that the user has been already disconnected.
 */
class RoomEvent extends LicodeEvent {
  constructor(spec) {
    super(spec);
    this.streams = spec.streams;
    this.message = spec.message;
  }
}

/*
 * Class StreamEvent represents an event related to a stream. It is a LicodeEvent.
 * It is usually initialized this way:
 * var streamEvent = StreamEvent({type:"stream-added", stream:stream1});
 * Event types:
 * 'stream-added' - indicates that there is a new stream available in the room.
 * 'stream-removed' - shows that a previous available stream has been removed from the room.
 */
class StreamEvent extends LicodeEvent {
  constructor(spec) {
    super(spec);
    this.stream = spec.stream;

    this.msg = spec.msg;
    this.bandwidth = spec.bandwidth;
    this.attrs = spec.attrs;
    this.roomInfo = spec.roomInfo;
  }
}

/*
 * Class PublisherEvent represents an event related to a publisher. It is a LicodeEvent.
 * It usually initializes as:
 * var publisherEvent = PublisherEvent({})
 * Event types:
 * 'access-accepted' - indicates that the user has accepted to share his camera and microphone
 */
class PublisherEvent extends LicodeEvent {
  constructor(spec) {
    super(spec);
  }
}




/***/ }),

/***/ "./rtcbase/src/utils/Logger.js":
/*!*************************************!*\
  !*** ./rtcbase/src/utils/Logger.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* global console */

/*
  * API to write logs based on traditional logging mechanisms: debug, info, warning, error
  *1： 全打 info、error、warn、debug
  *2:  只打 info、error、warn
  *3:  只打 warn 和error
  *4： 只打 error
  *5： 全部不打印 none
 */
const Logger = (() => {
  const DEBUG = 1;
  const INFO = 2;
  const WARNING = 3;
  const ERROR = 4;
  const NONE = 5;
  let logPrefix = '';
  let outputFunction;

    // It sets the new log level. We can set it to NONE if we do not want to print logs
  const setLogLevel = (level) => {
    let targetLevel = level;
    if (level > Logger.NONE) {
      targetLevel = Logger.NONE;
    } else if (level < Logger.DEBUG) {
      targetLevel = Logger.DEBUG;
    }
    Logger.logLevel = targetLevel;
  };

  outputFunction = (args) => {
    // eslint-disable-next-line no-console
    console.log(...args);
  };

  const setOutputFunction = (newOutputFunction) => {
    outputFunction = newOutputFunction;
  };

  const setLogPrefix = (newLogPrefix) => {
    logPrefix = newLogPrefix;
  };

    // Generic function to print logs for a given level:
    //  Logger.[DEBUG, INFO, WARNING, ERROR]
  const log = (level, ...args) => {
    let out = logPrefix || 'VHALL-SDK';
    let outColor = '363636'
    if(level < Logger.logLevel){
      return
    }
    if (level === Logger.DEBUG) {
      out = `%c${out} [DEBUG]`;
      outColor = '912CEE'
    } else if (level === Logger.INFO) {
      out = `%c${out} [INFO]`;
      outColor = '1E90FF'
    } else if (level === Logger.WARNING) {
      out = `%c${out} [WARNING]`;
      outColor = 'FFB90F'
    } else if (level === Logger.ERROR) {
      out = `%c${out} [ERROR]`;
      outColor = 'CD3333'
    }
    out = `${out}: `;
    const tempArgs = [out, `color: #${outColor}`].concat(args);
    if (Logger.panel !== undefined) {
      // panel is not used
      let tmp = '';
      for (let idx = 0; idx < tempArgs.length; idx += 1) {
        tmp += tempArgs[idx];
      }
      Logger.panel.value = `${Logger.panel.value}\n${tmp}`;
    } else {
      outputFunction.apply(Logger, [tempArgs]);
    }
  };

  const debug = (...args) => {
    Logger.log(Logger.DEBUG, ...args);
  };

  const info = (...args) => {
    Logger.log(Logger.INFO, ...args);
  };

  const warning = (...args) => {
    Logger.log(Logger.WARNING, ...args);
  };

  const error = (...args) => {
    Logger.log(Logger.ERROR, ...args);
  };

  return {
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    NONE,
    logLevel:1,
    setLogLevel,
    setOutputFunction,
    setLogPrefix,
    log,
    debug,
    info,
    warning,
    error,
  };
})();

/* harmony default export */ __webpack_exports__["default"] = (Logger);


/***/ }),

/***/ "./rtcbase/src/utils/SdpHelpers.js":
/*!*****************************************!*\
  !*** ./rtcbase/src/utils/SdpHelpers.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const SdpHelpers = {};

SdpHelpers.addSim = (spatialLayers) => {
  let line = 'a=ssrc-group:SIM';
  spatialLayers.forEach((spatialLayerId) => {
    line += ` ${spatialLayerId}`;
  });
  return `${line}\r\n`;
};

SdpHelpers.addGroup = (spatialLayerId, spatialLayerIdRtx) =>
  `a=ssrc-group:FID ${spatialLayerId} ${spatialLayerIdRtx}\r\n`;

SdpHelpers.addSpatialLayer = (cname, msid, mslabel,
  label, spatialLayerId, spatialLayerIdRtx) =>
  `a=ssrc:${spatialLayerId} cname:${cname}\r\n` +
  `a=ssrc:${spatialLayerId} msid:${msid}\r\n` +
  `a=ssrc:${spatialLayerId} mslabel:${mslabel}\r\n` +
  `a=ssrc:${spatialLayerId} label:${label}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} cname:${cname}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} msid:${msid}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} mslabel:${mslabel}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} label:${label}\r\n`;

SdpHelpers.setMaxBW = (sdpInput, spec) => {
  let r;
  let a;
  let m;
  let sdp = sdpInput;
  if (spec.video && spec.maxVideoBW) {
    m = sdp.match(/b=AS:.*\r\n/g);
    if (m == null) {
      m = sdp.match(/b=AS:.*\n/g);
      if (m) {
        sdp = sdp.replace(/b=AS:.*\n/g, '');
      }
    } else {
      sdp = sdp.replace(/b=AS:.*\r\n/g, '');
    }
    a = sdp.match(/m=video.*\r\n/);
    if (a == null) {
      a = sdp.match(/m=video.*\n/);
    }
    if (a && (a.length > 0)) {
      r = `${a[0]}b=AS:${spec.maxVideoBW}\r\n`;
      sdp = sdp.replace(a[0], r);
    }
  }

  if (spec.audio && spec.maxAudioBW) {
    a = sdp.match(/m=audio.*\r\n/);
    if (a == null) {
      a = sdp.match(/m=audio.*\n/);
    }
    if (a && (a.length > 0)) {
      r = `${a[0]}b=AS:${spec.maxAudioBW}\r\n`;
      sdp = sdp.replace(a[0], r);
    }
  }
  return sdp;
};

SdpHelpers.enableOpusNacks = (sdpInput) => {
  let sdp = sdpInput;
  const sdpMatch = sdp.match(/a=rtpmap:(.*)opus.*\r\n/);
  if (sdpMatch !== null) {
    const theLine = `${sdpMatch[0]}a=rtcp-fb:${sdpMatch[1]}nack\r\n`;
    sdp = sdp.replace(sdpMatch[0], theLine);
  }
  return sdp;
};

SdpHelpers.setOpusFmtp = (sdpInput, profile) => {
  let sdp = sdpInput;
  const sdpMatch = sdp.match(/a=rtpmap:(.*)opus.*\r?\n/);
  if (sdpMatch !== null) {
    const payloadType = sdpMatch[1];
    const reg = new RegExp(`a=fmtp:${payloadType}minptime=10;useinbandfec=1.*\r?\n`)
    //const sdpMatchFmtp = sdp.match(eval("/a=fmtp:" + payloadType + "minptime=10;useinbandfec=1.*\r?\n/"));
    const sdpMatchFmtp = sdp.match(reg);
    if (sdpMatchFmtp !== null) {
      const theLine = `a=fmtp:${payloadType}minptime=10;useinbandfec=1;stereo=${profile.stereo};sprop-stereo=${profile.stereo};maxplaybackrate=${profile.maxplaybackrate};sprop-maxcapturerate=${profile.maxplaybackrate};maxaveragebitrate=${profile.maxaveragebitrate}\r\n`;
      sdp = sdp.replace(sdpMatchFmtp[0], theLine);
    } else {
      const theLine = `${sdpMatch[0]}a=fmtp:${payloadType}minptime=10;useinbandfec=1;stereo=${profile.stereo};sprop-stereo=${profile.stereo};maxplaybackrate=${profile.maxplaybackrate};sprop-maxcapturerate=${profile.maxplaybackrate};maxaveragebitrate=${profile.maxaveragebitrate}\r\n`;
      sdp = sdp.replace(sdpMatch[0], theLine);
    }
  }
  return sdp;
};

SdpHelpers.addShimCandidate = (sdpInput) => {
  let sdp = sdpInput;
  const sdpMatch = sdp.match(/a=ice-ufrag.*\r?\n/);
  if (sdpMatch !== null) {
    const theLine = `a=candidate:2222222222 1 udp 2222222222 192.168.0.1 30000 typ host generation 0 network-id 1\r\n${sdpMatch[0]}`;
    sdp = sdp.replace(/a=ice-ufrag.*\r?\n/g, theLine);
  }
  return sdp;
}

/* harmony default export */ __webpack_exports__["default"] = (SdpHelpers);


/***/ }),

/***/ "./rtcbase/src/views/AudioPlayer.js":
/*!******************************************!*\
  !*** ./rtcbase/src/views/AudioPlayer.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AudioPlayer; });
/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./View */ "./rtcbase/src/views/View.js");
/* global window, document, webkitURL */



/*
 * AudioPlayer represents a Licode Audio component that shows either a local or a remote Audio.
 * Ex.: var player = AudioPlayer({id: id, stream: stream, elementID: elementID});
 * A AudioPlayer is also a View component.
 */

class AudioPlayer extends _View__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(spec) {
    super();
    this.spec = spec;
    // AudioPlayer ID
    this.id = spec.id;

    // Stream that the AudioPlayer will play
    this.stream = spec.stream.stream;

    // DOM element in which the AudioPlayer will be appended
    this.elementID = spec.elementID;

    // const myURL = window.URL || webkitURL;
    // this.streamUrl = myURL.createObjectURL(this.stream);

    // Audio tag
    this.audio = document.createElement('audio');
    this.audio.setAttribute('id', `stream${this.id}`);
    this.audio.setAttribute('class', 'licode_stream');
    this.audio.setAttribute('style', 'width: 100%; height: 100%; '); // position: absolute
    this.audio.setAttribute('autoplay', 'autoplay');
    if (typeof spec.options.controls === 'boolean') {
      this.audio.controls = spec.options.controls;
    }
    if (spec.stream.local) { this.audio.muted = true; }
    if (typeof spec.options.muted === 'boolean') {
      this.audio.muted = spec.options.muted;
    }

    if (this.elementID !== undefined) {
      // It will stop the AudioPlayer and remove it from the HTML
      this.destroy = () => {
        this.audio.pause();
        if (this.parentNode.contains(this.div)) {
          this.parentNode.removeChild(this.div);
        }
      };

      // Container
      this.div = document.createElement('div');
      this.div.setAttribute('id', `player_${this.id}`);
      this.div.setAttribute('class', 'licode_player');
      this.div.setAttribute('style', 'width: 100%; height: 100%;  ' +
        'overflow: hidden;'); // position: relative;

      // Check for a passed DOM node.
      if (typeof this.elementID === 'object' &&
        typeof this.elementID.appendChild === 'function') {
        this.container = this.elementID;
      } else {
        this.container = document.getElementById(this.elementID);
      }
      this.container.appendChild(this.div);

      this.parentNode = this.div.parentNode;

      this.div.appendChild(this.audio);

      // Expose a consistent object to manipulate the media.
      this.media = this.audio;
    } else {
      // It will stop the AudioPlayer and remove it from the HTML
      this.destroy = () => {
        this.audio.pause();
        if (this.parentNode.contains(this.audio)) {
          this.parentNode.removeChild(this.audio);
        }
      };

      document.body.appendChild(this.audio);
      this.parentNode = document.body;
    }

    this.audio.srcObject = this.stream;
    this.initAddEvent()
  }

  initAddEvent(){
    // 退出全屏后自动执行播放
    let _that = this
    // 针对Mobile safari上使用
    document.addEventListener('webkitbeginfullscreen', function(e){
      _that.fullScreenStatus = FULLSCREEN
    })
    
    document.addEventListener('webkitendfullscreen', function(){
      _that.fullScreenStatus = NOTFULLSCREEN
      setTimeout(() => { 
        try {
          if(!_that.audio.paused){
            _that.audio.play()
          }
        } catch (error) {}
      }, 200);
    })
  }
}


/***/ }),

/***/ "./rtcbase/src/views/VideoPlayer.js":
/*!******************************************!*\
  !*** ./rtcbase/src/views/VideoPlayer.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VideoPlayer; });
/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./View */ "./rtcbase/src/views/View.js");
/* global window, document, webkitURL, L */



/*
 * VideoPlayer represents a Licode video component that shows either a local or a remote video.
 * Ex.: var player = VideoPlayer({id: id, stream: stream, elementID: elementID});
 * A VideoPlayer is also a View component.
 */
class VideoPlayer extends _View__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(spec) {
    super();
    this.spec = spec;
    this.id = spec.id;
    this.streamId = spec.stream.getID();
    // Stream that the VideoPlayer will play
    this.stream = spec.stream.stream;

    // DOM element in which the VideoPlayer will be appended
    this.elementID = spec.elementID;

    // Container
    this.div = document.createElement('div');
    this.div.setAttribute('id', `player_${this.id}`);
    this.div.setAttribute('class', 'licode_player');
    this.div.setAttribute('style', 'width: 100%; height: 100%; ' +
      'background-color: black; overflow: hidden;');

    // Video tag
    this.video = document.createElement('video');
    this.video.setAttribute('id', `stream${this.id}`);
    this.video.setAttribute('class', 'licode_stream');
    this.video.setAttribute('style', 'width: 100%; height: 100%;');
    // fix: IOS H5 play action cause fullscreen
    this.video.setAttribute('playsinline', 'true');
    this.video.setAttribute('webkit-playsinline', '');
    this.video.setAttribute('x5-playsinline', '');
    if (typeof spec.options.controls === 'boolean') {
      this.video.controls = spec.options.controls;
    }
    if (spec.stream.local) { this.video.muted = true; }
    if (spec.stream.local && spec.stream.mirror === true && (spec.stream.streamType === 1 || spec.stream.streamType === 2)) {
      this.video.setAttribute('style', 'width: 100%; height: 100%; transform: rotateY(180deg); -webkit-transform: rotateY(180deg); -moz-transform: rotateY(180deg);');
    }
    if (typeof spec.options.muted === 'boolean') {
      this.video.muted = spec.options.muted;
    }

    if (this.elementID !== undefined) {
      // Check for a passed DOM node.
      if (typeof this.elementID === 'object' &&
        typeof this.elementID.appendChild === 'function') {
        this.container = this.elementID;
      } else {
        this.container = document.getElementById(this.elementID);
      }
    } else {
      this.container = document.body;
    }
    this.container.appendChild(this.div);

    this.parentNode = this.div.parentNode;

    if (this.loader) {
      this.div.appendChild(this.loader);
    }
    this.div.appendChild(this.video);

    // document.addEventListener("fullscreenchange", function( event ) {
    //   if (this.video) {
    //     this.video.play();
    //   }
    // });

    this.containerWidth = 0;
    this.containerHeight = 0;

    // Expose a consistent object to manipulate the media.
    this.media = this.video;

    // }

    console.warn(`-----`, this.spec.stream);
    let StreamObj = this.spec.stream
    this.video.srcObject = StreamObj.cloneStream
    if(StreamObj.beautyOption.flag){
      StreamObj.beautyRtc.startDraw()
      StreamObj.cloneStream.removeTrack(StreamObj.cloneStream.getVideoTracks()[0])
      StreamObj.cloneStream.addTrack(StreamObj.beautyRtc.getCanvasCap().getVideoTracks()[0], 'cxs')
    }

    this.initAddEvent()
  }

  applyRatio(ratio, width, height, reverse) {
    const condition = !reverse ? width * (1 / ratio) < height : width * (1 / ratio) > height;
    if (condition) {
      this.video.style.width = `${width}px`;
      this.video.style.height = `${(1 / ratio) * width}px`;

      this.video.style.top = `${-((((1 / ratio) * width) / 2) - (height / 2))}px`;
      this.video.style.left = '0px';
    } else {
      this.video.style.height = `${height}px`;
      this.video.style.width = `${ratio * height}px`;

      this.video.style.left = `${-(((ratio * height) / 2) - (width / 2))}px`;
      this.video.style.top = '0px';
    }
  }

  // Public functions

  // It will stop the VideoPlayer and remove it from the HTML
  destroy() {
    this.video.pause();
    if (this.parentNode.contains(this.div)) {
      this.parentNode.removeChild(this.div);
    }
  }

  resize() {
    const width = this.container.offsetWidth;
    const height = this.container.offsetHeight;

    if (this.spec.stream.screen || this.spec.options.crop === false) {
      this.applyRatio(16 / 9, width, height, false);
    } else if (width !== this.containerWidth || height !== this.containerHeight) {
      this.applyRatio(4 / 3, width, height, true);
    }

    this.containerWidth = width;
    this.containerHeight = height;
  };
  
  initAddEvent(){
    let _that = this
     // 针对Mobile safari上使用
     document.addEventListener('webkitbeginfullscreen', function(e){
        _that.fullScreenStatus = FULLSCREEN
      })
      
      document.addEventListener('webkitendfullscreen', function(){
          _that.fullScreenStatus = NOTFULLSCREEN
          setTimeout(() => { 
              try {
                if(!_that.video.paused){
                  _that.video.play()
                }
              } catch (error) {}
          }, 200);
      })
  }
}


/***/ }),

/***/ "./rtcbase/src/views/View.js":
/*!***********************************!*\
  !*** ./rtcbase/src/views/View.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return View; });
/* harmony import */ var _utils_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Events */ "./rtcbase/src/utils/Events.js");
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");
/* harmony import */ var _common_Definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Definition */ "./rtcbase/src/common/Definition.js");
/*
 * View class represents a HTML component
 * Every view is an EventDispatcher.
 * 获取全屏状态功能暂不提供
 */




const FULLSCREEN = 'FULLSCREEN'
const NOTFULLSCREEN = 'NOTFULLSCREEN'

class View extends _utils_Events__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {
  constructor() {
    super();
    this.url = '';
    this.fullScreenStatus = NOTFULLSCREEN
  }

  setAudioOutput(deviceId, success = () => {}, failure = () => {}) {
    return new Promise((resolve, reject) => {
      const avElement = this.video || this.audio;
      if (avElement && typeof avElement.sinkId !== 'undefined') {
        avElement.setSinkId(deviceId).then(() => {
          _common_uplog__WEBPACK_IMPORTED_MODULE_1__["default"].info(`setSinkId success ${deviceId}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_2__["K"].SET_AUDIO_OUTPUT, streamId: this.streamId });
          success();
          resolve();
        }).catch((error) => {
          _common_uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`setSinkId failed ${deviceId}, ${error}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_2__["K"].SET_AUDIO_OUTPUT, streamId: this.streamId });
          failure(error.name);
          reject(error.name);
        });
      } else {
        const msg = `setSinkId failed ${deviceId}, browser does not support output device selection`;
        _common_uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`${msg}`, { k: _common_Definition__WEBPACK_IMPORTED_MODULE_2__["K"].SET_AUDIO_OUTPUT, streamId: this.streamId });
        failure(msg);
        reject(msg);
      }
    });
  }

  play(){
    return this.media.play()
  }

  pause(){
    return Promise.resolve(this.media.pause())
  }

  getAudioVolume(){
    return Promise.resolve(this.media.volume)
  }

  // Dom进入
  setFullscreen(opt){
    return new Promise((resolve,reject)=>{
      let { vNode = undefined } = opt
      this.fullScreenStatus = FULLSCREEN
      if(!vNode){
        return this.vScreenJoin(this.media).then(res=>{resolve(res)}).catch(err=>{reject(err)})
      }
      let videoWrap = document.querySelector(`#${vNode}`)
      if (videoWrap.requestFullscreen) videoWrap.requestFullscreen(),resolve()
      else if (videoWrap.webkitRequestFullscreen) videoWrap.webkitRequestFullscreen(),resolve()
      else if (videoWrap.mozRequestFullScreen) videoWrap.mozRequestFullScreen(),resolve()
      else if (videoWrap.msRequestFullscreen) videoWrap.msRequestFullscreen(),resolve()
      else  {
        return this.vScreenJoin(this.media).then(res=>{resolve(res)}).catch(err=>{reject(err)})
      }
    })
  }

  // video/audio  进入
  vScreenJoin(vScreenDom){
    return new Promise((resolve,reject) => {
      try {
        if(vScreenDom.webkitEnterFullScreen) vScreenDom.webkitEnterFullScreen(),resolve()
        else if (vScreenDom.requestFullscreen) vScreenDom.requestFullscreen(),resolve()
        else if (vScreenDom.webkitRequestFullscreen) vScreenDom.webkitRequestFullscreen(),resolve()
        else if (vScreenDom.mozRequestFullScreen) vScreenDom.mozRequestFullScreen(),resolve()
        else if (vScreenDom.msRequestFullscreen) vScreenDom.msRequestFullscreen(),resolve()
        else throw ({code: '611034', message: 'Failed to execute full screen of video..'})
        this.fullScreenStatus = FULLSCREEN
      } catch (error) {
        this.fullScreenStatus = NOTFULLSCREEN
        reject({code: '611035', message: '执行伪全屏'})
      }
    })
  }

  // Dom退出
  exitFullscreen(opt){
    return new Promise((resolve, reject)=>{
      this.fullScreenStatus = NOTFULLSCREEN
      let { vNode = undefined } = opt
      if( !vNode ){
        return this.vScreenQuit(this.media).then(()=>{resolve()}).catch(err=>{reject(err)})
      }
      if (document.exitFullscreen) document.exitFullscreen(),resolve()
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen(),resolve()
      else if (document.mozCancelFullScreen) document.mozCancelFullScreen(),resolve()
      else if (document.msExitFullscreen) document.msExitFullscreen(),resolve()
      else {
        return this.vScreenQuit(this.media).then(()=>{resolve()}).catch(err=>{reject(err)})
      }
    })
  }
  // video/audio 退出
  vScreenQuit(vScreenDom){
    return new Promise((resolve, reject)=>{
      try {
        if(vScreenDom.webkitExitFullscreen) vScreenDom.webkitExitFullscreen(),resolve()
        if (vScreenDom.exitFullscreen) vScreenDom.exitFullscreen(),resolve()
        else if (vScreenDom.webkitExitFullscreen) vScreenDom.webkitExitFullscreen(),resolve()
        else if (vScreenDom.mozCancelFullScreen) vScreenDom.mozCancelFullScreen(),resolve()
        else if (vScreenDom.msExitFullscreen) vScreenDom.msExitFullscreen(),resolve()
        else throw ({code: '611034', message: 'Failed to quit full screen of video..'})
      } catch (error) {
        this.fullScreenStatus = NOTFULLSCREEN
        reject({code: '611035', message: '伪全屏退出'})
      }
    })
  }
}


/***/ }),

/***/ "./rtcbase/src/webrtc-stacks/BaseStack.js":
/*!************************************************!*\
  !*** ./rtcbase/src/webrtc-stacks/BaseStack.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/SdpHelpers */ "./rtcbase/src/utils/SdpHelpers.js");
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");
/* global RTCSessionDescription, RTCIceCandidate, RTCPeerConnection */




const BaseStack = (specInput) => {
  const that = {};
  const specBase = specInput;
  let localDesc;
  let remoteDesc;

  specBase.remoteCandidates = [];
  specBase.localCandidates = [];
  specBase.remoteDescriptionSet = false;

  if (specBase.audio === undefined) {
    specBase.audio = true;
  }
  if (specBase.video === undefined) {
    specBase.video = true;
  }
  that.audio = specBase.audio;
  that.video = specBase.video;
  that.mediaConstraints = {
    offerToReceiveVideo: (that.video !== false),
    offerToReceiveAudio: (that.audio !== false)
  };

  // create RTCPeerConnection
  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection
  that.pcConfig = {
    iceServers: [],
    // sdpSemantics: 'unified-plan', //'unified-plan' or 'plan-b'
  };
  if (specBase.iceServers !== undefined) {
    that.pcConfig.iceServers = specBase.iceServers;
    if (specBase.forceTurn === true) {
      that.pcConfig.iceTransportPolicy = 'relay';
    }
  }
  that.peerConnection = new RTCPeerConnection(that.pcConfig);


  const errorCallback = (where, errorcb, message) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error(`message: ${message} in baseStack at ${where}`);
    if (errorcb !== undefined) {
      errorcb('error');
    }
  };

  const onIceCandidate = (event) => {
    return;
  };

  const onIceGatheringStateChange = (event) => {
    // log.info(`onicegatheringstatechange: ${that.peerConnection.iceGatheringState}`);
    return;
  }

  const setLocalDescForOffer = (isSubscribe, sessionDescription) => {
    localDesc = sessionDescription;
    if (!isSubscribe) {
      localDesc.sdp = that.enableSimulcast(localDesc.sdp);
    }
    localDesc.sdp = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].setMaxBW(localDesc.sdp, specBase);
    if (specBase.enableOpusNack) {
      localDesc.sdp = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].enableOpusNacks(localDesc.sdp);
    }
    // ice-lite
    localDesc.sdp = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].addShimCandidate(localDesc.sdp);

    specBase.callback({
      type: localDesc.type,
      sdp: localDesc.sdp
    });
  };


  const processAnswer = (message) => {
    const msg = message;
    if (specBase.audioProfle !== undefined) {
      msg.sdp = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].setOpusFmtp(msg.sdp, specBase.audioProfle);
    }
    msg.sdp = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].setMaxBW(msg.sdp, specBase);
    // msg.sdp = that.setStartVideoBW(msg.sdp);
    msg.sdp = that.setHardMinVideoBW(msg.sdp);
    remoteDesc = msg;

    that.peerConnection.setLocalDescription(localDesc).then(() => {
      that.peerConnection.setRemoteDescription(new RTCSessionDescription(msg)).then(() => {
        specBase.remoteDescriptionSet = true;
      }).catch(errorCallback.bind(null, 'processAnswer', undefined));
    }).catch(errorCallback.bind(null, 'processAnswer', undefined));
  };

  // Peerconnection events
  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/onicecandidate
  that.peerConnection.onicecandidate = onIceCandidate;
  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/onicegatheringstatechange
  that.peerConnection.onicegatheringstatechange = onIceGatheringStateChange;
  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/onaddstream
  // todo: migrating to ontrack
  that.peerConnection.onaddstream = (stream) => {
    if (that.onaddstream) {
      that.onaddstream(stream);
    }
  };

  that.peerConnection.onremovestream = (stream) => {
    if (that.onremovestream) {
      that.onremovestream(stream);
    }
  };

  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/oniceconnectionstatechange
  that.peerConnection.oniceconnectionstatechange = (ev) => {
    if (that.oniceconnectionstatechange) {
      that.oniceconnectionstatechange(ev.target.iceConnectionState);
    }
  };


  // public functions
  that.setStartVideoBW = (sdpInput) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error('startVideoBW not implemented for this browser');
    return sdpInput;
  };

  that.setHardMinVideoBW = (sdpInput) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error('hardMinVideoBw not implemented for this browser');
    return sdpInput;
  };
  
  that.enableSimulcast = (sdpInput) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_1__["default"].error('Simulcast not implemented');
    return sdpInput;
  };

  that.close = () => {
    that.state = 'closed';
    that.peerConnection.close();
  };

  that.updateSpec = (configInput, callback = () => {}) => {
    const config = configInput;
    if (config.maxVideoBW || config.maxAudioBW) {
      if (config.maxVideoBW) {
        if (config.maxVideoBW > specBase.limitMaxVideoBW) {
          config.maxVideoBW = specBase.limitMaxVideoBW;
        }
        specBase.maxVideoBW = config.maxVideoBW;
      }
      if (config.maxAudioBW) {
        specBase.maxAudioBW = config.maxAudioBW;
      }

      localDesc.sdp = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].setMaxBW(localDesc.sdp, specBase);
      if (config.Sdp || config.maxVideoBW || config.maxAudioBW) {
        // log.info(`Updating with SDP renegotiation: maxVideoBW: ${specBase.maxVideoBW}, maxAudioBW: ${specBase.maxAudioBW}`);
        that.peerConnection.setLocalDescription(localDesc)
          .then(() => {
            remoteDesc.sdp = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_0__["default"].setMaxBW(remoteDesc.sdp, specBase);
            return that.peerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));
          }).then(() => {
            specBase.remoteDescriptionSet = true;
            specBase.callback({ type: 'updatestream', sdp: localDesc.sdp });
          }).catch(errorCallback.bind(null, 'updateSpec', callback));
      } else {
        // log.info(`Updating without SDP renegotiation, newVideoBW: ${specBase.maxVideoBW}, newAudioBW: ${specBase.maxAudioBW}`);
        specBase.callback({ type: 'updatestream', sdp: localDesc.sdp });
      }
    }
    if (config.minVideoBW || 
            (config.muteStream !== undefined) || (config.qualityLayer !== undefined) ||
            (config.video !== undefined) || (config.dual !== undefined) ||
            (config.seekTime !== undefined) || (config.fileCtl !== undefined)) {
      // log.info(`updatestream: ${config}`);
      specBase.callback({ type: 'updatestream', config });
    }
  };

  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createOffer
  that.createOffer = (isSubscribe) => {
    if (isSubscribe !== true) {
      that.mediaConstraints = {
        offerToReceiveVideo: false,
        offerToReceiveAudio: false
      };
    }
    that.peerConnection.createOffer(that.mediaConstraints)
      .then(setLocalDescForOffer.bind(null, isSubscribe))
      .catch(errorCallback.bind(null, 'Create Offer', undefined));
  };

  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream
  // migrating to addTrack()
  that.addStream = (stream) => {
    that.peerConnection.addStream(stream);
  };

  that.processSignalingMessage = (msgInput) => {
    if (msgInput.type === 'offer') { // no need
      processOffer(msgInput);
    } else if (msgInput.type === 'candidate') { // no need
      processNewCandidate(msgInput);
    } else if (msgInput.type === 'answer') { 
      processAnswer(msgInput);
    }
  };

  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/getStats
  that.getStats = (callback) => {
    that.peerConnection.getStats(null).then((res) => {
      callback(res);
    });
  };

  // zhix: 新增 peerConnection 的removeTrack 方法，对发出的流进行删除轨道操作
  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/removeTrack
  // https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpSender
  that.removeTrack = (track)=>{
    that.peerConnection.removeTrack(that.peerConnection.getSenders().find(res=>{
      return res.track == track;
    }))
  }

  // zhix: 新增 peerConnection 的removeTrack 方法，对发出的流进行添加轨道操作
  // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack
  that.addTrack = (track , stream)=>{
    that.peerConnection.addTrack(track , stream);
  }

  return that;
};

/* harmony default export */ __webpack_exports__["default"] = (BaseStack);


/***/ }),

/***/ "./rtcbase/src/webrtc-stacks/ChromeStableStack.js":
/*!********************************************************!*\
  !*** ./rtcbase/src/webrtc-stacks/ChromeStableStack.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseStack */ "./rtcbase/src/webrtc-stacks/BaseStack.js");
/* harmony import */ var _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../utils/SdpHelpers */ "./rtcbase/src/utils/SdpHelpers.js");
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");




const ChromeStableStack = (specInput) => {
  const spec = specInput;
  const that = Object(_BaseStack__WEBPACK_IMPORTED_MODULE_0__["default"])(specInput);
  const defaultSimulcastSpatialLayers = 2;
  const streamId = spec.streamId;
  _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].info('Starting Chrome stable stack', { streamId, Collapsed: specInput });

  that.enableSimulcast = (sdpInput) => {
    let result;
    let sdp = sdpInput;
    if (!spec.video || !spec.simulcast) {
      return sdp;
    }

    // TODO(javier): Improve the way we check for current video ssrcs
    const matchGroup = sdp.match(/a=ssrc-group:FID ([0-9]*) ([0-9]*)\r?\n/);
    if (!matchGroup || (matchGroup.length <= 0)) {
      return sdp;
    }
    // TODO (pedro): Consider adding these to SdpHelpers
    const numSpatialLayers = spec.simulcast.numSpatialLayers || defaultSimulcastSpatialLayers;
    const baseSsrc = parseInt(matchGroup[1], 10);
    const baseSsrcRtx = parseInt(matchGroup[2], 10);
    const cname = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} cname:(.*)\r?\n`))[1];
    const msid = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} msid:(.*)\r?\n`))[1];
    const mslabel = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} mslabel:(.*)\r?\n`))[1];
    const label = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} label:(.*)\r?\n`))[1];

    sdp.match(new RegExp(`a=ssrc:${matchGroup[1]}.*\r?\n`, 'g')).forEach((line) => {
      sdp = sdp.replace(line, '');
    });
    sdp.match(new RegExp(`a=ssrc:${matchGroup[2]}.*\r?\n`, 'g')).forEach((line) => {
      sdp = sdp.replace(line, '');
    });

    const spatialLayers = [baseSsrc];
    const spatialLayersRtx = [baseSsrcRtx];

    for (let i = 1; i < numSpatialLayers; i += 1) {
      spatialLayers.push(baseSsrc + (i * 1000));
      spatialLayersRtx.push(baseSsrcRtx + (i * 1000));
    }

    result = _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_1__["default"].addSim(spatialLayers);
    let spatialLayerId;
    let spatialLayerIdRtx;
    for (let i = 0; i < spatialLayers.length; i += 1) {
      spatialLayerId = spatialLayers[i];
      spatialLayerIdRtx = spatialLayersRtx[i];
      result += _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_1__["default"].addGroup(spatialLayerId, spatialLayerIdRtx);
    }

    for (let i = 0; i < spatialLayers.length; i += 1) {
      spatialLayerId = spatialLayers[i];
      spatialLayerIdRtx = spatialLayersRtx[i];
      result += _utils_SdpHelpers__WEBPACK_IMPORTED_MODULE_1__["default"].addSpatialLayer(cname,
        msid, mslabel, label, spatialLayerId, spatialLayerIdRtx);
    }
    result += 'a=x-google-flag:conference\r\n';
    return sdp.replace(matchGroup[0], result);
  };

  that.setStartVideoBW = (sdpInfo) => {
    if (that.video && spec.startVideoBW) {
      _common_uplog__WEBPACK_IMPORTED_MODULE_2__["default"].info(`startVideoBW requested: ${spec.startVideoBW}`);
      if (sdpInfo.indexOf('m=audio') > sdpInfo.indexOf('m=video') &&
        sdpInfo.indexOf('m=audio') > -1 && sdpInfo.indexOf('m=video') > -1) {
        // head + video sdp
        let videoSDP = sdpInfo.substring(0, sdpInfo.indexOf('m=audio'));
        // audio sdp
        const audioSDP = sdpInfo.substring(sdpInfo.indexOf('m=audio'), sdpInfo.length);
        const sdpMatch = videoSDP.match(/a=rtpmap:(.*)VP8/);
        if (sdpMatch !== null) {
          videoSDP += `a=fmtp:${sdpMatch[1]}x-google-start-bitrate=${spec.startVideoBW}\r\n`;
        }
        const sdpMatchH264 = sdpInfo.match(/a=rtpmap:(.*)H264/);
        if (sdpMatchH264 !== null) {
          videoSDP += `a=fmtp:${sdpMatchH264[1]}x-google-start-bitrate=${spec.startVideoBW}\r\n`;
        }
        sdpInfo = `${videoSDP}${audioSDP}`;
      } else {
        // sdpInfo += `a=fmtp:96 x-google-start-bitrate=${spec.startVideoBW}\r\n`;
        const sdpMatch = sdpInfo.match(/a=rtpmap:(.*)VP8/);
        if (sdpMatch !== null) {
          sdpInfo += `a=fmtp:${sdpMatch[1]}x-google-start-bitrate=${spec.startVideoBW}\r\n`;
        }
        const sdpMatchH264 = sdpInfo.match(/a=rtpmap:(.*)H264/);
        if (sdpMatchH264 !== null) {
          sdpInfo += `a=fmtp:${sdpMatchH264[1]}x-google-start-bitrate=${spec.startVideoBW}\r\n`;
        }
      }
    }
    return sdpInfo;
  };
  // TODO: fit more video codec sdp
  that.setHardMinVideoBW = (sdpInfo) => {
    if (that.video && spec.hardMinVideoBW) {
      // log.info(`hardMinVideoBW requested: ${spec.hardMinVideoBW}`);
      if (sdpInfo.indexOf('m=audio') > sdpInfo.indexOf('m=video') &&
        sdpInfo.indexOf('m=audio') > -1 && sdpInfo.indexOf('m=video') > -1) {
        // head + video sdp
        let videoSDP = sdpInfo.substring(0, sdpInfo.indexOf('m=audio'));
        // audio sdp
        const audioSDP = sdpInfo.substring(sdpInfo.indexOf('m=audio'), sdpInfo.length);
        const sdpMatch = videoSDP.match(/a=rtpmap:(.*)VP8/);
        if (sdpMatch !== null) {
          videoSDP += `a=fmtp:${sdpMatch[1]}x-google-min-bitrate=${spec.hardMinVideoBW}\r\n`;
        }
        const sdpMatchH264 = sdpInfo.match(/a=rtpmap:(.*)H264/);
        if (sdpMatchH264 !== null) {
          videoSDP += `a=fmtp:${sdpMatchH264[1]}x-google-min-bitrate=${spec.hardMinVideoBW}\r\n`;
        }
        sdpInfo = `${videoSDP}${audioSDP}`;
      } else {
        const sdpMatch = sdpInfo.match(/a=rtpmap:(.*)VP8/);
        if (sdpMatch !== null) {
          sdpInfo += `a=fmtp:${sdpMatch[1]}x-google-min-bitrate=${spec.hardMinVideoBW}\r\n`;
        }
        const sdpMatchH264 = sdpInfo.match(/a=rtpmap:(.*)H264/);
        if (sdpMatchH264 !== null) {
          sdpInfo += `a=fmtp:${sdpMatchH264[1]}x-google-min-bitrate=${spec.hardMinVideoBW}\r\n`;
        }
      }
    }
    return sdpInfo;
  };

  return that;
};

/* harmony default export */ __webpack_exports__["default"] = (ChromeStableStack);


/***/ }),

/***/ "./rtcbase/src/webrtc-stacks/FcStack.js":
/*!**********************************************!*\
  !*** ./rtcbase/src/webrtc-stacks/FcStack.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");


const FcStack = (spec) => {
  /*
  spec.callback({
      type: sessionDescription.type,
      sdp: sessionDescription.sdp
  });
  */
  const that = {};

  that.pcConfig = {};

  that.peerConnection = {};
  that.desc = {};
  that.signalCallback = undefined;

  that.close = () => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_0__["default"].info('Close FcStack');
  };

  that.createOffer = () => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_0__["default"].info('FCSTACK: CreateOffer');
  };

  that.addStream = (stream) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_0__["default"].info('FCSTACK: addStream', stream);
  };

  that.processSignalingMessage = (msg) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_0__["default"].info('FCSTACK: processSignaling', msg);
    if (that.signalCallback !== undefined) { that.signalCallback(msg); }
  };

  that.sendSignalingMessage = (msg) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_0__["default"].info('FCSTACK: Sending signaling Message', msg);
    spec.callback(msg);
  };

  that.setSignalingCallback = (callback = () => {}) => {
    _common_uplog__WEBPACK_IMPORTED_MODULE_0__["default"].info('FCSTACK: Setting signalling callback');
    that.signalCallback = callback;
  };
  return that;
};

/* harmony default export */ __webpack_exports__["default"] = (FcStack);


/***/ }),

/***/ "./rtcbase/src/webrtc-stacks/FirefoxStack.js":
/*!***************************************************!*\
  !*** ./rtcbase/src/webrtc-stacks/FirefoxStack.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_uplog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/uplog */ "./rtcbase/src/common/uplog.js");
/* harmony import */ var _BaseStack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseStack */ "./rtcbase/src/webrtc-stacks/BaseStack.js");



const FirefoxStack = (specInput) => {
  _common_uplog__WEBPACK_IMPORTED_MODULE_0__["default"].info('Starting Firefox stack');
  const that = Object(_BaseStack__WEBPACK_IMPORTED_MODULE_1__["default"])(specInput);
  const spec = specInput;

  that.enableSimulcast = (sdp) => {
    if (!spec.video || !spec.simulcast) {
      return sdp;
    }
    that.peerConnection.getSenders().forEach((sender) => {
      if (sender.track.kind === 'video') {
        sender.getParameters();
        sender.setParameters({ encodings: [{
          rid: 'spam',
          active: true,
          priority: 'high',
          maxBitrate: 40000,
          maxHeight: 640,
          maxWidth: 480 }, {
            rid: 'egg',
            active: true,
            priority: 'medium',
            maxBitrate: 10000,
            maxHeight: 320,
            maxWidth: 240 }],
        });
      }
    });
    return sdp;
  };
  return that;
};

/* harmony default export */ __webpack_exports__["default"] = (FirefoxStack);


/***/ }),

/***/ "./src/CallMain.js":
/*!*************************!*\
  !*** ./src/CallMain.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ "./node_modules/babel-runtime/core-js/get-iterator.js");
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _tools_Store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tools/Store */ "./src/tools/Store.js");
/* harmony import */ var _server_API__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./server/API */ "./src/server/API.js");
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./common/Contant */ "./src/common/Contant.js");
/* harmony import */ var _tools_RoomInfo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/RoomInfo */ "./src/tools/RoomInfo.js");
/* harmony import */ var _tools_Events__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/Events */ "./src/tools/Events.js");
/* harmony import */ var _tools_Utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/Utils */ "./src/tools/Utils.js");
/* harmony import */ var _biz_call_MsgRoom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./biz/call/MsgRoom */ "./src/biz/call/MsgRoom.js");
/* harmony import */ var _biz_call_O2O__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./biz/call/O2O */ "./src/biz/call/O2O.js");
/* harmony import */ var _biz_call_StreamsApi__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./biz/call/StreamsApi */ "./src/biz/call/StreamsApi.js");
/* harmony import */ var _biz_call_RoomApi__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./biz/call/RoomApi */ "./src/biz/call/RoomApi.js");
/* harmony import */ var _biz_call_StaticFnc__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./biz/call/StaticFnc */ "./src/biz/call/StaticFnc.js");


















window.VhallRTC = new (function () {
  function VhallRTC() {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5___default()(this, VhallRTC);

    this.roomInfo = new _tools_RoomInfo__WEBPACK_IMPORTED_MODULE_10__["default"]();
    this.events = new _tools_Events__WEBPACK_IMPORTED_MODULE_11__["default"]();

    // 导入静态方法
    Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["mixin"])(this, _biz_call_StaticFnc__WEBPACK_IMPORTED_MODULE_17__["default"], this);
    // 添加常量
    for (var i in _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"]) {
      this[i] = _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"][i];
    }
    for (var _i in _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"]) {
      this[_i] = _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"][_i];
    }
    for (var _i2 in _common_Contant__WEBPACK_IMPORTED_MODULE_9__["VRTC_MODES"]) {
      this[_i2] = _common_Contant__WEBPACK_IMPORTED_MODULE_9__["VRTC_MODES"][_i2];
    }
    // 添加常量，rtc底层音视频参数
    for (var _i3 in _common_Contant__WEBPACK_IMPORTED_MODULE_9__["Constant"]) {
      this[_i3] = _common_Contant__WEBPACK_IMPORTED_MODULE_9__["Constant"][_i3];
    }
    // 添加版本号和版本日期
    this["VERSION"] = "2.3.6";
    this["RTCVERSION"] = "1.3.6";
    this["DATE"] = "2021/11/1";
  }

  /**
   * 创建实例
   * @param {object} opt 创建实例参数
   * @param {function} success 成功回调
   * @param {function} failure 失败回调
   */


  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6___default()(VhallRTC, [{
    key: "createInstance",
    value: function () {
      var _ref = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee(opt) {
        var success = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
        var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

        var inavId, _opt$roomId, roomId, appId, accountId, token, _opt$mode, mode, _opt$role, role, _opt$autoStartBroadca, autoStartBroadcast, _opt$broadcastConfig, broadcastConfig, _opt$otherOption, otherOption, _opt$hide, hide, _opt$client, client, _opt$attributes, attributes, _opt$forceTurn, forceTurn, reg, callOpt, inavUserlist, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, user, res, connectOption, _res, currentStreams, streamIdArr, isConfigRoomBroadCast, broadCast, vhallrtc;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                inavId = opt.inavId, _opt$roomId = opt.roomId, roomId = _opt$roomId === undefined ? "" : _opt$roomId, appId = opt.appId, accountId = opt.accountId, token = opt.token, _opt$mode = opt.mode, mode = _opt$mode === undefined ? _common_Contant__WEBPACK_IMPORTED_MODULE_9__["VRTC_MODES"].MODE_RTC : _opt$mode, _opt$role = opt.role, role = _opt$role === undefined ? _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_HOST : _opt$role, _opt$autoStartBroadca = opt.autoStartBroadcast, autoStartBroadcast = _opt$autoStartBroadca === undefined ? false : _opt$autoStartBroadca, _opt$broadcastConfig = opt.broadcastConfig, broadcastConfig = _opt$broadcastConfig === undefined ? {} : _opt$broadcastConfig, _opt$otherOption = opt.otherOption, otherOption = _opt$otherOption === undefined ? {} : _opt$otherOption, _opt$hide = opt.hide, hide = _opt$hide === undefined ? false : _opt$hide, _opt$client = opt.client, client = _opt$client === undefined ? Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["checkDevice"])() : _opt$client, _opt$attributes = opt.attributes, attributes = _opt$attributes === undefined ? "" : _opt$attributes, _opt$forceTurn = opt.forceTurn, forceTurn = _opt$forceTurn === undefined ? false : _opt$forceTurn;
                // 无延迟进行隐身参会  直播类型+观众

                if (mode === _common_Contant__WEBPACK_IMPORTED_MODULE_9__["VRTC_MODES"].MODE_LIVE && opt.role === _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_AUDIENCE) {
                  hide = true;
                }

                if (!(!inavId || !appId || !accountId || !token || typeof attributes !== "string")) {
                  _context.next = 5;
                  break;
                }

                failure && failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS);
                return _context.abrupt("return");

              case 5:
                reg = new RegExp("[\\u4E00-\\u9FFF]+", "g");

                if (!reg.test(accountId)) {
                  _context.next = 9;
                  break;
                }

                failure && failure({ code: "611029", message: "accountId不能为中文", data: {} });
                return _context.abrupt("return");

              case 9:
                if (!(mode !== _common_Contant__WEBPACK_IMPORTED_MODULE_9__["VRTC_MODES"].MODE_RTC && mode !== _common_Contant__WEBPACK_IMPORTED_MODULE_9__["VRTC_MODES"].MODE_LIVE)) {
                  _context.next = 12;
                  break;
                }

                failure && failure({ code: "611029", message: "mode参数错误", data: {} });
                return _context.abrupt("return");

              case 12:
                if (role === "MASTER" || role === "GUEST" || mode === _common_Contant__WEBPACK_IMPORTED_MODULE_9__["VRTC_MODES"].MODE_RTC) {
                  //兼容历史
                  role = _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_HOST;
                }

                if (!(role !== _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_HOST && role !== _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_AUDIENCE)) {
                  _context.next = 16;
                  break;
                }

                failure && failure({ code: "611029", message: "role参数错误", data: {} });
                return _context.abrupt("return");

              case 16:

                this.roomInfo.setLocalMap(accountId);

                this.store = new _tools_Store__WEBPACK_IMPORTED_MODULE_7__["default"]();
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].APP_ID, appId);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ACCOUNTID, accountId);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].CLIENT, client);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ACCESS_TOKEN, token);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].PACKAGE_CHECK, "peter");
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID, inavId);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ROOMID, roomId);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].CLIENT_ROLE, role);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].VRTC_MODE, mode);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].AUTOSTARTBROADCAST, autoStartBroadcast);
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].BROADCASTCONFIG, autoStartBroadcast);
                this.api = new _server_API__WEBPACK_IMPORTED_MODULE_8__["default"](this.store);

                // 由于断线后服务端没有移除此用户，故加入此代码
                _context.prev = 30;
                _context.next = 33;
                return this.api.LeaveInav(inavId, accountId);

              case 33:
                _context.next = 39;
                break;

              case 35:
                _context.prev = 35;
                _context.t0 = _context["catch"](30);

                failure({ code: "", message: _context.t0.msg, data: {} });
                return _context.abrupt("return");

              case 39:
                _context.prev = 39;
                _context.next = 42;
                return Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["createVhallMsg"])({ appId: appId, accountId: accountId, token: token, inavId: inavId, hide: hide, client: client });

              case 42:
                this.msg = _context.sent;
                _context.next = 49;
                break;

              case 45:
                _context.prev = 45;
                _context.t1 = _context["catch"](39);

                failure({ code: "", message: "初始化消息服务失败", data: {} });
                return _context.abrupt("return");

              case 49:

                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].LOG_SERVER, this.msg.info.log_server);

                // 获取互动房间信息
                _context.prev = 50;
                _context.next = 53;
                return this.api.getInavInfo(inavId, roomId, mode, role);

              case 53:
                this.inavInfo = _context.sent;
                _context.next = 60;
                break;

              case 56:
                _context.prev = 56;
                _context.t2 = _context["catch"](50);

                failure({ code: "", message: _context.t2.msg, data: {} });
                return _context.abrupt("return");

              case 60:
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].PUSH_URL, this.inavInfo.pushUrl);

                // 互动房间配置
                callOpt = {
                  token: this.inavInfo.inav_token,
                  upLogUrl: this.msg.info.log_server, // 日志上报的url地址
                  bu: 1, // 业务类型，pass 1
                  vid: this.inavInfo.log_info.account_id, // 发起者（房间创建者）账号 accountId
                  app_id: appId, // 应用id(选填)
                  otherOption: otherOption, // 自定义上报字段
                  forceTurn: forceTurn, //是否强制使用turn代理服务器（iceServers）
                  mode: mode
                };

                // 将房间内的用户存入roomInfo中

                _context.next = 64;
                return this.api.getInavUserlist(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID));

              case 64:
                _context.t3 = _context.sent;

                if (_context.t3) {
                  _context.next = 67;
                  break;
                }

                _context.t3 = [];

              case 67:
                inavUserlist = _context.t3;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context.prev = 71;
                _iterator = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_3___default()(inavUserlist["lists"]);

              case 73:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context.next = 81;
                  break;
                }

                user = _step.value;

                if (!(accountId === user.third_party_user_id)) {
                  _context.next = 77;
                  break;
                }

                return _context.abrupt("continue", 78);

              case 77:
                this.roomInfo.setRemoteMap(user.third_party_user_id);

              case 78:
                _iteratorNormalCompletion = true;
                _context.next = 73;
                break;

              case 81:
                _context.next = 87;
                break;

              case 83:
                _context.prev = 83;
                _context.t4 = _context["catch"](71);
                _didIteratorError = true;
                _iteratorError = _context.t4;

              case 87:
                _context.prev = 87;
                _context.prev = 88;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 90:
                _context.prev = 90;

                if (!_didIteratorError) {
                  _context.next = 93;
                  break;
                }

                throw _iteratorError;

              case 93:
                return _context.finish(90);

              case 94:
                return _context.finish(87);

              case 95:

                // 初始化互动房间监听
                res = void 0;
                _context.prev = 96;
                connectOption = { attributes: attributes };
                _context.next = 100;
                return this._initCallListen(callOpt, connectOption);

              case 100:
                res = _context.sent;
                _context.next = 107;
                break;

              case 103:
                _context.prev = 103;
                _context.t5 = _context["catch"](96);

                failure(_context.t5);
                return _context.abrupt("return");

              case 107:
                _res = res, currentStreams = _res.currentStreams, streamIdArr = _res.streamIdArr, isConfigRoomBroadCast = _res.isConfigRoomBroadCast;
                broadCast = null;
                //自动配置旁路

                if (!(autoStartBroadcast && !isConfigRoomBroadCast && role === _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_HOST && broadcastConfig !== {})) {
                  _context.next = 120;
                  break;
                }

                _context.prev = 110;
                _context.next = 113;
                return this.roomApi.startBroadCast(broadcastConfig);

              case 113:
                res = _context.sent;
                _context.next = 120;
                break;

              case 116:
                _context.prev = 116;
                _context.t6 = _context["catch"](110);

                broadCast = _context.t6;
                console.log("warning: autoStartBroadcast failed!", _context.t6);

              case 120:

                // 监听房间及流事件
                this._initMsgListen();

                vhallrtc = {};

                Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["mixinInst"])(vhallrtc, this.roomApi);
                Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["mixin"])(vhallrtc, _biz_call_StaticFnc__WEBPACK_IMPORTED_MODULE_17__["default"], this);
                Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["mixin"])(vhallrtc, _biz_call_MsgRoom__WEBPACK_IMPORTED_MODULE_13__["default"], this);
                Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["mixin"])(vhallrtc, _biz_call_StreamsApi__WEBPACK_IMPORTED_MODULE_15__["default"], this);
                Object(_tools_Utils__WEBPACK_IMPORTED_MODULE_12__["mixin"])(vhallrtc, _biz_call_O2O__WEBPACK_IMPORTED_MODULE_14__["default"], this);
                this.vhallrtc = vhallrtc;
                // streams 向下兼容
                success({ vhallrtc: vhallrtc, currentStreams: currentStreams, streams: streamIdArr, broadCast: broadCast });

              case 129:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[30, 35], [39, 45], [50, 56], [71, 83, 87, 95], [88,, 90, 94], [96, 103], [110, 116]]);
      }));

      function createInstance(_x) {
        return _ref.apply(this, arguments);
      }

      return createInstance;
    }()

    // 初始化消息房间监听

  }, {
    key: "_initMsgListen",
    value: function _initMsgListen() {
      var _this = this;

      this.msg.connect();

      this.msg.addEventListener("service_room", function (msg) {
        var data = JSON.parse(msg.data);
        switch (data.inav_event) {
          case "kick_inav":
            _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_BLACKLIST, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_BLACKLIST, data: { userId: data.third_party_user_id } });
            break;
          case "apply_inav_publish":
            // 申请上麦
            _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_APPLY, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_APPLY, data: { userId: data.third_party_user_id } });
            break;
          case "audit_inav_publish":
            // 审核申请上麦    1 上麦 2 下麦 3拒绝上麦
            _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_AUTH, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_AUTH, data: { userId: data.third_party_user_id, status: data.status } });
            break;
          case "askfor_inav_publish":
            //  被邀请上麦
            _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_INVITED, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_INVITED, data: { userId: data.third_party_user_id, sendId: msg.sender_id } });
            break;
          case "user_publish_callback":
            // 邀请上麦回复消息
            _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_CALLBACK, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_CALLBACK, data: { userId: data.third_party_user_id, status: data.status } });
            break;
          case "inav_close":
            // 关闭互动房间事件
            _this.vhallrtc.destroyInstance();
            break;
          case "force_leave_inav":
            // 强行踢出房间事件
            if (data.third_party_user_id === _this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ACCOUNTID)) {
              _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_FORCELEAVE, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_FORCELEAVE, data: { userId: data.third_party_user_id } });
              _this.vhallrtc.destroyInstance();
            }
            break;
        }
      });
    }

    // 初始化互动房间监听

  }, {
    key: "_initCallListen",
    value: function () {
      var _ref2 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee4(opt, connectOption) {
        var _this2 = this;

        var connectRes, isConfigRoomBroadCast, streamIdArr, currentStreams, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, stream, userId;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.roomApi = new _biz_call_RoomApi__WEBPACK_IMPORTED_MODULE_16__["default"](opt, this);

                this.roomApi.addEventListener("network-change", function (event) {
                  _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_NETWORK_CHANGE, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_NETWORK_CHANGE, data: event.message });
                });

                this.roomApi.addEventListener("enter-room", function () {
                  var _ref3 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee2(event) {
                    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!_this2.roomInfo.getRemoteMap(event.msg.id)) {
                              _context2.next = 2;
                              break;
                            }

                            return _context2.abrupt("return");

                          case 2:
                            if (!_this2.roomInfo.getLocalMap(event.msg.id)) _this2.roomInfo.setRemoteMap(event.msg.id);
                            _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_JOIN, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_JOIN, data: { userId: event.msg.id, attributes: event.msg.attributes } });

                          case 4:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, _this2);
                  }));

                  return function (_x6) {
                    return _ref3.apply(this, arguments);
                  };
                }());

                this.roomApi.addEventListener("quit-room", function (event) {
                  if (!_this2.roomInfo.getRemoteMap(event.msg.id)) {
                    return;
                  }
                  _this2.roomInfo.removeRemoteMap(event.msg.id);
                  _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_LEAVE, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_LEAVE, data: { userId: event.msg.id, attributes: event.msg.attributes } });
                });

                this.roomApi.addEventListener("device-change", function () {
                  _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_DEVICE_CHANGE, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_DEVICE_CHANGE, data: {} });
                });

                this.roomApi.addEventListener("room-stream-mute", function (event) {
                  var _event$msg = event.msg,
                      id = _event$msg.id,
                      config = _event$msg.config;
                  var muteStream = config.muteStream;
                  //todo: filter localStream, like stream-added

                  _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_MUTE, {
                    event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_MUTE,
                    data: {
                      stream: event.stream,
                      streamId: id,
                      muteStream: muteStream,
                      accountId: event.stream.getUserId(),
                      streamType: event.stream.streamType,
                      attributes: event.stream.getAttributes()
                    }
                  });
                });

                this.roomApi.addEventListener("room-disconnected", function (event) {
                  var status = event.message;
                  switch (status) {
                    //todo: no need "expected-disconnection"
                    case "expected-disconnection":
                      // 正常断开房间
                      _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_DISCONNECTED, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_DISCONNECTED, data: {} });
                      break;
                    case "unexpected-disconnection":
                      // 异常断开房间
                      _this2.msg.destroy();
                      _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_EXCDISCONNECTED, { event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_ROOM_EXCDISCONNECTED, data: {} });
                      break;
                  }
                });

                this.roomApi.addEventListener("stream-failed", function (event) {
                  var streamId = event.stream.getID();
                  _common_Contant__WEBPACK_IMPORTED_MODULE_9__["localStreamMap"].delete(streamId);
                  _common_Contant__WEBPACK_IMPORTED_MODULE_9__["streamObjMap"].delete(streamId);
                  _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_FAILED, {
                    event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_FAILED,
                    data: babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_1___default()({}, event, {
                      streamId: event.stream.getID(),
                      accountId: event.stream.getUserId(),
                      streamType: event.stream.streamType,
                      attributes: event.stream.getAttributes()
                    })
                  });
                });

                this.roomApi.addEventListener("stream-added", function () {
                  var _ref4 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee3(streamEvt) {
                    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!_common_Contant__WEBPACK_IMPORTED_MODULE_9__["localStreamMap"].has(streamEvt.stream.getID())) {
                              _context3.next = 2;
                              break;
                            }

                            return _context3.abrupt("return");

                          case 2:
                            _common_Contant__WEBPACK_IMPORTED_MODULE_9__["streamObjMap"].set(streamEvt.stream.getID(), streamEvt.stream);

                            // 检测添加流的用户ID，是否存在Map中
                            if (!_this2.roomInfo.getRemoteMap(streamEvt.stream.getUserId())) {
                              _this2.roomInfo.setRemoteMap(streamEvt.stream.getUserId());
                            }
                            _this2.roomInfo.addRemoteStream(streamEvt.stream.getUserId(), {
                              streamId: streamEvt.stream.getID(),
                              status: 0,
                              type: streamEvt.stream.local ? "local" : "remote",
                              streamType: streamEvt.stream.streamType,
                              attributes: streamEvt.stream.getAttributes(),
                              audioMuted: streamEvt.stream.audioMuted,
                              videoMuted: streamEvt.stream.videoMuted
                            });

                            _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_ADD, {
                              event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_ADD,
                              data: {
                                stream: streamEvt.stream,
                                streamId: streamEvt.stream.getID(),
                                accountId: streamEvt.stream.getUserId(),
                                streamType: streamEvt.stream.streamType,
                                attributes: streamEvt.stream.getAttributes()
                              }
                            });

                          case 6:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, _this2);
                  }));

                  return function (_x7) {
                    return _ref4.apply(this, arguments);
                  };
                }());

                this.roomApi.addEventListener("stream-removed", function (streamEvt) {
                  var userId = streamEvt.stream.getUserId();
                  var streamId = streamEvt.stream.getID();

                  _common_Contant__WEBPACK_IMPORTED_MODULE_9__["localStreamMap"].delete(streamId);
                  _common_Contant__WEBPACK_IMPORTED_MODULE_9__["streamObjMap"].delete(streamId);
                  _this2.roomInfo.removeRemoteStream(userId, streamId);
                  _this2.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_REMOVED, {
                    event: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_REMOTESTREAM_REMOVED, data: {
                      stream: streamEvt.stream,
                      streamId: streamId,
                      accountId: userId,
                      streamType: streamEvt.stream.streamType,
                      attributes: streamEvt.stream.getAttributes()
                    }
                  });
                });

                // 实例化互动房间处理类并连接互动房间
                connectRes = void 0;
                _context4.prev = 11;
                _context4.next = 14;
                return this.roomApi._connect(connectOption);

              case 14:
                connectRes = _context4.sent;
                _context4.next = 20;
                break;

              case 17:
                _context4.prev = 17;
                _context4.t0 = _context4["catch"](11);
                return _context4.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject({ code: "", message: "连接互动房间失败", data: {} }));

              case 20:

                // 返回当前流数据给用户
                isConfigRoomBroadCast = connectRes["isConfigRoomBroadCast"];
                streamIdArr = [];
                currentStreams = [];
                // const arr = [];

                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context4.prev = 26;
                for (_iterator2 = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_3___default()(connectRes["streams"]); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  stream = _step2.value;
                  userId = stream.getUserId();

                  // 将房间内的流存起来

                  _common_Contant__WEBPACK_IMPORTED_MODULE_9__["streamObjMap"].set(stream.getID(), stream);

                  // 当前房间流ID列表
                  currentStreams.push({
                    streamId: stream.getID(),
                    accountId: userId,
                    streamType: stream.streamType,
                    attributes: stream.getAttributes()
                  });

                  // 当前房间流ID列表
                  streamIdArr.push(stream.getID());

                  if (!this.roomInfo.getRemoteMap(userId)) {
                    this.roomInfo.setRemoteMap(userId);
                  }

                  this.roomInfo.addRemoteStream(userId, {
                    streamId: stream.getID(),
                    status: 0,
                    type: stream.local ? "local" : "remote",
                    streamType: stream.streamType,
                    attributes: stream.getAttributes(),
                    audioMuted: stream.audioMuted,
                    videoMuted: stream.videoMuted
                  });
                }

                _context4.next = 34;
                break;

              case 30:
                _context4.prev = 30;
                _context4.t1 = _context4["catch"](26);
                _didIteratorError2 = true;
                _iteratorError2 = _context4.t1;

              case 34:
                _context4.prev = 34;
                _context4.prev = 35;

                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }

              case 37:
                _context4.prev = 37;

                if (!_didIteratorError2) {
                  _context4.next = 40;
                  break;
                }

                throw _iteratorError2;

              case 40:
                return _context4.finish(37);

              case 41:
                return _context4.finish(34);

              case 42:
                return _context4.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.resolve({ currentStreams: currentStreams, streamIdArr: streamIdArr, isConfigRoomBroadCast: isConfigRoomBroadCast }));

              case 43:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[11, 17], [26, 30, 34, 42], [35,, 37, 41]]);
      }));

      function _initCallListen(_x4, _x5) {
        return _ref2.apply(this, arguments);
      }

      return _initCallListen;
    }()
  }]);

  return VhallRTC;
}())();

/***/ }),

/***/ "./src/biz/call/MsgRoom.js":
/*!*********************************!*\
  !*** ./src/biz/call/MsgRoom.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/Contant */ "./src/common/Contant.js");
/* harmony import */ var _server_API__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../server/API */ "./src/server/API.js");









/**
 * 消息房间类 （邀请上麦，申请上麦等）
 *
 * @class MsgRoom
 */

var MsgRoom = function () {
  function MsgRoom(app) {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default()(this, MsgRoom);

    this.msg = app.msg;
    this.store = app.store;
    this.api = new _server_API__WEBPACK_IMPORTED_MODULE_7__["default"](app.store);
    this.roomInfo = app.roomInfo;
    this.events = app.events;
  }

  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(MsgRoom, [{
    key: "on",
    value: function on(event, handler) {
      this.events.addEventListener(event, handler);
    }
  }, {
    key: "off",
    value: function off(event, handler) {
      this.events.removeEventListener(event, handler);
    }
  }, {
    key: "once",
    value: function once(event, handler) {
      this.events.once(event, handler);
    }
  }, {
    key: "getRoomInfo",
    value: function getRoomInfo() {
      return this.roomInfo.getRoomInfo();
    }
  }, {
    key: "getRoomStreams",
    value: function getRoomStreams() {
      return this.roomInfo.getRoomStreams();
    }

    /**
      * 获取当前互动房间用户列表
      * @param {object} opt 预留参数
      * @param {function} success 成功回调
      * @param {function} failure 失败回调
      */

  }, {
    key: "getUserList",
    value: function () {
      var _ref = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(opt, success, failure) {
        var errInfo, res, _errInfo;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object")) {
                  _context.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                res = void 0;
                _context.prev = 4;
                _context.next = 7;
                return this.api.getInavUserlist(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID));

              case 7:
                res = _context.sent;
                _context.next = 14;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](4);
                _errInfo = { code: "611026", message: "获取当前用户列表失败", data: {} };
                return _context.abrupt("return", failure ? failure(_errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo));

              case 14:
                return _context.abrupt("return", success ? success(res) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(res));

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 10]]);
      }));

      function getUserList(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      }

      return getUserList;
    }()

    /**
     * 同意申请上麦
     * @param {object} opt 同意上麦的用户ID
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "consentApply",
    value: function () {
      var _ref2 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(opt, success, failure) {
        var errInfo, _errInfo2;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object" || !opt.userId)) {
                  _context2.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context2.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context2.prev = 3;
                _context2.next = 6;
                return this.api.auditInavPublish({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), userId: opt.userId, type: 1 });

              case 6:
                _context2.next = 12;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](3);
                _errInfo2 = { code: "611019", message: "同意申请上麦失败", data: {} };
                return _context2.abrupt("return", failure ? failure(_errInfo2) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo2));

              case 12:
                return _context2.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 8]]);
      }));

      function consentApply(_x4, _x5, _x6) {
        return _ref2.apply(this, arguments);
      }

      return consentApply;
    }()

    /**
    * 拒绝申请上麦
    * @param {object} opt 拒绝上麦的用户ID
    * @param {function} success 成功回调
    * @param {function} failure 失败回调
    */

  }, {
    key: "rejectApply",
    value: function () {
      var _ref3 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(opt, success, failure) {
        var errInfo, _errInfo3;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object" || !opt.userId)) {
                  _context3.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context3.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context3.prev = 3;
                _context3.next = 6;
                return this.api.auditInavPublish({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), userId: opt.userId, type: 2 });

              case 6:
                _context3.next = 12;
                break;

              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](3);
                _errInfo3 = { code: "611020", message: "拒绝申请上麦失败", data: {} };
                return _context3.abrupt("return", failure ? failure(_errInfo3) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo3));

              case 12:
                return _context3.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[3, 8]]);
      }));

      function rejectApply(_x7, _x8, _x9) {
        return _ref3.apply(this, arguments);
      }

      return rejectApply;
    }()

    /**
     * 邀请上麦
     * @param {object} opt 用户ID
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "invite",
    value: function () {
      var _ref4 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4(opt, success, failure) {
        var errInfo, _errInfo4;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object" || !opt.userId)) {
                  _context4.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context4.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context4.prev = 3;
                _context4.next = 6;
                return this.api.askforInavPublish({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), userId: opt.userId });

              case 6:
                _context4.next = 12;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](3);
                _errInfo4 = { code: "611021", message: "邀请上麦失败", data: {} };
                return _context4.abrupt("return", failure ? failure(_errInfo4) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo4));

              case 12:
                return _context4.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 8]]);
      }));

      function invite(_x10, _x11, _x12) {
        return _ref4.apply(this, arguments);
      }

      return invite;
    }()

    /**
     * 同意被邀请上麦
     * @param opt
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "consentInvite",
    value: function () {
      var _ref5 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee5(opt, success, failure) {
        var errInfo, _errInfo5;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object")) {
                  _context5.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context5.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context5.prev = 3;
                _context5.next = 6;
                return this.api.userPublishCallback({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), streamId: "", type: 1 });

              case 6:
                _context5.next = 12;
                break;

              case 8:
                _context5.prev = 8;
                _context5.t0 = _context5["catch"](3);
                _errInfo5 = { code: "611022", message: "同意被邀请上麦失败", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo5) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo5));

              case 12:
                return _context5.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[3, 8]]);
      }));

      function consentInvite(_x13, _x14, _x15) {
        return _ref5.apply(this, arguments);
      }

      return consentInvite;
    }()

    /**
     * 消息房间下麦
     * @param opt
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "unPublish",
    value: function () {
      var _ref6 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee6(success, failure) {
        var errInfo;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return this.api.userPublishCallback({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), streamId: "", type: 2 });

              case 3:
                _context6.next = 9;
                break;

              case 5:
                _context6.prev = 5;
                _context6.t0 = _context6["catch"](0);
                errInfo = { code: "611022", message: "下麦失败", data: {} };
                return _context6.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 9:
                return _context6.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 5]]);
      }));

      function unPublish(_x16, _x17) {
        return _ref6.apply(this, arguments);
      }

      return unPublish;
    }()

    /**
     * 拒绝被邀请上麦
     * @param opt
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "rejectInvite",
    value: function () {
      var _ref7 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee7(opt, success, failure) {
        var errInfo, _errInfo6;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object")) {
                  _context7.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context7.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context7.prev = 3;
                _context7.next = 6;
                return this.api.userPublishCallback({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), streamId: "", type: 3 });

              case 6:
                _context7.next = 12;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);
                _errInfo6 = { code: "611023", message: "拒绝被邀请上麦失败", data: {} };
                return _context7.abrupt("return", failure ? failure(_errInfo6) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo6));

              case 12:
                return _context7.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8]]);
      }));

      function rejectInvite(_x18, _x19, _x20) {
        return _ref7.apply(this, arguments);
      }

      return rejectInvite;
    }()

    /**
     * 申请上麦
     * @param {object} opt 申请上麦所需参数
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "apply",
    value: function () {
      var _ref8 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee8(opt, success, failure) {
        var errInfo, _errInfo7;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object")) {
                  _context8.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context8.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context8.prev = 3;
                _context8.next = 6;
                return this.api.applyInavPublish(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID));

              case 6:
                _context8.next = 12;
                break;

              case 8:
                _context8.prev = 8;
                _context8.t0 = _context8["catch"](3);
                _errInfo7 = { code: "611024", message: "申请上麦失败", data: {} };
                return _context8.abrupt("return", failure ? failure(_errInfo7) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo7));

              case 12:
                return _context8.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[3, 8]]);
      }));

      function apply(_x21, _x22, _x23) {
        return _ref8.apply(this, arguments);
      }

      return apply;
    }()

    /**
     * 获取互动被踢人列表（黑名单列表）
     * @param {object} opt 获取被提出人列表
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "getBlackList",
    value: function () {
      var _ref9 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee9(opt, success, failure) {
        var errInfo, res, _errInfo8;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object")) {
                  _context9.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context9.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                res = void 0;
                _context9.prev = 4;
                _context9.next = 7;
                return this.api.getKickList(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID));

              case 7:
                res = _context9.sent;
                _context9.next = 14;
                break;

              case 10:
                _context9.prev = 10;
                _context9.t0 = _context9["catch"](4);
                _errInfo8 = { code: "611025", message: "获取黑名单列表失败", data: {} };
                return _context9.abrupt("return", failure ? failure(_errInfo8) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo8));

              case 14:
                return _context9.abrupt("return", success ? success(res.lists) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(res.lists));

              case 15:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[4, 10]]);
      }));

      function getBlackList(_x24, _x25, _x26) {
        return _ref9.apply(this, arguments);
      }

      return getBlackList;
    }()

    /**
     * 将用户添加到黑名单
     * @param {object} opt 用户id
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "addBlackList",
    value: function () {
      var _ref10 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee10(opt, success, failure) {
        var errInfo, _errInfo9;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object" || !opt.userId)) {
                  _context10.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context10.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context10.prev = 3;
                _context10.next = 6;
                return this.api.kickInav({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), userId: opt.userId, type: 1 });

              case 6:
                _context10.next = 12;
                break;

              case 8:
                _context10.prev = 8;
                _context10.t0 = _context10["catch"](3);
                _errInfo9 = { code: "611027", message: "添加用户进黑名单失败", data: {} };
                return _context10.abrupt("return", failure ? failure(_errInfo9) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo9));

              case 12:
                return _context10.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[3, 8]]);
      }));

      function addBlackList(_x27, _x28, _x29) {
        return _ref10.apply(this, arguments);
      }

      return addBlackList;
    }()

    /**
     * 将用户从黑名单移除
     * @param {object} opt 用户id
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "removeBlackList",
    value: function () {
      var _ref11 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee11(opt, success, failure) {
        var errInfo, _errInfo10;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_2___default()(opt)) !== "object" || !opt.userId)) {
                  _context11.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context11.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(errInfo));

              case 3:
                _context11.prev = 3;
                _context11.next = 6;
                return this.api.kickInav({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["KV"].INAVID), userId: opt.userId, type: 2 });

              case 6:
                _context11.next = 12;
                break;

              case 8:
                _context11.prev = 8;
                _context11.t0 = _context11["catch"](3);
                _errInfo10 = { code: "611028", message: "移除黑名单用户失败", data: {} };
                return _context11.abrupt("return", failure ? failure(_errInfo10) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.reject(_errInfo10));

              case 12:
                return _context11.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_1___default.a.resolve());

              case 13:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[3, 8]]);
      }));

      function removeBlackList(_x30, _x31, _x32) {
        return _ref11.apply(this, arguments);
      }

      return removeBlackList;
    }()
  }]);

  return MsgRoom;
}();

/* harmony default export */ __webpack_exports__["default"] = (MsgRoom);

/***/ }),

/***/ "./src/biz/call/O2O.js":
/*!*****************************!*\
  !*** ./src/biz/call/O2O.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return O2O; });
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-runtime/core-js/map */ "./node_modules/babel-runtime/core-js/map.js");
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/Contant */ "./src/common/Contant.js");
/* harmony import */ var _StreamsApi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./StreamsApi */ "./src/biz/call/StreamsApi.js");
/* harmony import */ var _MsgRoom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MsgRoom */ "./src/biz/call/MsgRoom.js");










var O2O = function () {
  function O2O(app) {
    var _this = this;

    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default()(this, O2O);

    this.roomApi = app.roomApi;
    this.streamApi = new _StreamsApi__WEBPACK_IMPORTED_MODULE_7__["default"](app);
    this.msgRoom = new _MsgRoom__WEBPACK_IMPORTED_MODULE_8__["default"](app);
    this.isInvite = false;
    this.streamMap = new babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_3___default.a();
    this.msgRoom.events.addEventListener(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["EVENT"].EVENT_ROOM_CALLBACK, function () {
      var _ref = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee(event) {
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(event.data.status !== 2)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                _context.prev = 2;
                _context.next = 5;
                return _this.streamApi.destroyStream({ streamId: _this.localStreamId });

              case 5:
                _context.next = 9;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](2);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, _this, [[2, 7]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()
    // console.error(error)
    );

    this.msgRoom.events.addEventListener(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["EVENT"].EVENT_ROOM_LEAVE, function () {
      var _ref2 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2(event) {
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(_this.userId !== event.data.userId)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return _this.roomApi.unpublish({ streamId: _this.localStreamId });

              case 5:
                _context2.next = 9;
                break;

              case 7:
                _context2.prev = 7;
                _context2.t0 = _context2["catch"](2);

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, _this, [[2, 7]]);
      }));

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }()
    // console.error(error)
    );
  }

  //邀请


  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(O2O, [{
    key: "OTOCall",
    value: function () {
      var _ref3 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee5(params, success, failure) {
        var _this2 = this;

        var _params$userId, userId, _params$remoteNode, remoteNode, _params$localStreamOp, localStreamOpt, addStreamHandle;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _params$userId = params.userId, userId = _params$userId === undefined ? "" : _params$userId, _params$remoteNode = params.remoteNode, remoteNode = _params$remoteNode === undefined ? "" : _params$remoteNode, _params$localStreamOp = params.localStreamOpt, localStreamOpt = _params$localStreamOp === undefined ? {} : _params$localStreamOp;

                this.userId = userId;
                _context5.prev = 2;
                _context5.next = 5;
                return this._createStream(localStreamOpt);

              case 5:
                _context5.next = 10;
                break;

              case 7:
                _context5.prev = 7;
                _context5.t0 = _context5["catch"](2);
                return _context5.abrupt("return", failure ? failure(_context5.t0) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context5.t0));

              case 10:
                _context5.prev = 10;
                _context5.next = 13;
                return this.msgRoom.invite({ userId: userId });

              case 13:
                _context5.next = 22;
                break;

              case 15:
                _context5.prev = 15;
                _context5.t1 = _context5["catch"](10);
                _context5.t2 = this.localStreamId;

                if (!_context5.t2) {
                  _context5.next = 21;
                  break;
                }

                _context5.next = 21;
                return this.streamApi.destroyStream({ streamId: this.localStreamId });

              case 21:
                return _context5.abrupt("return", failure ? failure(_context5.t1) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context5.t1));

              case 22:
                addStreamHandle = function () {
                  var _ref4 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee3(event) {
                    var streamId;
                    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!(userId !== event.data.accountId)) {
                              _context3.next = 2;
                              break;
                            }

                            return _context3.abrupt("return");

                          case 2:
                            streamId = event.data.streamId;
                            _context3.prev = 3;
                            _context3.next = 6;
                            return _this2.roomApi.subscribe({ streamId: streamId, videoNode: remoteNode });

                          case 6:
                            _context3.next = 10;
                            break;

                          case 8:
                            _context3.prev = 8;
                            _context3.t0 = _context3["catch"](3);

                          case 10:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, _this2, [[3, 8]]);
                  }));

                  return function addStreamHandle(_x6) {
                    return _ref4.apply(this, arguments);
                  };
                }();

                this.msgRoom.events.once(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["EVENT"].EVENT_REMOTESTREAM_ADD, addStreamHandle);

                this.msgRoom.once(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["EVENT"].EVENT_ROOM_CALLBACK, function () {
                  var _ref5 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee4(res) {
                    var errInfo;
                    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.t0 = res.data.status;
                            _context4.next = _context4.t0 === 1 ? 3 : _context4.t0 === 3 ? 12 : 19;
                            break;

                          case 3:
                            _context4.prev = 3;
                            _context4.next = 6;
                            return _this2._pushStream(localStreamOpt);

                          case 6:
                            _context4.next = 11;
                            break;

                          case 8:
                            _context4.prev = 8;
                            _context4.t1 = _context4["catch"](3);
                            return _context4.abrupt("return", failure ? failure(_context4.t1) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context4.t1));

                          case 11:
                            return _context4.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.resolve());

                          case 12:
                            _this2.msgRoom.events.removeOnceListener(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["EVENT"].EVENT_REMOTESTREAM_ADD, addStreamHandle);
                            _context4.t2 = _this2.localStreamId;

                            if (!_context4.t2) {
                              _context4.next = 17;
                              break;
                            }

                            _context4.next = 17;
                            return _this2.streamApi.destroyStream({ streamId: _this2.localStreamId });

                          case 17:
                            errInfo = { code: "", message: "发起失败，用户拒绝", data: {} };
                            return _context4.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(errInfo));

                          case 19:
                            return _context4.abrupt("break", 20);

                          case 20:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, _this2, [[3, 8]]);
                  }));

                  return function (_x7) {
                    return _ref5.apply(this, arguments);
                  };
                }());

              case 25:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[2, 7], [10, 15]]);
      }));

      function OTOCall(_x3, _x4, _x5) {
        return _ref3.apply(this, arguments);
      }

      return OTOCall;
    }()
  }, {
    key: "OTOAnwser",
    value: function () {
      var _ref6 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee7(params, success, failure) {
        var _this3 = this;

        var isConsent, _params$remoteNode2, remoteNode, _params$userId2, userId, _params$localStreamOp2, localStreamOpt, addStreamHandle;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                isConsent = params.isConsent, _params$remoteNode2 = params.remoteNode, remoteNode = _params$remoteNode2 === undefined ? "" : _params$remoteNode2, _params$userId2 = params.userId, userId = _params$userId2 === undefined ? "" : _params$userId2, _params$localStreamOp2 = params.localStreamOpt, localStreamOpt = _params$localStreamOp2 === undefined ? {} : _params$localStreamOp2;

                this.userId = userId;

                addStreamHandle = function () {
                  var _ref7 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee6(event) {
                    var streamId;
                    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            if (!(userId !== event.data.accountId)) {
                              _context6.next = 2;
                              break;
                            }

                            return _context6.abrupt("return");

                          case 2:
                            streamId = event.data.streamId;
                            _context6.prev = 3;
                            _context6.next = 6;
                            return _this3.roomApi.subscribe({ streamId: streamId, videoNode: remoteNode });

                          case 6:
                            _context6.next = 10;
                            break;

                          case 8:
                            _context6.prev = 8;
                            _context6.t0 = _context6["catch"](3);

                          case 10:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6, _this3, [[3, 8]]);
                  }));

                  return function addStreamHandle(_x11) {
                    return _ref7.apply(this, arguments);
                  };
                }();

                this.msgRoom.once(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["EVENT"].EVENT_REMOTESTREAM_ADD, addStreamHandle);

                if (!isConsent) {
                  _context7.next = 40;
                  break;
                }

                _context7.prev = 5;
                _context7.next = 8;
                return this._createStream(localStreamOpt);

              case 8:
                _context7.next = 15;
                break;

              case 10:
                _context7.prev = 10;
                _context7.t0 = _context7["catch"](5);
                _context7.next = 14;
                return this.msgRoom.rejectInvite({});

              case 14:
                return _context7.abrupt("return", failure ? failure(_context7.t0) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context7.t0));

              case 15:
                _context7.prev = 15;
                _context7.next = 18;
                return this._pushStream(localStreamOpt);

              case 18:
                _context7.next = 25;
                break;

              case 20:
                _context7.prev = 20;
                _context7.t1 = _context7["catch"](15);
                _context7.next = 24;
                return this.msgRoom.rejectInvite({});

              case 24:
                return _context7.abrupt("return", failure ? failure(_context7.t1) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context7.t1));

              case 25:
                _context7.prev = 25;
                _context7.next = 28;
                return this.msgRoom.consentInvite({});

              case 28:
                _context7.next = 37;
                break;

              case 30:
                _context7.prev = 30;
                _context7.t2 = _context7["catch"](25);
                _context7.t3 = this.localStreamId;

                if (!_context7.t3) {
                  _context7.next = 36;
                  break;
                }

                _context7.next = 36;
                return this.streamApi.destroyStream({ streamId: this.localStreamId });

              case 36:
                return _context7.abrupt("return", failure ? failure(_context7.t2) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context7.t2));

              case 37:
                return _context7.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.resolve());

              case 40:
                _context7.prev = 40;
                _context7.next = 43;
                return this.msgRoom.rejectInvite({});

              case 43:
                _context7.next = 48;
                break;

              case 45:
                _context7.prev = 45;
                _context7.t4 = _context7["catch"](40);
                return _context7.abrupt("return", failure ? failure(_context7.t4) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context7.t4));

              case 48:
                this.msgRoom.events.removeOnceListener(_common_Contant__WEBPACK_IMPORTED_MODULE_6__["EVENT"].EVENT_REMOTESTREAM_ADD, addStreamHandle);
                return _context7.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.resolve());

              case 50:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[5, 10], [15, 20], [25, 30], [40, 45]]);
      }));

      function OTOAnwser(_x8, _x9, _x10) {
        return _ref6.apply(this, arguments);
      }

      return OTOAnwser;
    }()

    // 挂断

  }, {
    key: "OTOHangUp",
    value: function () {
      var _ref8 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee8(success, failure) {
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return this.roomApi.unpublish({ streamId: this.localStreamId });

              case 3:
                _context8.next = 8;
                break;

              case 5:
                _context8.prev = 5;
                _context8.t0 = _context8["catch"](0);
                return _context8.abrupt("return", failure ? failure(_context8.t0) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context8.t0));

              case 8:
                return _context8.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.resolve());

              case 9:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 5]]);
      }));

      function OTOHangUp(_x12, _x13) {
        return _ref8.apply(this, arguments);
      }

      return OTOHangUp;
    }()

    // 创建本地流并推送

  }, {
    key: "_pushStream",
    value: function () {
      var _ref9 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee9() {
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return this.roomApi.publish({ streamId: this.localStreamId });

              case 3:
                _context9.next = 9;
                break;

              case 5:
                _context9.prev = 5;
                _context9.t0 = _context9["catch"](0);

                console.warn("一对一视频，推流失败");
                return _context9.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context9.t0));

              case 9:
                return _context9.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.resolve());

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[0, 5]]);
      }));

      function _pushStream() {
        return _ref9.apply(this, arguments);
      }

      return _pushStream;
    }()
  }, {
    key: "_createStream",
    value: function () {
      var _ref10 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee10(localStreamOpt) {
        var streamId, res;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                streamId = void 0;
                _context10.prev = 1;
                _context10.next = 4;
                return this.streamApi.createStream(localStreamOpt);

              case 4:
                res = _context10.sent;

                streamId = res.streamId;
                this.localStreamId = res.streamId;
                _context10.next = 13;
                break;

              case 9:
                _context10.prev = 9;
                _context10.t0 = _context10["catch"](1);

                console.warn("一对一视频，创建本地流失败");
                return _context10.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.reject(_context10.t0));

              case 13:
                return _context10.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(streamId));

              case 14:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[1, 9]]);
      }));

      function _createStream(_x14) {
        return _ref10.apply(this, arguments);
      }

      return _createStream;
    }()
  }]);

  return O2O;
}();



/***/ }),

/***/ "./src/biz/call/RoomApi.js":
/*!*********************************!*\
  !*** ./src/biz/call/RoomApi.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RoomApi; });
/* harmony import */ var babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");
/* harmony import */ var babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ "./node_modules/babel-runtime/core-js/get-iterator.js");
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../rtcbase/src/Main */ "./rtcbase/src/Main.js");
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/Contant */ "./src/common/Contant.js");











var RoomApi = function () {
  function RoomApi(opt, app) {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6___default()(this, RoomApi);

    this.room = _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_8__["default"].vhallcall.Room(opt);
    this.events = app.events;
    this.msg = app.msg;
    this.api = app.api;
    this.store = app.store;
    this.roomInfo = app.roomInfo;
    this.streamObjMap = _common_Contant__WEBPACK_IMPORTED_MODULE_9__["streamObjMap"];
    this.localStreamMap = _common_Contant__WEBPACK_IMPORTED_MODULE_9__["localStreamMap"];
  }

  /**
   * 销毁实例
   * @param {object} opt 销毁参数
   * @param {function} success 成功回调
   * @param {function} failure 失败回调
   */
  // eslint-disable-next-line no-unused-vars


  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7___default()(RoomApi, [{
    key: "destroyInstance",
    value: function destroyInstance() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var success = arguments[1];
      var failure = arguments[2];

      // 销毁所有流（包括本地和远端）。
      this.localStreamMap.forEach(function (value) {
        value.close("vhallyun-destroyInstance");
      });
      this.localStreamMap.clear();
      this.streamObjMap.clear();
      this.roomInfo.clearLocalMap();
      this.roomInfo.clearRemoteMap();
      // todo: room.disconnect()也会销毁所有流
      this.room.disconnect();
      this.msg.destroy();
      this.events.removeAllListener();
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve();
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(event, handler) {
      this.room.addEventListener(event, handler);
    }

    /**
     * 链接房间
     */

  }, {
    key: "_connect",
    value: function _connect(options) {
      return this.room.connect(options);
    }

    /**
     * 房间断开
     * todo: 未使用，可删除
     */

  }, {
    key: "_disconnect",
    value: function _disconnect() {
      return this.room.disconnect();
    }

    /**
     * 互动推流
     * @param {object} opt 推送本地流所需参数
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "publish",
    value: function () {
      var _ref = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var success = arguments[1];
        var failure = arguments[2];

        var hasPermission, _result, errInfo, _errInfo, localStream, res, _errInfo2, streams, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, stream, result;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId"))) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (this.localStreamMap.get(opt.streamId)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST));

              case 4:
                hasPermission = null;
                _context.prev = 5;
                _context.next = 8;
                return this.api.getTokenPermission(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID), "publish_inav_stream");

              case 8:
                _result = _context.sent;

                hasPermission = _result.has_permission;
                _context.next = 16;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](5);
                errInfo = { code: "611009", message: "权限验证失败", data: { error: _context.t0 } };
                return _context.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 16:
                if (!(hasPermission !== 1)) {
                  _context.next = 19;
                  break;
                }

                _errInfo = { code: "611007", message: "没有推流权限", data: {} };
                return _context.abrupt("return", failure ? failure(_errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo));

              case 19:
                localStream = this.localStreamMap.get(opt.streamId);
                res = void 0;
                _context.prev = 21;
                _context.next = 24;
                return this.room.publish(localStream, { mix: true });

              case 24:
                res = _context.sent;
                _context.next = 32;
                break;

              case 27:
                _context.prev = 27;
                _context.t1 = _context["catch"](21);
                _errInfo2 = { code: "611007", message: "推流失败", data: { error: _context.t1 } };

                if (_context.t1 === "no permission") {
                  _errInfo2 = { code: "611007", message: "没有推流权限", data: { error: _context.t1 } };
                }
                return _context.abrupt("return", failure ? failure(_errInfo2) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo2));

              case 32:

                // 推流成功后改变roomInfo 状态
                streams = this.roomInfo.getLocalMap(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ACCOUNTID));
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context.prev = 36;

                for (_iterator = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_2___default()(streams); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  stream = _step.value;

                  if (stream.streamId === opt.streamId) {
                    stream.state = 1;
                  }
                }

                _context.next = 44;
                break;

              case 40:
                _context.prev = 40;
                _context.t2 = _context["catch"](36);
                _didIteratorError = true;
                _iteratorError = _context.t2;

              case 44:
                _context.prev = 44;
                _context.prev = 45;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 47:
                _context.prev = 47;

                if (!_didIteratorError) {
                  _context.next = 50;
                  break;
                }

                throw _iteratorError;

              case 50:
                return _context.finish(47);

              case 51:
                return _context.finish(44);

              case 52:
                result = { streamId: res.getID() };
                return _context.abrupt("return", success ? success(result) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve(result));

              case 54:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[5, 12], [21, 27], [36, 40, 44, 52], [45,, 47, 51]]);
      }));

      function publish() {
        return _ref.apply(this, arguments);
      }

      return publish;
    }()

    /**
    * 停止互动推流
    * @param {object} opt 停止推送流所需参数
    * @param {function} success 成功回调
    * @param {function} failure 失败回调
    */

  }, {
    key: "unpublish",
    value: function () {
      var _ref2 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2(opt, success, failure) {
        var localStream, errInfo, _errInfo3;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId"))) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (this.localStreamMap.get(opt.streamId)) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST));

              case 4:
                localStream = this.localStreamMap.get(opt.streamId);
                _context2.prev = 5;
                _context2.next = 8;
                return this.room.unpublish(localStream);

              case 8:
                _context2.next = 14;
                break;

              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](5);
                errInfo = { code: "611010", message: "停止推流失败", data: { error: _context2.t0 } };
                return _context2.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 14:
                _context2.prev = 14;
                _context2.next = 17;
                return this.api.userPublishCallback({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID), streamId: "", type: 2 });

              case 17:
                _context2.next = 23;
                break;

              case 19:
                _context2.prev = 19;
                _context2.t1 = _context2["catch"](14);
                _errInfo3 = { code: "611010", message: "停止推流失败", data: { error: _context2.t1 } };
                return _context2.abrupt("return", failure ? failure(_errInfo3) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo3));

              case 23:

                _common_Contant__WEBPACK_IMPORTED_MODULE_9__["localStreamMap"].delete(opt.streamId);
                _common_Contant__WEBPACK_IMPORTED_MODULE_9__["streamObjMap"].delete(opt.streamId);
                // 成功后修改roomInfo 信息

                if (this.roomInfo.getLocalMap(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ACCOUNTID))) {
                  _context2.next = 27;
                  break;
                }

                return _context2.abrupt("return");

              case 27:
                this.roomInfo.removeLocalStream(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ACCOUNTID), opt.streamId);
                // this.roomInfo.setLocalMap(this.store.getKV(KV.ACCOUNTID));

                return _context2.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 29:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 10], [14, 19]]);
      }));

      function unpublish(_x3, _x4, _x5) {
        return _ref2.apply(this, arguments);
      }

      return unpublish;
    }()
    /**
    * 订阅远端流
    * @param {object} opt 订阅远端流所需参数
    * @param {function} success 成功回调
    * @param {function} failure 失败回调
    */

  }, {
    key: "subscribe",
    value: function () {
      var _ref3 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee3() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var _this = this;

        var success = arguments[1];
        var failure = arguments[2];

        var stream, mute, dual, resStream, errInfo, users, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, item, result;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId") || !opt.hasOwnProperty("videoNode"))) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (document.getElementById(opt.videoNode)) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_DOM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_DOM_NOT_EXIST));

              case 4:
                if (this.streamObjMap.get(opt.streamId)) {
                  _context3.next = 6;
                  break;
                }

                return _context3.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST));

              case 6:
                stream = this.streamObjMap.get(opt.streamId);
                mute = opt.mute || { audio: false, video: false };
                dual = 1;

                if (opt.dual === 0) {
                  dual = 0;
                }

                stream.hasOwnProperty("audioMuted") && (stream.audioMuted = mute.audio);
                stream.hasOwnProperty("videoMuted") && (stream.videoMuted = mute.video);

                console.error("stream--------roomApi订阅------", stream);
                resStream = void 0;
                _context3.prev = 14;
                _context3.next = 17;
                return this.room.subscribe(stream, { dual: dual });

              case 17:
                resStream = _context3.sent;

                resStream.addEventListener("stream-play-abord", function (event) {
                  _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_STREAM_PLAYABORT, {
                    type: _common_Contant__WEBPACK_IMPORTED_MODULE_9__["EVENT"].EVENT_STREAM_PLAYABORT,
                    data: {
                      stream: event.stream,
                      streamId: event.stream.getID(),
                      accountId: event.stream.getUserId(),
                      streamType: event.stream.streamType,
                      attributes: event.stream.getAttributes()
                    }
                  });
                });
                resStream.play(opt.videoNode);
                _context3.next = 26;
                break;

              case 22:
                _context3.prev = 22;
                _context3.t0 = _context3["catch"](14);
                errInfo = { code: "", message: "订阅失败", data: { error: _context3.t0 } };
                return _context3.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 26:
                users = this.roomInfo.getRemoteMap(stream.getUserId());
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context3.prev = 30;

                for (_iterator2 = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_2___default()(users); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  item = _step2.value;

                  if (item.streamId === opt.streamId) {
                    item.status = 1;
                  }
                }

                _context3.next = 38;
                break;

              case 34:
                _context3.prev = 34;
                _context3.t1 = _context3["catch"](30);
                _didIteratorError2 = true;
                _iteratorError2 = _context3.t1;

              case 38:
                _context3.prev = 38;
                _context3.prev = 39;

                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }

              case 41:
                _context3.prev = 41;

                if (!_didIteratorError2) {
                  _context3.next = 44;
                  break;
                }

                throw _iteratorError2;

              case 44:
                return _context3.finish(41);

              case 45:
                return _context3.finish(38);

              case 46:
                result = { streamId: resStream.getID() };
                return _context3.abrupt("return", success ? success(result) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve(result));

              case 48:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[14, 22], [30, 34, 38, 46], [39,, 41, 45]]);
      }));

      function subscribe() {
        return _ref3.apply(this, arguments);
      }

      return subscribe;
    }()

    /**
     * 停止订阅远端流
     * @param {object} opt 取消订阅远端流所需的参数
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "unsubscribe",
    value: function () {
      var _ref4 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee4(opt, success, failure) {
        var stream, errInfo, accountId, users, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _stream;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId"))) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (this.streamObjMap.get(opt.streamId)) {
                  _context4.next = 4;
                  break;
                }

                return _context4.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST));

              case 4:
                stream = this.streamObjMap.get(opt.streamId);
                _context4.prev = 5;
                _context4.next = 8;
                return this.room.unsubscribe(stream);

              case 8:
                _context4.next = 14;
                break;

              case 10:
                _context4.prev = 10;
                _context4.t0 = _context4["catch"](5);
                errInfo = { code: "611012", message: "取消订阅失败", data: { error: _context4.t0 } };
                return _context4.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 14:

                // 订阅成功后修改roomInfo 状态
                accountId = this.streamObjMap.get(opt.streamId).getUserId();
                users = this.roomInfo.getRemoteMap(accountId);
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context4.prev = 19;

                for (_iterator3 = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_2___default()(users); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  _stream = _step3.value;

                  if (_stream.streamId === opt.streamId) {
                    _stream.status = 0;
                  }
                }
                _context4.next = 27;
                break;

              case 23:
                _context4.prev = 23;
                _context4.t1 = _context4["catch"](19);
                _didIteratorError3 = true;
                _iteratorError3 = _context4.t1;

              case 27:
                _context4.prev = 27;
                _context4.prev = 28;

                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }

              case 30:
                _context4.prev = 30;

                if (!_didIteratorError3) {
                  _context4.next = 33;
                  break;
                }

                throw _iteratorError3;

              case 33:
                return _context4.finish(30);

              case 34:
                return _context4.finish(27);

              case 35:
                return _context4.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 36:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[5, 10], [19, 23, 27, 35], [28,, 30, 34]]);
      }));

      function unsubscribe(_x7, _x8, _x9) {
        return _ref4.apply(this, arguments);
      }

      return unsubscribe;
    }()

    /**
     * 获取上下行丢包率
     * @param opt 预留参数
     * @param success
     * @param failure
     */

  }, {
    key: "getPacketLossRate",
    value: function getPacketLossRate(opt, success, failure) {
      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object") {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS);
      }
      var upLossRate = this.room.getUploadPacketLossRate();
      var downLossRate = this.room.getDownloadPacketLossRate();
      var result = { upLossRate: upLossRate, downLossRate: downLossRate };
      return success ? success(result) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve(result);
    }

    /**
     * 开启旁路直播推流
     * @param {object} opt 开启旁路直播推流所需参数
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "startBroadCast",
    value: function () {
      var _ref5 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee5(opt, success, failure) {
        var errInfo, profile, layout, adaptiveLayoutMode, option, _errInfo4, _errInfo5, _errInfo6, _errInfo7, _errInfo8, checkStreamParams, checkResult, _errInfo9, input_stream_list, _errInfo10, _errInfo11, optionStr, _errInfo12;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].PUSH_URL)) {
                  _context5.next = 3;
                  break;
                }

                errInfo = { code: "611017", message: "开启旁路失败（未获取推流地址）", data: {} };
                return _context5.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 3:
                // if (!opt.hasOwnProperty('profile') || (!opt.hasOwnProperty('layout') && !opt.hasOwnProperty('adaptiveLayoutMode'))) {
                //   const errInfo = { code: '611017', message: "开启旁路失败（旁路参数缺失）", data: {} }
                //   return failure ? failure(errInfo) : Promise.reject(errInfo);
                // }

                profile = opt.profile, layout = opt.layout, adaptiveLayoutMode = opt.adaptiveLayoutMode;
                option = {
                  publishUrl: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].PUSH_URL),
                  profile: profile, // 视频质量参数
                  layoutMode: layout, // 指定布局模板
                  adaptiveLayoutMode: adaptiveLayoutMode, // 自使用布局模式
                  backgroundColor: opt.backgroundColor, // 背景色 默认为0x333338
                  crop_type: opt.cropType, // 剪裁模式
                  paneAspectRatio: opt.paneAspectRatio, // 窗格宽高比
                  border: opt.hasOwnProperty("border") && opt["border"] ? { exist: true, width: opt.border.width, color: opt.border.color } : { exist: false }, // 边框
                  precast_pic_exist: opt.precastPic, // 是否要占坑图标，即小人头图标
                  join_pic_exist: opt.joinPic // 是否要禁画图标，即摄像头禁止图标
                  // input_stream_list: opt.layout === VhallRTC.CANVAS_LAYOUT_PATTERN_CUSTOM ? opt.streamList : []
                };

                // todo: 检查所有的参数合法性
                //校验backgroundColor

                if (!(opt.hasOwnProperty("backgroundColor") && (typeof opt.backgroundColor !== "string" || opt.backgroundColor.length !== 8 || opt.backgroundColor.indexOf("0x") !== 0))) {
                  _context5.next = 8;
                  break;
                }

                _errInfo4 = { code: "611017", message: "开启旁路失败（backgroundColor参数异常）", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo4) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo4));

              case 8:
                if (!(opt.hasOwnProperty("layout") && _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CANVAS_LAYOUT"].indexOf(opt.layout) < 0)) {
                  _context5.next = 11;
                  break;
                }

                _errInfo5 = { code: "611017", message: "开启旁路失败（layout参数异常）", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo5) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo5));

              case 11:
                if (!(opt.hasOwnProperty("adaptiveLayoutMode") && _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CANVAS_ADAPTIVE_LAYOUT"].indexOf(opt.adaptiveLayoutMode) < 0)) {
                  _context5.next = 14;
                  break;
                }

                _errInfo6 = { code: "611017", message: "开启旁路失败（adaptiveLayoutMode参数异常）", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo6) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo6));

              case 14:
                if (!(opt.hasOwnProperty("cropType") && _common_Contant__WEBPACK_IMPORTED_MODULE_9__["BROADCAST_CROP_TYPE"].indexOf(opt.cropType) < 0)) {
                  _context5.next = 17;
                  break;
                }

                _errInfo7 = { code: "611017", message: "开启旁路失败（cropType参数异常）", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo7) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo7));

              case 17:
                if (!(opt.hasOwnProperty("paneAspectRatio") && _common_Contant__WEBPACK_IMPORTED_MODULE_9__["BROADCAST_PANE_ASPACT"].indexOf(opt.paneAspectRatio) < 0)) {
                  _context5.next = 20;
                  break;
                }

                _errInfo8 = { code: "611017", message: "开启旁路失败（paneAspectRatio参数异常）", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo8) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo8));

              case 20:
                //校验streamList
                checkStreamParams = function checkStreamParams(stream) {
                  if (!stream.hasOwnProperty("streamId") || !stream.hasOwnProperty("x") || !stream.hasOwnProperty("y") || !stream.hasOwnProperty("width") || !stream.hasOwnProperty("height") || !stream.hasOwnProperty("zorder")) {
                    return false;
                  }
                  var canvasWidth = profile["resolution"][0];
                  var canvasHeight = profile["resolution"][1];
                  if (stream["x"] + stream["width"] > canvasWidth || stream["y"] + stream["height"] > canvasHeight) {
                    return false;
                  }
                  return true;
                };

                if (!(opt.layout === VhallRTC.CANVAS_LAYOUT_PATTERN_CUSTOM)) {
                  _context5.next = 36;
                  break;
                }

                if (!(babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt.streamList) === "object" && opt.streamList.length > 0)) {
                  _context5.next = 34;
                  break;
                }

                checkResult = opt.streamList.every(checkStreamParams);

                if (checkResult) {
                  _context5.next = 29;
                  break;
                }

                _errInfo9 = { code: "611017", message: "开启旁路失败（streamList参数异常）", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo9) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo9));

              case 29:
                input_stream_list = [];

                opt.streamList.forEach(function (value) {
                  var param = {
                    streamID: value.streamId,
                    location_params: {
                      x: value.x,
                      y: value.y,
                      width: value.width,
                      height: value.height,
                      zorder: value.zorder
                    }
                  };
                  input_stream_list.push(param);
                });
                option.input_stream_list = input_stream_list;

              case 32:
                _context5.next = 36;
                break;

              case 34:
                _errInfo10 = { code: "611017", message: "开启旁路失败（streamList参数缺失）", data: {} };
                return _context5.abrupt("return", failure ? failure(_errInfo10) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo10));

              case 36:
                _context5.prev = 36;
                _context5.next = 39;
                return this.api.setBroadCast({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID), roomId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ROOMID), type: 1 });

              case 39:
                _context5.next = 45;
                break;

              case 41:
                _context5.prev = 41;
                _context5.t0 = _context5["catch"](36);
                _errInfo11 = { code: "611017", message: "开启旁路失败", data: { error: _context5.t0 } };
                return _context5.abrupt("return", failure ? failure(_errInfo11) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo11));

              case 45:
                _context5.prev = 45;
                optionStr = babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0___default()(option);
                _context5.next = 49;
                return this.room.configRoomBroadCast(optionStr);

              case 49:
                _context5.next = 63;
                break;

              case 51:
                _context5.prev = 51;
                _context5.t1 = _context5["catch"](45);
                _context5.prev = 53;
                _context5.next = 56;
                return this.api.setBroadCast({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID), roomId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ROOMID), type: 2 });

              case 56:
                _context5.next = 61;
                break;

              case 58:
                _context5.prev = 58;
                _context5.t2 = _context5["catch"](53);

                console.warn("通知关闭旁路失败");

              case 61:
                _errInfo12 = { code: "611017", message: "开启旁路失败", data: { error: _context5.t1 } };
                return _context5.abrupt("return", failure ? failure(_errInfo12) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo12));

              case 63:
                return _context5.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 64:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[36, 41], [45, 51], [53, 58]]);
      }));

      function startBroadCast(_x10, _x11, _x12) {
        return _ref5.apply(this, arguments);
      }

      return startBroadCast;
    }()

    /**
     * 停止旁路直播
     * @param {object} opt 停止旁路直播所需参数
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "stopBroadCast",
    value: function () {
      var _ref6 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee6() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var success = arguments[1];
        var failure = arguments[2];

        var errInfo, _errInfo13;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object")) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                _context6.prev = 2;
                _context6.next = 5;
                return this.api.setBroadCast({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID), roomId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ROOMID), type: 2 });

              case 5:
                _context6.next = 11;
                break;

              case 7:
                _context6.prev = 7;
                _context6.t0 = _context6["catch"](2);
                errInfo = { code: "611016", message: "停止旁路失败", data: {} };
                return _context6.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 11:
                _context6.prev = 11;
                _context6.next = 14;
                return this.room.stopRoomBroadCast();

              case 14:
                _context6.next = 28;
                break;

              case 16:
                _context6.prev = 16;
                _context6.t1 = _context6["catch"](11);
                _context6.prev = 18;
                _context6.next = 21;
                return this.api.setBroadCast({ inavId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].INAVID), roomId: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].ROOMID), type: 1 });

              case 21:
                _context6.next = 26;
                break;

              case 23:
                _context6.prev = 23;
                _context6.t2 = _context6["catch"](18);

                console.warn("通知开启旁路失败");

              case 26:
                _errInfo13 = { code: "611016", message: "停止旁路失败", data: {} };
                return _context6.abrupt("return", failure ? failure(_errInfo13) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_errInfo13));

              case 28:
                return _context6.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 29:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[2, 7], [11, 16], [18, 23]]);
      }));

      function stopBroadCast() {
        return _ref6.apply(this, arguments);
      }

      return stopBroadCast;
    }()

    /**
     * 动态配置旁路布局
     * @param {*} layout 旁路布局
     * @param {string} [mode="all"]
     * @returns null
     * @memberof MixStream
     */

  }, {
    key: "setBroadCastLayout",
    value: function () {
      var _ref7 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee7() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var success = arguments[1];
        var failure = arguments[2];
        var errInfo;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || typeof opt.layout !== "number")) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                _context7.prev = 2;
                _context7.next = 5;
                return this.room.setMixLayoutMode(opt.layout);

              case 5:
                _context7.next = 11;
                break;

              case 7:
                _context7.prev = 7;
                _context7.t0 = _context7["catch"](2);
                errInfo = { code: "611018", message: "切换旁路推流布局失败", data: {} };
                return _context7.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 11:
                return _context7.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[2, 7]]);
      }));

      function setBroadCastLayout() {
        return _ref7.apply(this, arguments);
      }

      return setBroadCastLayout;
    }()

    /**
    * 动态配置旁路自适应布局模式
    * @param {*} adaptiveLayoutMode 自适应布局模式
    * @returns null
    */

  }, {
    key: "setBroadCastAdaptiveLayoutMode",
    value: function () {
      var _ref8 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee8() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var success = arguments[1];
        var failure = arguments[2];
        var errInfo;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || typeof opt.adaptiveLayoutMode !== "number")) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                _context8.prev = 2;
                _context8.next = 5;
                return this.room.setMixAdaptiveLayoutMode(opt.adaptiveLayoutMode);

              case 5:
                _context8.next = 11;
                break;

              case 7:
                _context8.prev = 7;
                _context8.t0 = _context8["catch"](2);
                errInfo = { code: "611018", message: "切换旁路自适应布局模式失败", data: {} };
                return _context8.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 11:
                return _context8.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[2, 7]]);
      }));

      function setBroadCastAdaptiveLayoutMode() {
        return _ref8.apply(this, arguments);
      }

      return setBroadCastAdaptiveLayoutMode;
    }()

    /**
     * 动态配置旁路主屏
     * @param {object} opt 配置旁路主屏所需参数
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "setBroadCastScreen",
    value: function () {
      var _ref9 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee9(opt, success, failure) {
        var errInfo;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.mainScreenStreamId)) {
                  _context9.next = 2;
                  break;
                }

                return _context9.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (this.streamObjMap.get(opt.mainScreenStreamId)) {
                  _context9.next = 4;
                  break;
                }

                return _context9.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_STREAM_NOT_EXIST));

              case 4:
                _context9.prev = 4;
                _context9.next = 7;
                return this.room.setMixLayoutMainScreen(opt.mainScreenStreamId);

              case 7:
                _context9.next = 13;
                break;

              case 9:
                _context9.prev = 9;
                _context9.t0 = _context9["catch"](4);
                errInfo = { code: "611018", message: "切换旁路推流主屏失败", data: {} };
                return _context9.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 13:
                return _context9.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 14:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[4, 9]]);
      }));

      function setBroadCastScreen(_x16, _x17, _x18) {
        return _ref9.apply(this, arguments);
      }

      return setBroadCastScreen;
    }()

    /**
     * 设置是否使用Turn代理服务器
     * @param {boolean} 是否开启
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "setTurn",
    value: function () {
      var _ref10 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee10(forceTurn_, success, failure) {
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.room.setTurn(forceTurn_);
                return _context10.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function setTurn(_x19, _x20, _x21) {
        return _ref10.apply(this, arguments);
      }

      return setTurn;
    }()

    /**
     * 设置参会者角色
     * @param {role} audience|host
     */

  }, {
    key: "setClientRole",
    value: function () {
      var _ref11 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee11(role, success, failure) {
        var errInfo;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(role !== _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_HOST && role !== _common_Contant__WEBPACK_IMPORTED_MODULE_9__["CLIENT_ROLES"].ROLE_AUDIENCE)) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                _context11.prev = 2;
                _context11.next = 5;
                return this.room.setClientRole(role);

              case 5:
                this.store.setKV(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["KV"].CLIENT_ROLE, role);
                _context11.next = 12;
                break;

              case 8:
                _context11.prev = 8;
                _context11.t0 = _context11["catch"](2);
                errInfo = { code: "611018", message: "设置用户角色失败", data: {} };
                return _context11.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 12:
                return _context11.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 13:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[2, 8]]);
      }));

      function setClientRole(_x22, _x23, _x24) {
        return _ref11.apply(this, arguments);
      }

      return setClientRole;
    }()

    /**
     * 动态配置互动流的旁路混流属性
     * @param {*} 
     * @returns null
     */

  }, {
    key: "setStreamMixOption",
    value: function () {
      var _ref12 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee12() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var success = arguments[1];
        var failure = arguments[2];
        var errInfo;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt.option) !== "object")) {
                  _context12.next = 2;
                  break;
                }

                return _context12.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                _context12.prev = 2;
                _context12.next = 5;
                return this.room.setStreamMixOption(opt.option);

              case 5:
                _context12.next = 11;
                break;

              case 7:
                _context12.prev = 7;
                _context12.t0 = _context12["catch"](2);
                errInfo = { code: "611018", message: "配置互动流旁路混流属性失败", data: {} };
                return _context12.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.reject(errInfo));

              case 11:
                return _context12.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_5___default.a.resolve());

              case 12:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[2, 7]]);
      }));

      function setStreamMixOption() {
        return _ref12.apply(this, arguments);
      }

      return setStreamMixOption;
    }()
  }]);

  return RoomApi;
}();



/***/ }),

/***/ "./src/biz/call/StaticFnc.js":
/*!***********************************!*\
  !*** ./src/biz/call/StaticFnc.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StaticFnc; });
/* harmony import */ var babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");
/* harmony import */ var babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! babel-runtime/core-js/map */ "./node_modules/babel-runtime/core-js/map.js");
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../rtcbase/src/Main */ "./rtcbase/src/Main.js");
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/Contant */ "./src/common/Contant.js");








/* 
* 此类静态方法   尽量只放非实例化的方法
*/



var StaticFnc = function () {
  function StaticFnc() {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_6___default()(this, StaticFnc);

    this.tools = _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_8__["default"].vhallcall.Tools();
    this.previewMap = new babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_5___default.a();
  }

  /**
   * 检查当前浏览器的支持兼容性，返回格式如下：
   * {
   *   "result": true,
   *   "detail":{
   *     "isWebRTCSupported": true,
   *     "isWebSocketSupported": true,
   *     "isScreenShareSupported": true,
   *     "isGetUserMediaSupported": true,
   *     "isEnumerateDevicesSupported": true
   *   }
   * }
   */


  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_7___default()(StaticFnc, [{
    key: "checkSystemRequirements",
    value: function checkSystemRequirements() {
      var _this = this;

      // return this.tools.checkSystemRequirements();
      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a(function (resolve) {
        var ret = _this.tools.checkSystemRequirements();
        resolve(ret);
      });
    }

    /* 
    * 设置日志等级  
    *   leavel  只能是number
    */

  }, {
    key: "setLogLevel",
    value: function () {
      var _ref = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee(level) {
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof level != "number")) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                return _context.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(this.tools.setLogLevel(level)));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setLogLevel(_x) {
        return _ref.apply(this, arguments);
      }

      return setLogLevel;
    }()
  }, {
    key: "setLogUpload",
    value: function () {
      var _ref2 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee2(level, sure) {
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (level == _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_8__["default"].Vhallcall.LOG_DISABLE_ALL_REPORT && !sure && sure != "all") {
                  level = _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_8__["default"].Vhallcall.LOG_DISABLE_REPORT;
                }

                if (!(typeof level != "number" || level >= 4 && level <= 0)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 3:
                return _context2.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(this.tools.setLogUpload(level)));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setLogUpload(_x2, _x3) {
        return _ref2.apply(this, arguments);
      }

      return setLogUpload;
    }()

    /**
     * 获取当前浏览器是否支持屏幕共享（WebRTC屏幕分享支持桌面端Chrome M72+及Safari 13）：
     * true/false
     */

  }, {
    key: "isScreenShareSupported",
    value: function isScreenShareSupported() {
      return this.tools.isScreenShareSupported();
    }

    /**
     * 获取当前是否在移动端设备，返回格式如下：
     * true/false
     */

  }, {
    key: "isMobileDevice",
    value: function isMobileDevice() {
      return this.tools.isMobileDevice();
    }

    /**
     * 获取浏览器类型和版本，返回格式如下：
     * {
     *   fullVersion: "87.0.4280.88",
     *   name: "Chrome",
     *   version: 87
     * }
     */

  }, {
    key: "getBrowserInfo",
    value: function getBrowserInfo() {
      return this.tools.getBrowserInfo();
    }

    /**
     * 获取浏览器类型： none|fake|mozilla|chrome-stable|electron|safari
     */

  }, {
    key: "getBrowser",
    value: function getBrowser() {
      return this.tools.getBrowser();
    }

    /**
     * 获取操作系统类型和版本，返回格式如下：
     *  {
     *     osName: 'Windows',
     *     osVersion: '7'
     *  }
     */

  }, {
    key: "getOS",
    value: function getOS() {
      return this.tools.getOS();
    }

    /**
    * 获取音视频设备列表
    * @param {object} opt 预留参数
    * @param {function} success 成功回调
    * @param {function} failure 失败回调
    */

  }, {
    key: "getDevices",
    value: function () {
      var _ref3 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee3() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var success = arguments[1];
        var failure = arguments[2];

        var errInfo, res, _errInfo;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(opt)) !== "object")) {
                  _context3.next = 3;
                  break;
                }

                errInfo = { code: "611001", message: "无效的参数", data: {} };
                return _context3.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(errInfo));

              case 3:
                res = void 0;
                _context3.prev = 4;
                _context3.next = 7;
                return this.tools.getBrowserDevices();

              case 7:
                res = _context3.sent;
                _context3.next = 14;
                break;

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](4);
                _errInfo = { code: "611008", message: "无音频/视频设备", data: {} };
                return _context3.abrupt("return", failure ? failure(_errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(_errInfo));

              case 14:
                return _context3.abrupt("return", success ? success(res) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(res));

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[4, 10]]);
      }));

      function getDevices() {
        return _ref3.apply(this, arguments);
      }

      return getDevices;
    }()

    /**
     * 获取摄像头列表
     * return: Promise.<Array.<MediaDeviceInfo>>
     */

  }, {
    key: "getCameras",
    value: function () {
      var _ref4 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee4() {
        var devices;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return this.getDevices();

              case 3:
                devices = _context4.sent;
                return _context4.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(devices["videoInputDevices"]));

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](0);
                return _context4.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(_context4.t0));

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 7]]);
      }));

      function getCameras() {
        return _ref4.apply(this, arguments);
      }

      return getCameras;
    }()

    /**
     * 获取麦克风列表
     * return: Promise.<Array.<MediaDeviceInfo>> 
     */

  }, {
    key: "getMicrophones",
    value: function () {
      var _ref5 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee5() {
        var devices;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;
                _context5.next = 3;
                return this.getDevices();

              case 3:
                devices = _context5.sent;
                return _context5.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(devices["audioInputDevices"]));

              case 7:
                _context5.prev = 7;
                _context5.t0 = _context5["catch"](0);
                return _context5.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(_context5.t0));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[0, 7]]);
      }));

      function getMicrophones() {
        return _ref5.apply(this, arguments);
      }

      return getMicrophones;
    }()

    /**
     * 获取扬声器列表
     * return: Promise.<Array.<MediaDeviceInfo>>
     */

  }, {
    key: "getSpeakers",
    value: function () {
      var _ref6 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee6() {
        var devices;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return this.getDevices();

              case 3:
                devices = _context6.sent;
                return _context6.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(devices["audioOutputDevices"]));

              case 7:
                _context6.prev = 7;
                _context6.t0 = _context6["catch"](0);
                return _context6.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(_context6.t0));

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 7]]);
      }));

      function getSpeakers() {
        return _ref6.apply(this, arguments);
      }

      return getSpeakers;
    }()

    /**
    * 获取指定视频设备的支持分辨率列表
    * @param {object} opt 参数
    * @param {function} success 成功回调
    * @param {function} failure 失败回调
    */

  }, {
    key: "getVideoConstraints",
    value: function () {
      var _ref7 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee7(opt, success, failure) {
        var options, res;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(opt)) !== "object" || !opt.hasOwnProperty("deviceId"))) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_9__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (!sessionStorage.getItem(opt.deviceId)) {
                  _context7.next = 4;
                  break;
                }

                return _context7.abrupt("return", success ? success(JSON.parse(sessionStorage.getItem(opt.deviceId))) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(JSON.parse(sessionStorage.getItem(opt.deviceId))));

              case 4:
                options = { frameRate: 25, deviceId: opt.deviceId };
                _context7.next = 7;
                return this.tools.getVideoConstraintsV2(options);

              case 7:
                res = _context7.sent;

                if (res && res.length) {
                  sessionStorage.setItem(opt.deviceId, babel_runtime_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_0___default()(res));
                }
                return _context7.abrupt("return", success ? success(res) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_4___default.a.resolve(res));

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getVideoConstraints(_x5, _x6, _x7) {
        return _ref7.apply(this, arguments);
      }

      return getVideoConstraints;
    }()

    /**
     * 开始预览
     *
     * @param {*} opt
     * @param {*} [success=() => { }]
     * @param {*} [failure=() => { }]
     * @returns
     * @memberof StaticFnc
     */

  }, {
    key: "startPreview",
    value: function () {
      var _ref8 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee8(opt) {
        var success = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
        var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

        var _opt$audio, audio, _opt$video, video, profile, _opt$mute, mute, videoQuality, _opt$videoCodec, videoCodec, _opt$attributes, attributes, videoNode, _opt$showControls, showControls, videoSize, option, localStream, errInfo;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                // eslint-disable-next-line no-unused-vars
                _opt$audio = opt.audio, audio = _opt$audio === undefined ? true : _opt$audio, _opt$video = opt.video, video = _opt$video === undefined ? true : _opt$video, profile = opt.profile, _opt$mute = opt.mute, mute = _opt$mute === undefined ? { audio: false, video: false } : _opt$mute, videoQuality = opt.videoQuality, _opt$videoCodec = opt.videoCodec, videoCodec = _opt$videoCodec === undefined ? VhallRTC.CODECS_VP8 : _opt$videoCodec, _opt$attributes = opt.attributes, attributes = _opt$attributes === undefined ? "" : _opt$attributes, videoNode = opt.videoNode, _opt$showControls = opt.showControls, showControls = _opt$showControls === undefined ? false : _opt$showControls;

                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(opt)) !== "object")) {
                  _context8.next = 6;
                  break;
                }

                failure({ code: "611001", message: "无效的参数", data: {} });
                return _context8.abrupt("return");

              case 6:
                if (document.getElementById(videoNode)) {
                  _context8.next = 9;
                  break;
                }

                failure({ code: "611003", message: "dom节点不存在", data: {} });
                return _context8.abrupt("return");

              case 9:
                videoSize = undefined;

                if (videoQuality && videoQuality.framerate % 1 === 0 && videoQuality.framerate >= 5 && videoQuality.framerate <= 30) {
                  videoSize = [videoQuality.width, videoQuality.height, videoQuality.width, videoQuality.height];
                }
                option = {
                  audio: opt.audioDevice ? { deviceId: opt.audioDevice } : audio,
                  video: opt.videoDevice ? { deviceId: opt.videoDevice } : video,
                  data: true,
                  profile: profile,
                  videoSize: videoSize,
                  attributes: attributes,
                  simulcast: videoCodec === VhallRTC.CODECS_VP8,
                  videoCodecPreference: videoCodec
                };
                localStream = void 0;
                _context8.prev = 13;

                localStream = _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_8__["default"].vhallcall.Stream(option);
                _context8.next = 17;
                return localStream.init();

              case 17:
                mute.hasOwnProperty("audio") && localStream.muteAudio(mute.audio);
                mute.hasOwnProperty("video") && localStream.muteVideo(mute.video);
                localStream.play(videoNode, {});
                _context8.next = 27;
                break;

              case 22:
                _context8.prev = 22;
                _context8.t0 = _context8["catch"](13);
                errInfo = { code: "611005", message: "初始化本地流失败", data: { error: _context8.t0 } };

                failure(errInfo);
                return _context8.abrupt("return");

              case 27:
                this.previewMap.set(localStream.getID(), localStream);
                success({ streamId: localStream.getID() });

              case 29:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[13, 22]]);
      }));

      function startPreview(_x8) {
        return _ref8.apply(this, arguments);
      }

      return startPreview;
    }()

    /**
     * 停止预览
     *
     * @param {*} opt
     * @param {*} [success=() => { }]
     * @param {*} [failure=() => { }]
     * @returns
     * @memberof StaticFnc
     */

  }, {
    key: "stopPreview",
    value: function () {
      var _ref9 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee9(opt) {
        var success = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
        var failure = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId"))) {
                  _context9.next = 3;
                  break;
                }

                failure({ code: "611001", message: "无效的参数", data: {} });
                return _context9.abrupt("return");

              case 3:
                if (this.previewMap.get(opt.streamId)) {
                  _context9.next = 6;
                  break;
                }

                failure({ code: "611006", message: "该streamId不存在", data: {} });
                return _context9.abrupt("return");

              case 6:
                this.previewMap.get(opt.streamId).close();
                this.previewMap.delete(opt.streamId);
                success();

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function stopPreview(_x11) {
        return _ref9.apply(this, arguments);
      }

      return stopPreview;
    }()
  }]);

  return StaticFnc;
}();



/***/ }),

/***/ "./src/biz/call/StreamsApi.js":
/*!************************************!*\
  !*** ./src/biz/call/StreamsApi.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StreamsApi; });
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ "./node_modules/babel-runtime/core-js/get-iterator.js");
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");
/* harmony import */ var babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../rtcbase/src/Main */ "./rtcbase/src/Main.js");
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/Contant */ "./src/common/Contant.js");










var StreamsApi = function () {
  function StreamsApi(app) {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_5___default()(this, StreamsApi);

    this.events = app.events;
    this.msg = app.msg;
    this.api = app.api;
    this.store = app.store;
    this.roomInfo = app.roomInfo;
    this.streamObjMap = _common_Contant__WEBPACK_IMPORTED_MODULE_8__["streamObjMap"];
    this.localStreamMap = _common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"];
  }

  /**
   * 创建本地音视频流
   * @param {object} opt 配置流参数
   * @param {function} success 成功回调
   * @param {function} failure 失败回调
   */


  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_6___default()(StreamsApi, [{
    key: "createStream",
    value: function () {
      var _ref = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2(opt, success, failure) {
        var _this = this;

        var videoNode, _opt$audio, audio, _opt$video, video, _opt$screen, screen, _opt$speaker, speaker, _opt$simulcast, simulcast, videoContentHint, profile, _opt$videoCodec, videoCodec, _opt$mute, mute, _opt$attributes, attributes, facingMode, mirror, _opt$showControls, showControls, audioTrack, videoTrack, insertedStream, _opt$electronScreen, electronScreen, _opt$electronScreenSp, electronScreenSpeaker, electronSource, mixOption, streamType, _opt$beautyOption, beautyOption, option, localStream, errInfo, handlerStreamEnded, result;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                videoNode = opt.videoNode, _opt$audio = opt.audio, audio = _opt$audio === undefined ? true : _opt$audio, _opt$video = opt.video, video = _opt$video === undefined ? true : _opt$video, _opt$screen = opt.screen, screen = _opt$screen === undefined ? false : _opt$screen, _opt$speaker = opt.speaker, speaker = _opt$speaker === undefined ? true : _opt$speaker, _opt$simulcast = opt.simulcast, simulcast = _opt$simulcast === undefined ? false : _opt$simulcast, videoContentHint = opt.videoContentHint, profile = opt.profile, _opt$videoCodec = opt.videoCodec, videoCodec = _opt$videoCodec === undefined ? VhallRTC.CODECS_VP8 : _opt$videoCodec, _opt$mute = opt.mute, mute = _opt$mute === undefined ? {} : _opt$mute, _opt$attributes = opt.attributes, attributes = _opt$attributes === undefined ? "" : _opt$attributes, facingMode = opt.facingMode, mirror = opt.mirror, _opt$showControls = opt.showControls, showControls = _opt$showControls === undefined ? false : _opt$showControls, audioTrack = opt.audioTrack, videoTrack = opt.videoTrack, insertedStream = opt.insertedStream, _opt$electronScreen = opt.electronScreen, electronScreen = _opt$electronScreen === undefined ? false : _opt$electronScreen, _opt$electronScreenSp = opt.electronScreenSpeaker, electronScreenSpeaker = _opt$electronScreenSp === undefined ? false : _opt$electronScreenSp, electronSource = opt.electronSource, mixOption = opt.mixOption, streamType = opt.streamType, _opt$beautyOption = opt.beautyOption, beautyOption = _opt$beautyOption === undefined ? {
                  flag: false,
                  level: 0.1
                } : _opt$beautyOption;

                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || typeof attributes !== "string" || attributes.length > 256)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS));

              case 3:
                if (document.getElementById(videoNode)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_DOM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_DOM_NOT_EXIST));

              case 5:
                option = {
                  profile: profile,
                  audio: opt.audioDevice ? { deviceId: opt.audioDevice } : audio,
                  video: opt.videoDevice ? { deviceId: opt.videoDevice } : video,
                  screen: screen,
                  screenSpeaker: speaker,
                  audioTrack: audioTrack,
                  videoTrack: videoTrack,
                  simulcast: simulcast,
                  videoCodecPreference: videoCodec,
                  facingMode: facingMode,
                  mirror: mirror,
                  attributes: attributes,
                  insertedStream: insertedStream,
                  hasInsertedStream: insertedStream !== undefined,
                  mixOption: mixOption,
                  streamType: streamType,
                  beautyOption: beautyOption
                };

                if (electronScreen && electronSource) {
                  option.screen = true;
                  option.video = {
                    mandatory: {
                      chromeMediaSource: "desktop",
                      chromeMediaSourceId: electronSource.id
                    }
                  };
                  if (electronScreenSpeaker) {
                    option.audio = {
                      mandatory: {
                        chromeMediaSource: "desktop"
                      }
                    };
                  } else {
                    option.audio = false;
                  }
                }
                localStream = void 0;
                _context2.prev = 8;

                localStream = _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_7__["default"].vhallcall.Stream(option);
                _context2.next = 12;
                return localStream.init();

              case 12:
                videoContentHint && localStream.setVideoContentHint(videoContentHint);
                if (mute.audio) {
                  localStream.muteAudio();
                }
                if (mute.video) {
                  localStream.muteVideo();
                }
                localStream.play(videoNode, { controls: showControls });
                _context2.next = 23;
                break;

              case 18:
                _context2.prev = 18;
                _context2.t0 = _context2["catch"](8);
                errInfo = { code: "611005", message: "初始化本地流失败", name: "", data: { error: _context2.t0 } };

                if (_context2.t0.type === "localStream-parameters-error") {
                  errInfo.name = "localStream-parameters-error";
                } else if (_context2.t0.type === "localStream-getusermedia-error") {
                  errInfo.name = _context2.t0.msg.name;
                }
                return _context2.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo));

              case 23:
                handlerStreamEnded = function () {
                  var _ref2 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee(event) {
                    var streamId;
                    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            streamId = event.stream.getID();
                            _context.prev = 1;
                            _context.next = 4;
                            return _this.destroyStream({ streamId: streamId });

                          case 4:
                            _context.next = 9;
                            break;

                          case 6:
                            _context.prev = 6;
                            _context.t0 = _context["catch"](1);
                            return _context.abrupt("return", failure ? failure(_context.t0) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_context.t0));

                          case 9:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, _this, [[1, 6]]);
                  }));

                  return function handlerStreamEnded(_x4) {
                    return _ref2.apply(this, arguments);
                  };
                }();

                localStream.addEventListener("stream-ended", function (event) {
                  handlerStreamEnded(event);
                  _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["EVENT"].EVENT_STREAM_END, {
                    event: _common_Contant__WEBPACK_IMPORTED_MODULE_8__["EVENT"].EVENT_STREAM_END,
                    data: {
                      stream: event.stream,
                      streamId: event.stream.getID(),
                      accountId: event.stream.getUserId(),
                      streamType: event.stream.streamType,
                      attributes: event.stream.getAttributes()
                    }
                  });
                });
                localStream.addEventListener("stream-stunk", function (event) {
                  // handler(event);
                  _this.events.dispatchEvent(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["EVENT"].EVENT_STREAM_STUNK, {
                    event: _common_Contant__WEBPACK_IMPORTED_MODULE_8__["EVENT"].EVENT_STREAM_STUNK,
                    data: {
                      stream: event.stream,
                      streamId: event.stream.getID(),
                      accountId: event.stream.getUserId(),
                      streamType: event.stream.streamType,
                      attributes: event.stream.getAttributes()
                    }
                  });
                });

                this.streamObjMap.set(localStream.getID(), localStream);
                this.localStreamMap.set(localStream.getID(), localStream);

                // 本地流多流roominfo 存储
                this.roomInfo.addLocalStream(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["KV"].ACCOUNTID), {
                  streamId: localStream.getID(),
                  type: "local",
                  state: 0,
                  streamType: localStream.streamType,
                  attributes: localStream.getAttributes(),
                  audioMuted: localStream.audioMuted,
                  videoMuted: localStream.videoMuted
                });

                //接口返回值
                result = { streamId: localStream.getID() };
                return _context2.abrupt("return", success ? success(result) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(result));

              case 31:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[8, 18]]);
      }));

      function createStream(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      }

      return createStream;
    }()

    /**
     * 销毁本地音视频流
     * @param {object} opt 销毁本地音视频流所需参
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "destroyStream",
    value: function destroyStream(opt, success, failure) {
      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      if (!this.localStreamMap.get(opt.streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }

      var stream = this.localStreamMap.get(opt.streamId);
      stream.close("vhallyun-destroyStream");
      this.localStreamMap.delete(opt.streamId);
      this.streamObjMap.delete(opt.streamId);
      this.roomInfo.removeLocalStream(this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["KV"].ACCOUNTID), opt.streamId);
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
    * 停止播放音视频流
    * @param {object} opt 参数
    * @param {function} success 成功回调
    * @param {function} failure 失败回调
    */

  }, {
    key: "stopStream",
    value: function stopStream(opt, success, failure) {
      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      if (!this.streamObjMap.get(opt.streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }

      var stream = this.streamObjMap.get(opt.streamId);
      stream.stop();
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 播放音视频流
     * @param {object} opt 参数
     * @param {function} success 成功回调
     * @param {function} failure 失败回调
     */

  }, {
    key: "playStream",
    value: function playStream(opt, success, failure) {
      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId") || !opt.hasOwnProperty("videoNode")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      if (!this.streamObjMap.get(opt.streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      if (!document.getElementById(opt.videoNode)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_DOM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_DOM_NOT_EXIST);
      }

      var stream = this.streamObjMap.get(opt.streamId);
      stream.play(opt.videoNode, {});
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 获取流的mute状态
     * @param {*} opt
     * @returns { audioMuted, videoMuted }
     * @memberof Interface
     */

  }, {
    key: "getStreamMute",
    value: function getStreamMute() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var success = arguments[1];
      var failure = arguments[2];

      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      var _opt$streamId = opt.streamId,
          streamId = _opt$streamId === undefined ? "" : _opt$streamId;

      if (!this.streamObjMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var stream = this.streamObjMap.get(streamId);
      var audioMuted = stream.audioMuted,
          videoMuted = stream.videoMuted;

      var res = { audioMuted: audioMuted, videoMuted: videoMuted };
      return success ? success(res) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(res);
    }

    /**
      * 不建议使用  demo使用的此方法
      * 开关音视频
      * @param {object} opt 开关音视频所需要的参数
      * @param {function} success 成功回调
      * @param {function} failure 失败回调
      */

  }, {
    key: "mute",
    value: function mute(opt, success, failure) {
      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("mute") || babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt.mute) !== "object" || !opt.hasOwnProperty("streamId")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      if (!this.streamObjMap.get(opt.streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      opt.mute.hasOwnProperty("audio") && this.muteAudio({ isMute: opt.mute.audio, streamId: opt.streamId });
      opt.mute.hasOwnProperty("video") && this.muteVideo({ isMute: opt.mute.video, streamId: opt.streamId });
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 设置视频开关
     * @param {object} opt {streamId , isMute}
     * @param {function} success 
     * @param {function} failure 
     */

  }, {
    key: "muteVideo",
    value: function muteVideo() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var success = arguments[1];
      var failure = arguments[2];

      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId") || !opt.hasOwnProperty("isMute")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      var streamId = opt.streamId,
          isMute = opt.isMute;

      if (!this.streamObjMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var streamObj = this.streamObjMap.get(streamId);
      streamObj.muteVideo(isMute);
      this.updateRoomInfo(streamObj, "video", isMute);
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 设置音频开关
     * @param {object} opt {streamId , isMute}
     * @param {function} success 
     * @param {function} failure 
     */

  }, {
    key: "muteAudio",
    value: function muteAudio() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var success = arguments[1];
      var failure = arguments[2];

      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId") || !opt.hasOwnProperty("isMute")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      var streamId = opt.streamId,
          isMute = opt.isMute;

      if (!this.streamObjMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var streamObj = this.streamObjMap.get(streamId);
      streamObj.muteAudio(isMute);
      this.updateRoomInfo(streamObj, "audio", isMute);
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /* 
    * 更新RoomInfo信息
    */

  }, {
    key: "updateRoomInfo",
    value: function updateRoomInfo(streamObj, type, isMute) {
      var streams = [];
      if (streamObj.local) {
        streams = this.roomInfo.localMap.get(streamObj.user.id);
      } else {
        streams = this.roomInfo.remoteMap.get(streamObj.user.id);
      }
      console.warn('streams------', this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["KV"].ACCOUNTID), streams, streamObj, this.roomInfo);
      try {
        this.roomInfo.updateStream({
          key: this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["KV"].ACCOUNTID),
          streamId: streamObj.streamId,
          mute: isMute,
          type: type
        });
      } catch (error) {
        console.error('error-------', error);
      }
      // this
      // try {
      //   streams.forEach(stream =>{
      //     streamObj.streamId == stream.streamId && type == "audio" ? stream.audioMuted = isMute : ""
      //     streamObj.streamId == stream.streamId && type == "video" ? stream.videoMuted = isMute : ""
      //   })
      // } catch (error) {
      //   console.log("update roomInfo failed", error)   
      // }
    }
    /**
    * 远端流双流配置
    * @param {object} opt 远端流双流配置所需参数
    * @param {function} success 成功回调
    * @param {function} failure 失败回调
    */

  }, {
    key: "setDual",
    value: function setDual(opt, success, failure) {
      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId") || !opt.hasOwnProperty("dual") || opt.streamId === "" || typeof opt.dual !== "number" || opt.dual !== 0 && opt.dual !== 1) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      if (this.localStreamMap.has(opt.streamId)) {
        var errInfo = { code: "611015", message: "无法配置本地流", data: {} };
        return failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo);
      }
      if (!this.streamObjMap.get(opt.streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var accountId = this.streamObjMap.get(opt.streamId).getUserId();
      var users = this.roomInfo.getRemoteMap(accountId);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0___default()(users), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _stream = _step.value;

          if (_stream.streamId === opt.streamId && _stream.status === 0) {
            var _errInfo = { code: "611013", message: "该流未订阅", data: {} };
            return failure ? failure(_errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_errInfo);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var stream = this.streamObjMap.get(opt.streamId);
      stream.setRemoteVideoStreamType(opt.dual);
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 获取流自定义信息
     * @param {*} opt 
     * @param {*} success 
     * @param {*} failure 
     */

  }, {
    key: "getAttributes",
    value: function getAttributes(opt, success, failure) {
      if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.hasOwnProperty("streamId")) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
      }
      if (!this.streamObjMap.get(opt.streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var stream = this.streamObjMap.get(opt.streamId);
      var attr = stream.getAttributes();
      return success ? success(attr) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(attr);
    }

    /**
     * 设置音频输出设备
     * @param {object} opt 
     * @param {function} success 
     * @param {function} failure 
     */

  }, {
    key: "setAudioOutput",
    value: function () {
      var _ref3 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee3() {
        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var success = arguments[1];
        var failure = arguments[2];

        var _opt$deviceId, deviceId, _opt$streamId2, streamId, errInfo, _errInfo2, stream, _errInfo3;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _opt$deviceId = opt.deviceId, deviceId = _opt$deviceId === undefined ? "" : _opt$deviceId, _opt$streamId2 = opt.streamId, streamId = _opt$streamId2 === undefined ? "" : _opt$streamId2;

                if (deviceId) {
                  _context3.next = 4;
                  break;
                }

                errInfo = { code: "611001", message: "deviceId不可为空", data: {} };
                return _context3.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo));

              case 4:
                if (!this.localStreamMap.has(opt.streamId)) {
                  _context3.next = 7;
                  break;
                }

                _errInfo2 = { code: "611015", message: "无法配置本地流", data: {} };
                return _context3.abrupt("return", failure ? failure(_errInfo2) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_errInfo2));

              case 7:
                if (this.streamObjMap.get(opt.streamId)) {
                  _context3.next = 9;
                  break;
                }

                return _context3.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST));

              case 9:
                stream = this.streamObjMap.get(streamId);
                _context3.prev = 10;
                _context3.next = 13;
                return stream.setAudioOutput(deviceId);

              case 13:
                _context3.next = 19;
                break;

              case 15:
                _context3.prev = 15;
                _context3.t0 = _context3["catch"](10);
                _errInfo3 = { code: "611012", message: "设置音频输出设备失败", data: { err: _context3.t0 } };
                return _context3.abrupt("return", failure ? failure(_errInfo3) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_errInfo3));

              case 19:
                return _context3.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve());

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[10, 15]]);
      }));

      function setAudioOutput() {
        return _ref3.apply(this, arguments);
      }

      return setAudioOutput;
    }()

    /**
     * 获取流的上下行丢包率
     * @param opt {streamId}
     * @param success 
     * @param failure 
     */

  }, {
    key: "getStreamPacketLoss",
    value: function getStreamPacketLoss(opt, success, failure) {
      var _opt$streamId3 = opt.streamId,
          streamId = _opt$streamId3 === undefined ? "" : _opt$streamId3;

      if (!this.streamObjMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var stream = this.streamObjMap.get(streamId);

      var packetLossRate = stream.getPacketLossRate();

      return success ? success(packetLossRate) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(packetLossRate);
    }

    /**
     *  设置流播放音量
     * @param  opt {streamId,volume}
     * @param  success 
     * @param  failure 
     */

  }, {
    key: "setAudioVolume",
    value: function setAudioVolume(opt, success, failure) {
      var _opt$streamId4 = opt.streamId,
          streamId = _opt$streamId4 === undefined ? "" : _opt$streamId4,
          _opt$volume = opt.volume,
          volume = _opt$volume === undefined ? 0 : _opt$volume;

      if (!this.streamObjMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var stream = this.streamObjMap.get(streamId);
      stream.setAudioVolume(volume);

      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     *  获取流播放音量大小
     * @param  opt {streamId}
     */

  }, {
    key: "getAudioVolume",
    value: function getAudioVolume(opt) {
      var _this2 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a(function (resolve, reject) {
        var _opt$streamId5 = opt.streamId,
            streamId = _opt$streamId5 === undefined ? "" : _opt$streamId5;

        if (!_this2.streamObjMap.get(streamId)) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
        }
        var stream = _this2.streamObjMap.get(streamId);
        stream.getAudioVolume().then(function (res) {
          return resolve(res);
        }).catch(function (err) {
          reject(err);
        });
      });
    }

    /**
     * 获取流播放音量
     * @param  opt {streamId}
     * @param  success 
     * @param  failure 
     */

  }, {
    key: "getAudioLevel",
    value: function getAudioLevel(opt, success, failure) {
      var _opt$streamId6 = opt.streamId,
          streamId = _opt$streamId6 === undefined ? "" : _opt$streamId6;

      if (!this.streamObjMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var stream = this.streamObjMap.get(streamId);
      var volume = stream.getAudioLevel();
      return success ? success(volume) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(volume);
    }

    /**
     * 获取流播放状态
     * @param opt {streamId}
     * @param success 
     * @param failure 
     */

  }, {
    key: "isPlay",
    value: function isPlay(opt, success, failure) {
      var _opt$streamId7 = opt.streamId,
          streamId = _opt$streamId7 === undefined ? "" : _opt$streamId7;

      if (!this.streamObjMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var stream = this.streamObjMap.get(streamId);
      var isPlay = stream.isPlaying();
      return success ? success(isPlay) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(isPlay);
    }

    /**
     * 设置互动视频质量参数
     * @param  opt {streamId, profile}
     * @param  success
     * @param  failure
     */

  }, {
    key: "setVideoProfile",
    value: function setVideoProfile(opt, success, failure) {
      var _opt$streamId8 = opt.streamId,
          streamId = _opt$streamId8 === undefined ? "" : _opt$streamId8,
          profile = opt.profile;

      if (!streamId) {
        var errInfo = { code: "611001", message: "缺少streamId", data: {} };
        return failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo);
      }
      if (!this.localStreamMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var streamObj = this.localStreamMap.get(streamId);
      streamObj.setVideoProfile(profile);
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 设置屏幕共享质量参数
     * @param  opt {streamId, profile}
     * @param  success
     * @param  failure
     */

  }, {
    key: "setScreenProfile",
    value: function setScreenProfile(opt, success, failure) {
      var _opt$streamId9 = opt.streamId,
          streamId = _opt$streamId9 === undefined ? "" : _opt$streamId9,
          profile = opt.profile;

      if (!streamId) {
        var errInfo = { code: "611001", message: "缺少streamId", data: {} };
        return failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo);
      }
      if (!this.localStreamMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var streamObj = this.localStreamMap.get(streamId);
      streamObj.setScreenProfile(profile);
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 设置互动音频质量参数
     * @param  opt {streamId, profile}
     * @param  success
     * @param  failure
     */

  }, {
    key: "setAudioProfile",
    value: function setAudioProfile(opt, success, failure) {
      var _opt$streamId10 = opt.streamId,
          streamId = _opt$streamId10 === undefined ? "" : _opt$streamId10,
          profile = opt.profile;

      if (!streamId) {
        var errInfo = { code: "611001", message: "缺少streamId", data: {} };
        return failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo);
      }
      if (!this.localStreamMap.get(streamId)) {
        return failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
      }
      var streamObj = this.localStreamMap.get(streamId);
      streamObj.setAudioProfile(profile);
      return success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve();
    }

    /**
     * 切换媒体采集设备
     * @param  opt {streamId, type, deviceId}
     * @param  success
     * @param  failure
     */

  }, {
    key: "switchDevice",
    value: function () {
      var _ref4 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee4(opt, success, failure) {
        var _opt$streamId11, streamId, type, deviceId, errInfo, streamObj, _errInfo4;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _opt$streamId11 = opt.streamId, streamId = _opt$streamId11 === undefined ? "" : _opt$streamId11, type = opt.type, deviceId = opt.deviceId;

                if (streamId) {
                  _context4.next = 4;
                  break;
                }

                errInfo = { code: "611001", message: "缺少streamId", data: {} };
                return _context4.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo));

              case 4:
                if (this.localStreamMap.get(streamId)) {
                  _context4.next = 6;
                  break;
                }

                return _context4.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST));

              case 6:
                streamObj = this.localStreamMap.get(streamId);

                console.warn("streamObj....................", streamObj);
                _context4.prev = 8;
                _context4.next = 11;
                return streamObj.switchDevice(type, deviceId, streamObj);

              case 11:
                _context4.next = 17;
                break;

              case 13:
                _context4.prev = 13;
                _context4.t0 = _context4["catch"](8);
                _errInfo4 = { code: "611012", message: "切换媒体采集设备失败", data: { err: _context4.t0 } };
                return _context4.abrupt("return", failure ? failure(_errInfo4) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_errInfo4));

              case 17:
                return _context4.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve());

              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[8, 13]]);
      }));

      function switchDevice(_x9, _x10, _x11) {
        return _ref4.apply(this, arguments);
      }

      return switchDevice;
    }()

    /**
     * 替换音视频track
     * @param  
     * @param  success
     * @param  failure
     */

  }, {
    key: "replaceTrack",
    value: function () {
      var _ref5 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee5(opt, success, failure) {
        var _opt$streamId12, streamId, type, newTrack, errInfo, streamObj, _errInfo5;

        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _opt$streamId12 = opt.streamId, streamId = _opt$streamId12 === undefined ? "" : _opt$streamId12, type = opt.type, newTrack = opt.newTrack;

                if (streamId) {
                  _context5.next = 4;
                  break;
                }

                errInfo = { code: "611001", message: "缺少streamId", data: {} };
                return _context5.abrupt("return", failure ? failure(errInfo) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(errInfo));

              case 4:
                if (this.localStreamMap.get(streamId)) {
                  _context5.next = 6;
                  break;
                }

                return _context5.abrupt("return", failure ? failure(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST));

              case 6:
                streamObj = this.localStreamMap.get(streamId);
                _context5.prev = 7;
                _context5.next = 10;
                return streamObj.replaceTrack(type, newTrack);

              case 10:
                _context5.next = 16;
                break;

              case 12:
                _context5.prev = 12;
                _context5.t0 = _context5["catch"](7);
                _errInfo5 = { code: "611012", message: "替换音视频轨道失败", data: { err: _context5.t0 } };
                return _context5.abrupt("return", failure ? failure(_errInfo5) : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_errInfo5));

              case 16:
                return _context5.abrupt("return", success ? success() : babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve());

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[7, 12]]);
      }));

      function replaceTrack(_x12, _x13, _x14) {
        return _ref5.apply(this, arguments);
      }

      return replaceTrack;
    }()

    /**
     * 设置contentHint
     * @param  opt {streamId, hint}
     */

  }, {
    key: "setVideoContentHint",
    value: function setVideoContentHint(opt) {
      var _this3 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a(function (resolve, reject) {
        var _opt$streamId13 = opt.streamId,
            streamId = _opt$streamId13 === undefined ? "" : _opt$streamId13,
            hint = opt.hint;

        if (!streamId) {
          var errInfo = { code: "611001", message: "缺少streamId", data: {} };
          return reject(errInfo);
        }
        if (!_this3.localStreamMap.get(streamId)) {
          return reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
        }
        var streamObj = _this3.localStreamMap.get(streamId);
        streamObj.setVideoContentHint(hint);
        return resolve();
      });
    }

    /**
     * 得到本地音频流状态
     * @return Promise.<map.<streamId, LocalAudioStat>>
     * LocalAudioStat{
     * sendBitrate 发送比特率(Kbps)
     * bytesSent 发送的字节数
     * volume 音量 0-1
     * muteState 静音状态： false:非静音， true:静音 
     * packetLossRate 丢包率 0 -100
     * rtt RTT时间，单位ms
     * }
     */

  }, {
    key: "getLocalAudioStats",
    value: function () {
      var _ref6 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee6() {
        var localAudioStatsMap;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                localAudioStatsMap = {};

                _common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].forEach(function (stream, streamId) {
                  var AudioStats = {};
                  if (!stream.getAudioTrack()) {
                    localAudioStatsMap[streamId] = AudioStats;
                    return;
                  }
                  var streamStats = stream.getStats();
                  var audioMsg = streamStats.outboundRtp.find(function (args) {
                    return args.kind === "audio";
                  });
                  if (!audioMsg) {
                    localAudioStatsMap[streamId] = AudioStats;
                    return;
                  }

                  AudioStats.muteState = stream.getMutedStatus().audioMuted;
                  AudioStats.sendBitrate = streamStats.calculated.a_kbitrateSent;
                  AudioStats.bytesSent = audioMsg.bytesSent;
                  AudioStats.packetLossRate = stream.getPacketLossRate();
                  AudioStats.volume = stream.getAudioLevel();
                  streamStats.candidatePair.forEach(function (stat) {
                    AudioStats.rtt = stat.currentRoundTripTime * 1000;
                  });
                  localAudioStatsMap[streamId] = AudioStats;
                });
                return _context6.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(localAudioStatsMap));

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getLocalAudioStats() {
        return _ref6.apply(this, arguments);
      }

      return getLocalAudioStats;
    }()

    /**
     * 得到本地视频流状态
     * @return Promise.<map.<streamId, LocalVideoStat>>
     * LocalVideoStat {
     * muteState : false: 非禁画， true: 禁画
     * frameRate : 帧率
     * frameWidth : 帧宽度
     * frameHeight : 帧高度
     * framesEncoded: 帧总数
     * bytesSent : 发送的字节数
     * sendBitrate : 当前的发送比特率(Kbps)
     * packetLossRate : 丢包率 0-100
     * rtt: rtt（单位：秒）
     * }
     */

  }, {
    key: "getLocalVideoStats",
    value: function () {
      var _ref7 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee7() {
        var localVideoStatsMap;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                localVideoStatsMap = {};

                _common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].forEach(function (stream, streamId) {
                  var VideoStats = {};
                  if (!stream.getVideoTrack()) {
                    localVideoStatsMap[streamId] = VideoStats;
                    return;
                  }
                  var streamStats = stream.getStats();
                  var videoMsg = streamStats.outboundRtp.find(function (args) {
                    return args.kind === "video";
                  });
                  if (!videoMsg) {
                    localVideoStatsMap[streamId] = VideoStats;
                    return;
                  }

                  VideoStats.muteState = stream.getMutedStatus().videoMuted;
                  VideoStats.frameRate = streamStats.calculated.v_frameRate;
                  VideoStats.frameWidth = videoMsg.frameWidth;
                  VideoStats.frameHeight = videoMsg.frameHeight;
                  VideoStats.framesEncoded = videoMsg.framesEncoded;
                  VideoStats.bytesSent = videoMsg.bytesSent;
                  VideoStats.sendBitrate = streamStats.calculated.v_kbitrateSent;
                  VideoStats.packetLossRate = stream.getPacketLossRate();
                  streamStats.candidatePair.forEach(function (stat) {
                    VideoStats.rtt = stat.currentRoundTripTime * 1000;
                  });

                  localVideoStatsMap[streamId] = VideoStats;
                });
                return _context7.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(localVideoStatsMap));

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getLocalVideoStats() {
        return _ref7.apply(this, arguments);
      }

      return getLocalVideoStats;
    }()

    /**
     * 得到远端音频流状态
     * @return Promise.<map.<streamId, RemoteAudioStat>>
     * RemoteAudioStat {
     * muteState: false: 非静音， true: 静音
     * volume: 音量 0 -1
     * bytesRecv 接受的字节数
     * recvBitrate 接受的比特率(Kbps)
     * packetLossRate 丢包率 0-100
     * rtt: rtt（单位：秒）
     * }
     */

  }, {
    key: "getRemoteAudioStats",
    value: function () {
      var _ref8 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee8() {
        var remoteAudioStatsMap;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                remoteAudioStatsMap = {};

                _common_Contant__WEBPACK_IMPORTED_MODULE_8__["streamObjMap"].forEach(function (stream, streamId) {
                  if (_common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].get(streamId)) {
                    return;
                  }
                  var AudioStats = {};
                  if (!stream.getAudioTrack()) {
                    remoteAudioStatsMap[streamId] = AudioStats;
                    return;
                  }

                  var streamStats = stream.getStats();
                  var audioMsg = streamStats.inboundRtp.find(function (args) {
                    return args.kind === "audio";
                  });
                  if (!audioMsg) {
                    remoteAudioStatsMap[streamId] = AudioStats;
                    return;
                  }

                  AudioStats.muteState = stream.getMutedStatus().audioMuted;
                  AudioStats.volume = stream.getAudioLevel();
                  AudioStats.bytesRecv = audioMsg.bytesReceived;
                  AudioStats.recvBitrate = streamStats.calculated.a_kbitrateReceived;
                  AudioStats.packetLossRate = stream.getPacketLossRate();
                  streamStats.candidatePair.forEach(function (stat) {
                    AudioStats.rtt = stat.currentRoundTripTime * 1000;
                  });
                  remoteAudioStatsMap[streamId] = AudioStats;
                });
                return _context8.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(remoteAudioStatsMap));

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getRemoteAudioStats() {
        return _ref8.apply(this, arguments);
      }

      return getRemoteAudioStats;
    }()

    /**
     * 得到远端视频流状态
     * @return Promise.<map.<streamId, RemoteVideoStat>>
     * RemoteVideoStat {
     * muteState  false: 非禁画， true: 禁画
     * frameRate 帧率
     * frameWidth 帧宽度
     * frameHeight 帧高度
     * bytesRecv 接受的字节数
     * recvBitrate 接受的比特率(Kbps)
     * packetLossRate 丢包率 0-100
     * rtt
     * }
     */

  }, {
    key: "getRemoteVideoStats",
    value: function () {
      var _ref9 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee9() {
        var remoteVideoStatsMap;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                remoteVideoStatsMap = {};

                _common_Contant__WEBPACK_IMPORTED_MODULE_8__["streamObjMap"].forEach(function (stream, streamId) {
                  if (_common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].get(streamId)) {
                    return;
                  }
                  var VideoStats = {};
                  if (!stream.getVideoTrack()) {
                    remoteVideoStatsMap[streamId] = VideoStats;
                    return;
                  }

                  var streamStats = stream.getStats();
                  var videoMsg = streamStats.inboundRtp.find(function (args) {
                    return args.kind === "video";
                  });
                  if (!videoMsg) {
                    remoteVideoStatsMap[streamId] = VideoStats;
                    return;
                  }

                  VideoStats.muteState = stream.getMutedStatus().videoMuted;
                  VideoStats.frameRate = streamStats.calculated.v_frameRate;
                  VideoStats.frameWidth = videoMsg.frameWidth;
                  VideoStats.frameHeight = videoMsg.frameHeight;
                  VideoStats.bytesRecv = videoMsg.bytesReceived;
                  VideoStats.recvBitrate = streamStats.calculated.v_kbitrateReceived;
                  VideoStats.packetLossRate = stream.getPacketLossRate();
                  streamStats.candidatePair.forEach(function (stat) {
                    VideoStats.rtt = stat.currentRoundTripTime * 1000;
                  });

                  remoteVideoStatsMap[streamId] = VideoStats;
                });
                return _context9.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(remoteVideoStatsMap));

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getRemoteVideoStats() {
        return _ref9.apply(this, arguments);
      }

      return getRemoteVideoStats;
    }()

    /**
     * 获取当前网络传输状况统计数据，该方法需要在有本地推流时调用。
     * @return Promise.<map.<streamId, RemoteVideoStat>>
     * transportStats {
     * rtt: currentRoundTripTime(ms)
     * subscribeRTT: {streamId: rtt, streamId: rtt}
     * }
     */

  }, {
    key: "getTransportStats",
    value: function () {
      var _ref10 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee10() {
        var transportStats;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                transportStats = {};

                _common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].forEach(function (stream) {
                  var streamStats = stream.getStats();
                  streamStats.candidatePair.forEach(function (stat) {
                    transportStats.rtt = stat.currentRoundTripTime * 1000;
                  });
                });
                _common_Contant__WEBPACK_IMPORTED_MODULE_8__["streamObjMap"].forEach(function (stream, streamId) {
                  if (_common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].get(streamId)) {
                    return;
                  }
                  var streamStats = stream.getStats();
                  streamStats.candidatePair.forEach(function (stat) {
                    if (!transportStats.hasOwnProperty("subscribeRTT")) {
                      transportStats.subscribeRTT = {};
                    }
                    transportStats.subscribeRTT[streamId] = stat.currentRoundTripTime * 1000;
                  });
                });
                return _context10.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(transportStats));

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTransportStats() {
        return _ref10.apply(this, arguments);
      }

      return getTransportStats;
    }()

    /**
     * 获取当前的本地流。
     * @return object.<streamId, stream>
     */

  }, {
    key: "getLocalStreams",
    value: function getLocalStreams() {
      var localStreams = {};
      _common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].forEach(function (stream, streamId) {
        localStreams[streamId] = stream;
      });

      return localStreams;
    }
    /**
     * 获取当前的远端流。
     * @return object.<streamId, stream>
     */

  }, {
    key: "getRemoteStreams",
    value: function getRemoteStreams() {
      var remoteStreams = {};
      _common_Contant__WEBPACK_IMPORTED_MODULE_8__["streamObjMap"].forEach(function (stream, streamId) {
        if (_common_Contant__WEBPACK_IMPORTED_MODULE_8__["localStreamMap"].get(streamId)) {
          return;
        }
        remoteStreams[streamId] = stream;
      });

      return remoteStreams;
    }

    // 此play 是流ID MediaElement的play方法   

  }, {
    key: "play",
    value: function play(opt) {
      var _this4 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a(function (resolve, reject) {
        if (!opt.streamId) {
          var errInfo = { code: "611001", message: "缺少streamId", data: {} };
          reject(errInfo);
        }
        if (!_this4.streamObjMap.get(opt.streamId)) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
        }
        var streamObj = _this4.streamObjMap.get(opt.streamId);
        streamObj.playTag().then(function (res) {
          resolve(res);
        }).catch(function (err) {
          reject(err);
        });
      });
    }

    // 此pause 是流ID MediaElement的play方法  

  }, {
    key: "pause",
    value: function pause(opt) {
      var _this5 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a(function (resolve, reject) {
        if (!opt.streamId) {
          var errInfo = { code: "611001", message: "缺少streamId", data: {} };
          reject(errInfo);
        }
        if (!_this5.streamObjMap.get(opt.streamId)) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
        }
        var streamObj = _this5.streamObjMap.get(opt.streamId);
        streamObj.pauseTag().then(function (res) {
          resolve(res);
        }).catch(function (err) {
          reject(err);
        });
      });
    }
  }, {
    key: "setStreamFullscreen",
    value: function setStreamFullscreen(opt) {
      var _this6 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a(function (resolve, reject) {
        if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.streamId) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
        }
        if (opt.vNode && opt.vNode == "") {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_DOM_NOT_EXIST);
        }
        if (!_this6.streamObjMap.get(opt.streamId)) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
        }
        var streamObj = _this6.streamObjMap.get(opt.streamId);
        streamObj.setFullscreen(opt).then(function (res) {
          resolve(res);
        }).catch(function (err) {
          reject(err);
        });
      });
    }
  }, {
    key: "exitStreamFullscreen",
    value: function exitStreamFullscreen(opt) {
      var _this7 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a(function (resolve, reject) {
        if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.streamId) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
        }
        if (opt.vNode && opt.vNode == "") {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_DOM_NOT_EXIST);
        }
        if (!_this7.streamObjMap.get(opt.streamId)) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
        }
        var streamObj = _this7.streamObjMap.get(opt.streamId);
        streamObj.exitFullscreen(opt).then(function (res) {
          resolve(res);
        }).catch(function (err) {
          reject(err);
        });
      });
    }
  }, {
    key: "setBeautyLevel",
    value: function setBeautyLevel(opt) {
      var _this8 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a(function (resolve, reject) {
        if ((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.streamId || !opt.level || opt.level > 1 || opt.level < 0) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS);
        }
        if (!_this8.streamObjMap.get(opt.streamId)) {
          reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST);
        }
        var streamObj = _this8.streamObjMap.get(opt.streamId);
        resolve(streamObj.setBeautyLevel(opt.level));
      });
    }
  }, {
    key: "startBeauty",
    value: function () {
      var _ref11 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee11(opt) {
        var streamObj;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.streamId || !opt.level || opt.level > 1 || opt.level < 0)) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (this.streamObjMap.get(opt.streamId)) {
                  _context11.next = 4;
                  break;
                }

                return _context11.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST));

              case 4:
                streamObj = this.streamObjMap.get(opt.streamId);
                _context11.next = 7;
                return streamObj.startBeauty(opt);

              case 7:
                _context11.next = 9;
                return streamObj.replaceBeauty();

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function startBeauty(_x15) {
        return _ref11.apply(this, arguments);
      }

      return startBeauty;
    }()
  }, {
    key: "destroyBeauty",
    value: function () {
      var _ref12 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee12(opt) {
        var streamObj;
        return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!((typeof opt === "undefined" ? "undefined" : babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_3___default()(opt)) !== "object" || !opt.streamId)) {
                  _context12.next = 2;
                  break;
                }

                return _context12.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_INVALID_PARAMETERS));

              case 2:
                if (this.streamObjMap.get(opt.streamId)) {
                  _context12.next = 4;
                  break;
                }

                return _context12.abrupt("return", babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_2___default.a.reject(_common_Contant__WEBPACK_IMPORTED_MODULE_8__["ERR"].ERR_STREAM_NOT_EXIST));

              case 4:
                streamObj = this.streamObjMap.get(opt.streamId);
                _context12.next = 7;
                return streamObj.destroyBeauty();

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function destroyBeauty(_x16) {
        return _ref12.apply(this, arguments);
      }

      return destroyBeauty;
    }()
  }]);

  return StreamsApi;
}();



/***/ }),

/***/ "./src/common/Config.js":
/*!******************************!*\
  !*** ./src/common/Config.js ***!
  \******************************/
/*! exports provided: CONFIG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/** 生产环境api配置 */
var PROD_CONFIG = {
  API_SERVER: "//api.vhallyun.com/sdk",
  REPORT_SERVER: "//dc.e.vhall.com/login",
  BASE_MESSAGE_URL: "https://static.vhallyun.com/jssdk/vhall-jssdk-base/vhall-msg-1.0.9.js?t=" + Date.now()
};

/** 开发环境api配置 */
var DEVELOP_CONFIG = {
  API_SERVER: "//test-api.vhallyun.com/sdk",
  REPORT_SERVER: "//t-dc.e.vhall.com/login",
  BASE_MESSAGE_URL: "https://t-static01-open.e.vhall.com/jssdk/vhall-jssdk-base/vhall-msg-1.0.9.js?t=" + Date.now()
};

var CONFIG =  false ? undefined : DEVELOP_CONFIG;

/***/ }),

/***/ "./src/common/Contant.js":
/*!*******************************!*\
  !*** ./src/common/Contant.js ***!
  \*******************************/
/*! exports provided: Constant, CANVAS_LAYOUT, CANVAS_ADAPTIVE_LAYOUT, BROADCAST_PANE_ASPACT, BROADCAST_CROP_TYPE, ERR, EVENT, streamObjMap, localStreamMap, VRTC_MODES, CLIENT_ROLES, KV, API_URL, PUBLISH_LAYOUT, PUBLISH_PROFILE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Constant", function() { return Constant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_LAYOUT", function() { return CANVAS_LAYOUT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_ADAPTIVE_LAYOUT", function() { return CANVAS_ADAPTIVE_LAYOUT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BROADCAST_PANE_ASPACT", function() { return BROADCAST_PANE_ASPACT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BROADCAST_CROP_TYPE", function() { return BROADCAST_CROP_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR", function() { return ERR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVENT", function() { return EVENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "streamObjMap", function() { return streamObjMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localStreamMap", function() { return localStreamMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VRTC_MODES", function() { return VRTC_MODES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLIENT_ROLES", function() { return CLIENT_ROLES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KV", function() { return KV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_URL", function() { return API_URL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PUBLISH_LAYOUT", function() { return PUBLISH_LAYOUT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PUBLISH_PROFILE", function() { return PUBLISH_PROFILE; });
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/map */ "./node_modules/babel-runtime/core-js/map.js");
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rtcbase/src/Main */ "./rtcbase/src/Main.js");

// import vhallILSSDK from "../../rtcbase/v1.2.0.11/vhallILSSDK";

var VhallConstant = _rtcbase_src_Main__WEBPACK_IMPORTED_MODULE_1__["default"].Vhallcall;

// 底层音视频参数常量
var Constant = {};
for (var i in VhallConstant) {
  if (VhallConstant.hasOwnProperty(i)) {
    Constant[i] = VhallConstant[i];
  }
}
// 底层各种参数的取值范围，用于校验
var CANVAS_LAYOUT = [];
for (var _i in VhallConstant) {
  if (_i.indexOf("CANVAS_LAYOUT_") === 0) {
    CANVAS_LAYOUT.push(VhallConstant[_i]);
  }
}
var CANVAS_ADAPTIVE_LAYOUT = [];
for (var _i2 in VhallConstant) {
  if (_i2.indexOf("CANVAS_ADAPTIVE_LAYOUT_") === 0) {
    CANVAS_ADAPTIVE_LAYOUT.push(VhallConstant[_i2]);
  }
}
var BROADCAST_PANE_ASPACT = [];
for (var _i3 in VhallConstant) {
  if (_i3.indexOf("BROADCAST_PANE_ASPACT_") === 0) {
    BROADCAST_PANE_ASPACT.push(VhallConstant[_i3]);
  }
}
var BROADCAST_CROP_TYPE = [];
for (var _i4 in VhallConstant) {
  if (_i4.indexOf("BROADCAST_CROP_TYPE_") === 0) {
    BROADCAST_CROP_TYPE.push(VhallConstant[_i4]);
  }
}

// 方法错误信息
var ERR = {
  ERR_INVALID_PARAMETERS: { code: "611001", message: "无效的参数", data: {} },
  ERR_STREAM_NOT_EXIST: { code: "611006", message: "该streamId不存在", data: {} },
  ERR_DOM_NOT_EXIST: { code: "611003", message: "dom节点不存在", data: {} }

  // 事件常量
};var EVENT = {
  MASTER: "MASTER", // *废弃
  GUEST: "GUEST", //*废弃
  EVENT_ROOM_DISCONNECTED: "EVENT_ROOM_DISCONNECTED", // 房间断开事件
  EVENT_ROOM_EXCDISCONNECTED: "EVENT_ROOM_EXCDISCONNECTED", // 房间异常断开事件
  EVENT_ROOM_AUTH: "EVENT_ROOM_AUTH", // 审核上麦事件
  EVENT_ROOM_BLACKLIST: "EVENT_ROOM_BLACKLIST", // 添加用户进黑名单事件
  EVENT_ROOM_INVITED: "EVENT_ROOM_INVITED", // 被邀请上麦事件
  EVENT_ROOM_APPLY: "EVENT_ROOM_APPLY", //  申请上麦事件
  EVENT_ROOM_CALLBACK: "EVENT_ROOM_CALLBACK", // 邀请上麦回复事件
  EVENT_ROOM_JOIN: "EVENT_ROOM_JOIN", // 用户加入房间事件
  EVENT_ROOM_LEAVE: "EVENT_ROOM_LEAVE", // 用户离开房间事件
  EVENT_REMOTESTREAM_ADD: "EVENT_REMOTESTREAM_ADD", // 远端流添加事件
  EVENT_REMOTESTREAM_REMOVED: "EVENT_REMOTESTREAM_REMOVED", // 远端流删除事件
  EVENT_REMOTESTREAM_MUTE: "EVENT_REMOTESTREAM_MUTE", // 远端流音视频状态改变事件
  EVENT_ROOM_CLOSE: "EVENT_ROOM_CLOSE", // 房间关闭事件   *废弃
  EVENT_ROOM_ERROR: "EVENT_ROOM_ERROR", // 房间链接出错                   *已废弃
  EVENT_REMOTESTREAM_FAILED: "EVENT_REMOTESTREAM_FAILED", // 推拉流异常事件      
  EVENT_STREAM_END: "EVENT_STREAM_END", // 音视频数据中断事件
  EVENT_STREAM_STUNK: "EVENT_STREAM_STUNK", // 视频编码异常事件
  EVENT_DEVICE_CHANGE: "EVENT_DEVICE_CHANGE", // 音视频设备列表更新事件
  EVENT_ROOM_FORCELEAVE: "EVENT_ROOM_FORCELEAVE", // 强行用户踢出事件
  EVENT_STREAM_PLAYABORT: "EVENT_STREAM_PLAYABORT", // Video/Audio的终止事件
  EVENT_NETWORK_CHANGE: "EVENT_NETWORK_CHANGE" // 网络状态变化事件
};

var streamObjMap = new babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0___default.a();
var localStreamMap = new babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0___default.a();

var VRTC_MODES = {
  MODE_RTC: "rtc",
  MODE_LIVE: "live"
};
var CLIENT_ROLES = {
  ROLE_HOST: "administrator",
  ROLE_AUDIENCE: "viewer"
};

var KV = {
  APP_ID: "app_id",
  ACCOUNTID: "third_party_user_id",
  CLIENT: "client",
  ACCESS_TOKEN: "access_token",
  PACKAGE_CHECK: "package_check",
  INAVID: "inavid",
  ROOMID: "roomId",
  PUSH_URL: "pushUrl",
  LOG_SERVER: "log_server", // 日志上报地址
  VIDEO_NODE: "videoNode",
  CLIENT_ROLE: "role",
  VRTC_MODE: "mode",
  AUTOSTARTBROADCAST: "autoStartBroadcast",
  BROADCASTCONFIG: "broadcastConfig"
};

var API_URL = {
  INIT: "/v1/init/start", // 获取token接口
  GET_INVINFO: "/v2/inav/get-inav-info", // 获取互动房间信息
  GET_INV_USERLIST: "/v2/inav/inav-user-list", // 获取互动房间人员列表
  GET_TOKEN_PERMISSION: "/v2/inav/get-access-token-permission", //查看AccessToken是否具有某权限
  GET_KICK_LIST: "/v2/inav/get-kick-inav-list", //获取提出房间名单列表
  PUBLISH_INAV_BROADCAST: "/v2/inav/publish-inav-another", //发起旁路直播
  AUDIT_INAV_PUBLISH: "/v2/inav/audit-inav-publish", //审核申请上麦
  ASKFOR_INAV_PUBLISH: "/v2/inav/askfor-inav-publish", //邀请上麦
  USER_PUBLISH_CALLBACK: "/v2/inav/user-publish-callback", //上/下/拒绝上麦状态回执
  APPLY_INAV_PUBLISH: "/v2/inav/apply-inav-publish", //申请上麦
  KICK_INAV: "/v2/inav/kick-inav", //踢出互动房间/取消踢出互动房间
  PUSH_ANOTHER_CONFIG: "/v2/inav/push-another-config",
  GET_PUBLISH_INFO: "/v2/room/get-publish-info",
  // LEAVE_INAV: "/v2/inav/leaveForceInav" // 离开互动房间
  LEAVE_INAV: "/v2/inav/leave-room-force-inav" //离开互动房间
};

// 以下，仅publish推流sdk有使用
var PUBLISH_LAYOUT = {};
var PUBLISH_PROFILE = {};
for (var key in VhallConstant) {
  if (VhallConstant.hasOwnProperty(key)) {
    var value = VhallConstant[key];
    if (key.indexOf("CANVAS_LAYOUT") !== -1) {
      PUBLISH_LAYOUT[key] = value;
    }
    if (key.indexOf("VIDEO_PROFILE") !== -1) {
      PUBLISH_PROFILE[key] = value;
    }
    if (key.indexOf("BROADCAST_VIDEO_PROFILE") !== -1) {
      delete PUBLISH_PROFILE[key];
    }
  }
}

/***/ }),

/***/ "./src/server/API.js":
/*!***************************!*\
  !*** ./src/server/API.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return API; });
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Http */ "./src/server/Http.js");
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/Contant */ "./src/common/Contant.js");






var API = function () {
  function API(store) {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, API);

    this.store = store;
  }

  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(API, [{
    key: "init",
    value: function init() {
      var _this = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].INIT);
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }
    // 获取互动房间信息

  }, {
    key: "getInavInfo",
    value: function getInavInfo(inavId, roomId, mode, role) {
      var _this2 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this2.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].GET_INVINFO, { inav_id: inavId, room_id: roomId, mode: mode, role: role });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 获取推流房间信息

  }, {
    key: "getPublishInfo",
    value: function getPublishInfo(roomId) {
      var _this3 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this3.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].GET_PUBLISH_INFO, { room_id: roomId });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 获取互动房间人员列表

  }, {
    key: "getInavUserlist",
    value: function getInavUserlist(inavId) {
      var _this4 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this4.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].GET_INV_USERLIST, { inav_id: inavId });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 查看AccessToken是否具有某权限

  }, {
    key: "getTokenPermission",
    value: function getTokenPermission(inavId, permission) {
      var _this5 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this5.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].GET_TOKEN_PERMISSION, {
          resourse_id: inavId,
          permission: permission
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 获取互动被踢人列表（黑名单列表）

  }, {
    key: "getKickList",
    value: function getKickList(inavId) {
      var _this6 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this6.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].GET_KICK_LIST, {
          inav_id: inavId
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 发起旁路直播

  }, {
    key: "publishInavBroadcast",
    value: function publishInavBroadcast(params) {
      var _this7 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this7.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].PUBLISH_INAV_BROADCAST, {
          inav_id: params.inavId, //互动房间ID
          room_id: params.roomId, //直播房间ID
          type: params.type, //开启 1 默认 / 关闭 2
          dpi: params.dpi || "", //分辨率 480P, 540P, 720P (默认),1080P
          frame_rate: params.frameRate || "", //帧率 15, 20 (默认), 25 帧
          bitrate: params.bitrate || "", //码率 800, 1000 (默认), 1200
          layout: params.layout || "", //旁路直播布局 具体见下旁路直播布局设置
          max_screen_stream: params.maxScreenStream || "" //设置屏占比最大的流ID
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 审核申请上麦

  }, {
    key: "auditInavPublish",
    value: function auditInavPublish(param) {
      var _this8 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this8.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].AUDIT_INAV_PUBLISH, {
          inav_id: param.inavId,
          audit_user_id: param.userId,
          audit_type: param.type
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 邀请上麦

  }, {
    key: "askforInavPublish",
    value: function askforInavPublish(params) {
      var _this9 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this9.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].ASKFOR_INAV_PUBLISH, {
          inav_id: params.inavId,
          askfor_third_user_id: params.userId
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 上/下/拒绝上麦状态回执

  }, {
    key: "userPublishCallback",
    value: function userPublishCallback(params) {
      var _this10 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this10.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].USER_PUBLISH_CALLBACK, {
          inav_id: params.inavId,
          stream_id: params.streamId,
          type: params.type
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 申请上麦

  }, {
    key: "applyInavPublish",
    value: function applyInavPublish(inavId) {
      var _this11 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this11.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].APPLY_INAV_PUBLISH, {
          inav_id: inavId
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 踢出互动房间/取消踢出互动房间

  }, {
    key: "kickInav",
    value: function kickInav(params) {
      var _this12 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this12.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].KICK_INAV, {
          inav_id: params.inavId,
          type: params.type,
          kick_user_id: params.userId
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }

    // 开关旁路 （通知PHP）

  }, {
    key: "setBroadCast",
    value: function setBroadCast(params) {
      var _this13 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this13.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].PUSH_ANOTHER_CONFIG, {
          inav_id: params.inavId,
          room_id: params.roomId,
          type: params.type
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }
  }, {
    key: "LeaveInav",
    value: function LeaveInav(inavId, userId) {
      var _this14 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this14.store);
        http.fire(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["API_URL"].LEAVE_INAV, {
          inav_id: inavId,
          kick_user_id: userId
        });
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }
  }, {
    key: "report",
    value: function report(params) {
      var _this15 = this;

      return new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_0___default.a(function (resolve, reject) {
        var http = new _Http__WEBPACK_IMPORTED_MODULE_3__["default"](_this15.store);
        http.fire("", params, "report", "GET");
        http.onError = function (e) {
          return reject(e);
        };
        http.onLoad = function (e) {
          return resolve(e);
        };
      });
    }
  }]);

  return API;
}();



/***/ }),

/***/ "./src/server/Http.js":
/*!****************************!*\
  !*** ./src/server/Http.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Http; });
/* harmony import */ var babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");
/* harmony import */ var babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/Config */ "./src/common/Config.js");
/* harmony import */ var _common_Contant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/Contant */ "./src/common/Contant.js");
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_5__);








/**
 * 简单封装
 *
 * @export
 * @class Http
 * @author zhenliang.sun
 */

var Http = function () {
  function Http(store) {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Http);

    this.store = store;
    this.e = {
      error: this._onError.bind(this),
      timeout: this._onTimeout.bind(this),
      onload: this._onLoad.bind(this),
      onLoadend: this._onLoadend.bind(this)
    };

    this.xhr = new XMLHttpRequest();
    this.xhr.responseType = "json";
    this.xhr.timeout = 5000;
    this.xhr.onerror = this.e.error;
    this.xhr.timeout = this.e.timeout;
    this.xhr.onload = this.e.onload;
    this.xhr.onloadend = this.e.onLoadend;

    this.onError = null;
    this.onLoad = null;
    this.onLoadend = null;
    this.onTimeout = null;
  }

  /**
   * inner method
   *
   * @param {*} e
   * @memberof Http
   */


  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Http, [{
    key: "_onError",
    value: function _onError(e) {
      this.onError && this.onError(e.target.response);
      this.onError = null;
    }

    /**
     * inner method
     *
     * @param {*} e
     * @memberof Http
     */

  }, {
    key: "_onLoad",
    value: function _onLoad(e) {
      if (!e.target) {
        this._onError(e);
        return;
      }

      if (!e.target.response) {
        this._onError(e);
        return;
      }

      var _e$target$response = e.target.response,
          code = _e$target$response.code,
          data = _e$target$response.data;

      if (+code !== 200) {
        this._onError(e);
        return;
      }

      this.onLoad && this.onLoad(data);
      this.onLoad = null;
    }

    /**
     * inner method
     *
     * @param {*} e
     * @memberof Http
     */

  }, {
    key: "_onLoadend",
    value: function _onLoadend(e) {
      this.onLoadend && this.onLoadend(e.target);
      this.onLoadend = null;
    }

    /**
     * inner method
     *
     * @param {*} e
     * @memberof Http
     */

  }, {
    key: "_onTimeout",
    value: function _onTimeout(e) {
      this.onTimeout && this.onTimeout(e.target);
      this.onTimeout = null;
    }

    /**
     * 发送请求
     *
     * @param {*} url API的URL
     * @param {*} data FormData
     * @param {string} [method='POST']
     * @memberof Http
     */

  }, {
    key: "fire",
    value: function fire(apiURL) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "api";
      var method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "POST";

      if (!this.xhr) {
        return;
      }

      var server = type === "api" ? _common_Config__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].API_SERVER : _common_Config__WEBPACK_IMPORTED_MODULE_3__["CONFIG"].REPORT_SERVER;
      var url = server + apiURL;

      // 构建formData数据
      var formData = new FormData();
      formData.set(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].CLIENT, this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].CLIENT));
      formData.set(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].APP_ID, this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].APP_ID));
      formData.set(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].ACCOUNTID, this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].ACCOUNTID));
      formData.set(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].ACCESS_TOKEN, this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].ACCESS_TOKEN));
      formData.set(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].PACKAGE_CHECK, this.store.getKV(_common_Contant__WEBPACK_IMPORTED_MODULE_4__["KV"].PACKAGE_CHECK));

      babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0___default()(data).forEach(function (keys) {
        formData.set(keys, data[keys]);
      });

      if (method === "POST") {
        this.xhr.open(method, url);
        this.xhr.send(formData);
      } else if (method === "GET") {
        var obj = {};
        formData.forEach(function (value, key) {
          obj[key] = value;
        });
        url += "?" + qs__WEBPACK_IMPORTED_MODULE_5___default.a.stringify(obj);
        this.xhr.open(method, url);
        this.xhr.send();
      }
    }

    /**
     * HTTP模块销毁
     *
     * @memberof Http
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.xhr) {
        return;
      }

      this.xhr.onerror = null;
      this.xhr.onload = null;
      this.xhr.onloadend = null;
      this.xhr.ontimeout = null;
      this.xhr = null;

      this.onLoad = null;
      this.onLoadend = null;
      this.onTimeout = null;
      this.onError = null;
    }
  }]);

  return Http;
}();



/***/ }),

/***/ "./src/tools/Events.js":
/*!*****************************!*\
  !*** ./src/tools/Events.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventDispatcher; });
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);



var EventDispatcher = function () {
  function EventDispatcher() {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, EventDispatcher);

    this.dispatcher = {
      eventListeners: {},
      onceListeners: {}
    };
  }

  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(EventDispatcher, [{
    key: "addEventListener",
    value: function addEventListener(eventType, listener) {
      if (this.dispatcher.eventListeners[eventType] === undefined) {
        this.dispatcher.eventListeners[eventType] = [];
      }
      this.dispatcher.eventListeners[eventType].push(listener);
    }
  }, {
    key: "once",
    value: function once(eventType, listener) {
      if (this.dispatcher.onceListeners[eventType] === undefined) {
        this.dispatcher.onceListeners[eventType] = [];
      }

      this.dispatcher.onceListeners[eventType].push(listener);
    }
  }, {
    key: "removeOnceListener",
    value: function removeOnceListener(eventType, listener) {
      if (!this.dispatcher.onceListeners[eventType]) {
        return;
      }
      this.dispatcher.onceListeners[eventType] = this.dispatcher.onceListeners[eventType].filter(function (fn) {
        return fn !== listener;
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(eventType, listener) {
      if (!this.dispatcher.eventListeners[eventType]) {
        return;
      }

      this.dispatcher.eventListeners[eventType] = this.dispatcher.eventListeners[eventType].filter(function (fn) {
        return fn !== listener;
      });
    }
  }, {
    key: "removeAllListener",
    value: function removeAllListener() {
      this.dispatcher.eventListeners = {};
      this.dispatcher.onceListeners = {};
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event, data) {
      if (!event) {
        throw new Error("Undefined event");
      }
      var listeners = this.dispatcher.eventListeners[event] || [];
      for (var i = 0; i < listeners.length; i += 1) {
        listeners[i](data);
      }

      var onceListeners = this.dispatcher.onceListeners[event] || [];
      for (var _i = 0; _i < onceListeners.length; _i += 1) {
        onceListeners[_i](data);
      }
      delete this.dispatcher.onceListeners[event];
    }
  }]);

  return EventDispatcher;
}();



/***/ }),

/***/ "./src/tools/RoomInfo.js":
/*!*******************************!*\
  !*** ./src/tools/RoomInfo.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/map */ "./node_modules/babel-runtime/core-js/map.js");
/* harmony import */ var babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);




var RoomInfo = function () {
  function RoomInfo() {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, RoomInfo);

    this.localMap = new babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0___default.a();
    this.remoteMap = new babel_runtime_core_js_map__WEBPACK_IMPORTED_MODULE_0___default.a();
  }

  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(RoomInfo, [{
    key: 'setLocalMap',
    value: function setLocalMap(key, value) {
      this.localMap.set(key, value || []);
    }
  }, {
    key: 'getLocalMap',
    value: function getLocalMap(key) {
      return this.localMap.get(key);
    }
  }, {
    key: 'addLocalStream',
    value: function addLocalStream(key, streamObj) {
      if (!this.localMap.get(key)) {
        return;
      }
      var newArr = this.localMap.get(key);
      newArr.push(streamObj);
      this.localMap.set(key, newArr);
    }
  }, {
    key: 'updateStream',
    value: function updateStream(opt) {
      console.warn('updateStream----', opt, opt.streamId, 'localMap', this.localMap, 'remoteMap:', this.remoteMap);

      var _arr = [];
      if (this.localMap.get(opt.key)) {
        _arr = this.localMap.get(opt.key);
      } else if (this.remoteMap.get(opt.key)) {
        _arr = this.localMap.get(opt.key);
      }

      console.log('cxs----1', _arr);
      _arr && _arr.forEach(function (stream) {
        console.log('cxs----2', stream);
        stream.streamId == opt.streamId && opt.type == 'video' ? stream.videoMuted = opt.mute : '';
        stream.streamId == opt.streamId && opt.type == 'audio' ? stream.audioMuted = opt.mute : '';
      });
    }
  }, {
    key: 'removeLocalStream',
    value: function removeLocalStream(key, streamId) {
      if (!this.localMap.get(key)) {
        return;
      }
      var newArr = [];
      for (var index = 0; index < this.localMap.get(key).length; index++) {
        var item = this.localMap.get(key)[index];
        if (item.streamId === streamId) {
          continue;
        }
        newArr.push(item);
      }
      this.localMap.set(key, newArr);
    }
  }, {
    key: 'removeLocalMap',
    value: function removeLocalMap(key) {
      this.localMap.delete(key);
    }
  }, {
    key: 'clearLocalMap',
    value: function clearLocalMap() {
      this.localMap.clear();
    }
  }, {
    key: 'setRemoteMap',
    value: function setRemoteMap(key, value) {
      this.remoteMap.set(key, value || []);
    }
  }, {
    key: 'addRemoteStream',
    value: function addRemoteStream(key, streamObj) {
      if (!this.remoteMap.get(key)) {
        return;
      }
      var newArr = this.remoteMap.get(key);
      newArr.push(streamObj);
      this.remoteMap.set(key, newArr);
    }
  }, {
    key: 'removeRemoteStream',
    value: function removeRemoteStream(key, streamId) {
      if (!this.remoteMap.get(key)) {
        return;
      }
      var newArr = [];
      for (var index = 0; index < this.remoteMap.get(key).length; index++) {
        var item = this.remoteMap.get(key)[index];
        if (item.streamId === streamId) {
          continue;
        }
        newArr.push(item);
      }
      this.remoteMap.set(key, newArr);
    }
  }, {
    key: 'getRemoteMap',
    value: function getRemoteMap(key) {
      return this.remoteMap.get(key);
    }
  }, {
    key: 'removeRemoteMap',
    value: function removeRemoteMap(key) {
      this.remoteMap.delete(key);
    }
  }, {
    key: 'clearRemoteMap',
    value: function clearRemoteMap() {
      this.remoteMap.clear();
    }
  }, {
    key: 'getRoomStreams',
    value: function getRoomStreams() {
      var _this = this;

      var _localStream = [];
      var _remoteStream = [];
      var roomStreams = [];

      this.localMap.forEach(function (items, key) {
        _localStream.push(_this.reviseInfo(items, key));
      });

      this.remoteMap.forEach(function (items, key) {
        _remoteStream.push(_this.reviseInfo(items, key));
      });
      try {
        roomStreams = [_localStream.concat(_remoteStream)].flat(Infinity);
      } catch (error) {
        roomStreams = _localStream.concat(_remoteStream);
        console.error("remoteStream merge localStream message fail is---", error);
      }

      return roomStreams;
    }
  }, {
    key: 'reviseInfo',
    value: function reviseInfo(items, key) {
      if (Object.prototype.toString.call(items) === "[object Array]") {
        items.forEach(function (item) {
          item.hasOwnProperty("state") ? (item.streamStatus = item.state, delete item.state) : "";
          item.hasOwnProperty("status") ? (item.streamStatus = item.status, delete item.status) : "";
          item.hasOwnProperty("type") ? (item.streamSource = item.type, delete item.type) : "";
          item.accountId = key;
        });
      } else {
        items.hasOwnProperty("state") ? (items.streamStatus = items.state, delete items.state) : "";
        items.hasOwnProperty("status") ? (items.streamStatus = items.status, delete items.status) : "";
        items.hasOwnProperty("type") ? (items.streamSource = items.type, delete items.type) : "";
        items.accountId = key;
      }
      return items;
    }
  }, {
    key: 'getRoomInfo',
    value: function getRoomInfo() {
      var localInfo = {
        user: {
          accountId: null,
          streams: []
        }
      };
      var remoteInfo = {
        users: []
      };

      this.localMap.forEach(function (item, key) {
        localInfo.user.accountId = key;
        localInfo.user.streams = item || [];
      });

      this.remoteMap.forEach(function (item, key) {
        remoteInfo.users.push({
          accountId: key,
          streams: item || []
        });
      });
      return {
        local: localInfo,
        remote: remoteInfo
      };
    }
  }]);

  return RoomInfo;
}();

/* harmony default export */ __webpack_exports__["default"] = (RoomInfo);

/***/ }),

/***/ "./src/tools/Store.js":
/*!****************************!*\
  !*** ./src/tools/Store.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Store; });
/* harmony import */ var babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");
/* harmony import */ var babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);




var Store = function () {
  function Store() {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Store);

    this.info = {};
  }

  /**
   * 根据KV价值对进行存储
   *
   * @param {*} key
   * @param {*} value
   * @memberof Store
   */


  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Store, [{
    key: "setKV",
    value: function setKV(key, value) {
      this.info[key] = value;
    }

    /**
     * 根据key获取
     *
     * @param {*} key
     * @returns
     * @memberof Store
     */

  }, {
    key: "getKV",
    value: function getKV(key) {
      return this.info[key];
    }

    /**
     * 根据key删除键值对
     *
     * @param {*} key
     * @memberof Store
     */

  }, {
    key: "deleteKey",
    value: function deleteKey(key) {
      if (this.info.hasOwnProperty(key)) {
        delete this.info[key];
      }
    }

    /**
     * 重置键值对
     *
     * @memberof Store
     */

  }, {
    key: "reset",
    value: function reset() {
      this.info = {};
    }
  }, {
    key: "toString",
    value: function toString() {
      var _this = this;

      var keys = babel_runtime_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0___default()(this.info);
      var tmp = "";
      keys.forEach(function (key) {
        tmp += key + ":" + _this.info[key] + " ";
      });
      return tmp;
    }
  }]);

  return Store;
}();



/***/ }),

/***/ "./src/tools/Utils.js":
/*!****************************!*\
  !*** ./src/tools/Utils.js ***!
  \****************************/
/*! exports provided: createVhallMsg, checkDevice, mixin, mixinInst, getDevice, filterDevices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVhallMsg", function() { return createVhallMsg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkDevice", function() { return checkDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mixin", function() { return mixin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mixinInst", function() { return mixinInst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDevice", function() { return getDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterDevices", function() { return filterDevices; });
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ "./node_modules/babel-runtime/core-js/get-iterator.js");
/* harmony import */ var babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var babel_runtime_core_js_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-names */ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js");
/* harmony import */ var babel_runtime_core_js_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");
/* harmony import */ var babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");
/* harmony import */ var babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");
/* harmony import */ var babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _common_Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/Config */ "./src/common/Config.js");






/**
 * 加载base
 */
var loadMsgScript = function () {
  var _ref = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee() {
    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_3___default.a(function (resolve, reject) {
              if (document.getElementById("VhallBaseSDK")) {
                resolve(true);
                return;
              }
              var scriptEl = document.createElement("script");
              scriptEl.setAttribute("type", "text/javascript");
              scriptEl.setAttribute("id", "VhallBaseSDK");
              scriptEl.setAttribute("src", _common_Config__WEBPACK_IMPORTED_MODULE_5__["CONFIG"].BASE_MESSAGE_URL);
              document.head.appendChild(scriptEl);
              scriptEl.onload = function () {
                return resolve(true);
              };
              scriptEl.onerror = function () {
                return reject(false);
              };
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function loadMsgScript() {
    return _ref.apply(this, arguments);
  };
}();

/**
 * 创建VhallMsg
 * @param {object} opt 入参
 */


var createVhallMsg = function () {
  var _ref2 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee2(opt) {
    var appId, accountId, token, inavId, hide, isLoadScript;
    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            appId = opt.appId, accountId = opt.accountId, token = opt.token, inavId = opt.inavId, hide = opt.hide;
            _context2.next = 3;
            return loadMsgScript();

          case 3:
            isLoadScript = _context2.sent;
            return _context2.abrupt("return", new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_3___default.a(function (resolve, reject) {
              if (isLoadScript) {
                VhallMsg.createInstance({ appId: appId, third_party_user_id: accountId, token: token, channelId: inavId, hide: hide }, function (msg) {
                  resolve(msg);
                }, function () {
                  reject({ code: "", message: "Base加载失败", data: {} });
                });
              }
            }));

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function createVhallMsg(_x) {
    return _ref2.apply(this, arguments);
  };
}();

// 检测设备
function checkDevice() {
  if (navigator.userAgent.match(/AppleWebKit.*Mobile.*/)) {
    //判断是否是移动设备打开。browser代码在下面
    var ua = navigator.userAgent.toLowerCase(); //获取判断用的对象
    if (ua.match(/MicroMessenger/i) == "micromessenger") {
      return "wechat_browser";
    }
    return "h5_browser";
  } else {
    return "pc_browser";
  }
}

function mixin(target, MixinConstructor) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var source = new (Function.prototype.bind.apply(MixinConstructor, [null].concat(args)))();
  var names = babel_runtime_core_js_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_1___default()(MixinConstructor.prototype);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0___default()(names), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var name = _step.value;

      var val = source[name];
      if (typeof val === "function" && name !== "constructor") {
        target[name] = val.bind(source);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function mixinInst(target, source) {
  var names = babel_runtime_core_js_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_1___default()(source.constructor.prototype);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = babel_runtime_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0___default()(names), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var name = _step2.value;

      var val = source[name];
      if (typeof val === "function" && name !== "constructor") {
        target[name] = val.bind(source);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

var getDevice = function () {
  var _ref3 = babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4___default()( /*#__PURE__*/babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee3() {
    return babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", new babel_runtime_core_js_promise__WEBPACK_IMPORTED_MODULE_3___default.a(function (resolve, reject) {
              navigator.mediaDevices.enumerateDevices().then(function (devices) {
                var arr = devices.filter(function (item) {
                  return item.kind === "videoinput";
                });
                navigator.getUserMedia({ audio: true, video: arr.length !== 0 }, function (stream) {
                  resolve(devices);
                  stream.getTracks().forEach(function (trackInput) {
                    trackInput.stop();
                  });
                }, function (err) {
                  reject(err);
                });
              }).catch(function (err) {
                reject(err);
              });
            }));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function getDevice() {
    return _ref3.apply(this, arguments);
  };
}();

function filterDevices(devices, flag) {
  return devices.filter(function (item) {
    return item.kind === flag;
  }).map(function (item) {
    return item.label;
  });
}

/***/ })

/******/ });
//# sourceMappingURL=vhall-jssdk-interaction-2.3.6.js.map